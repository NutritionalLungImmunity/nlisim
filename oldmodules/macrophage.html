<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nlisim.oldmodules.macrophage API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nlisim.oldmodules.macrophage</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
from random import choice, shuffle
from typing import Any, Dict, Tuple

import attr
import numpy as np

from nlisim.cell import CellData, CellList
from nlisim.coordinates import Point, Voxel
from nlisim.grid import RectangularGrid
from nlisim.module import ModuleModel, ModuleState
from nlisim.oldmodules.fungus import FungusCellData, FungusCellList
from nlisim.random import rg
from nlisim.state import State
from nlisim.util import TissueType

MAX_CONIDIA = 100

# np.warnings.filterwarnings(&#39;error&#39;, category=np.VisibleDeprecationWarning)


class MacrophageCellData(CellData):
    MACROPHAGE_FIELDS = [
        (&#39;iteration&#39;, &#39;i4&#39;),
        (&#39;phagosome&#39;, (np.int32, (MAX_CONIDIA))),
    ]

    dtype = np.dtype(CellData.FIELDS + MACROPHAGE_FIELDS, align=True)  # type: ignore

    @classmethod
    def create_cell_tuple(
        cls,
        **kwargs,
    ) -&gt; Tuple:
        iteration = 0
        phagosome = np.empty(MAX_CONIDIA)
        phagosome.fill(-1)
        return CellData.create_cell_tuple(**kwargs) + (
            iteration,
            phagosome,
        )


@attr.s(kw_only=True, frozen=True, repr=False)
class MacrophageCellList(CellList):
    CellDataClass = MacrophageCellData

    def len_phagosome(self, index):
        cell = self[index]
        return len(np.argwhere(cell[&#39;phagosome&#39;] != -1))

    def append_to_phagosome(self, index, pathogen_index, max_size):
        cell = self[index]
        index_to_append = MacrophageCellList.len_phagosome(self, index)
        if (
            index_to_append &lt; MAX_CONIDIA
            and index_to_append &lt; max_size
            and pathogen_index not in cell[&#39;phagosome&#39;]
        ):
            cell[&#39;phagosome&#39;][index_to_append] = pathogen_index
            return True
        else:
            return False

    def remove_from_phagosome(self, index, pathogen_index):
        phagosome = self[index][&#39;phagosome&#39;]
        if pathogen_index in phagosome:
            itemindex = np.argwhere(phagosome == pathogen_index)[0][0]
            size = MacrophageCellList.len_phagosome(self, index)
            if itemindex == size - 1:
                # full phagosome
                phagosome[itemindex] = -1
                return True
            else:
                phagosome[itemindex:-1] = phagosome[itemindex + 1 :]
                phagosome[-1] = -1
                return True
        else:
            return False

    def clear_all_phagosome(self, index, fungus: FungusCellList):
        for i in range(0, self.len_phagosome(index)):
            index = self[index][&#39;phagosome&#39;][i]
            fungus[index][&#39;internalized&#39;] = False
        self[index][&#39;phagosome&#39;].fill(-1)

    def recruit_new(self, rec_rate_ph, rec_r, p_rec_r, tissue, grid, cyto):
        num_reps = rec_rate_ph  # maximum number of macrophages recruited per time step

        cyto_index = np.argwhere(np.logical_and(tissue == TissueType.BLOOD.value, cyto &gt;= rec_r))
        if len(cyto_index) == 0:
            # nowhere to place cells
            return

        for _ in range(num_reps):
            if p_rec_r &gt; rg.random():
                ii = rg.integers(cyto_index.shape[0])
                point = Point(
                    x=grid.x[cyto_index[ii, 2]],
                    y=grid.y[cyto_index[ii, 1]],
                    z=grid.z[cyto_index[ii, 0]],
                )
                # Do we really want these things to always be in the exact center of the voxel?
                # No we do not. Should not have any effect on model, but maybe some on
                # visualization.
                perturbation = rg.multivariate_normal(
                    mean=[0.0, 0.0, 0.0], cov=[[0.25, 0.0, 0.0], [0.0, 0.25, 0.0], [0.0, 0.0, 0.25]]
                )
                perturbation_magnitude = np.linalg.norm(perturbation)
                perturbation /= max(1.0, perturbation_magnitude)
                point += perturbation
                self.append(MacrophageCellData.create_cell(point=point))

    def absorb_cytokines(self, m_abs, cyto, grid):
        for index in self.alive():
            vox = grid.get_voxel(self[index][&#39;point&#39;])
            x = vox.x
            y = vox.y
            z = vox.z
            cyto[z, y, x] = (1 - m_abs) * cyto[z, y, x]

    def produce_cytokines(self, m_det, m_n, grid, fungus: FungusCellList, cyto):
        for i in self.alive():
            vox = grid.get_voxel(self[i][&#39;point&#39;])

            hyphae_count = 0

            # Moore neighborhood
            neighborhood = tuple(itertools.product(tuple(range(-1 * m_det, m_det + 1)), repeat=3))

            for dx, dy, dz in neighborhood:
                zi = vox.z + dz
                yj = vox.y + dy
                xk = vox.x + dx
                if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                    index_arr = fungus.get_cells_in_voxel(Voxel(x=xk, y=yj, z=zi))
                    for index in index_arr:
                        if fungus[index][&#39;form&#39;] == FungusCellData.Form.HYPHAE:
                            hyphae_count += 1

            cyto[vox.z, vox.y, vox.x] = cyto[vox.z, vox.y, vox.x] + m_n * hyphae_count

    def move(self, rec_r, grid, cyto, tissue, fungus: FungusCellList):
        for cell_index in self.alive():
            cell = self[cell_index]
            cell_voxel = grid.get_voxel(cell[&#39;point&#39;])

            valid_voxel_offsets = []
            above_threshold_voxel_offsets = []

            # iterate over nearby voxels, recording the cytokine levels
            for dx, dy, dz in itertools.product((-1, 0, 1), repeat=3):
                zi = cell_voxel.z + dz
                yj = cell_voxel.y + dy
                xk = cell_voxel.x + dx
                if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                    if tissue[zi, yj, xk] != TissueType.AIR.value:
                        valid_voxel_offsets.append((dx, dy, dz))
                        if cyto[zi, yj, xk] &gt;= rec_r:
                            above_threshold_voxel_offsets.append((cyto[zi, yj, xk], (dx, dy, dz)))

            # pick a target for the move
            if len(above_threshold_voxel_offsets) &gt; 0:
                # shuffle + sort (with _only_ 0-key, not lexicographic as tuples) ensures
                # randomization when there are equal top cytokine levels
                # note that numpy&#39;s shuffle will complain about ragged arrays
                shuffle(above_threshold_voxel_offsets)
                above_threshold_voxel_offsets = sorted(
                    above_threshold_voxel_offsets, key=lambda x: x[0], reverse=True
                )
                _, target_voxel_offset = above_threshold_voxel_offsets[0]
            elif len(valid_voxel_offsets) &gt; 0:
                target_voxel_offset = choice(valid_voxel_offsets)
            else:
                raise AssertionError(
                    &#39;This cell has no valid voxel to move to, including the one that it is in!&#39;
                )

            # Some nonsense here, b/c jump is happening at the voxel level, not the point level
            starting_cell_point = Point(x=cell[&#39;point&#39;][2], y=cell[&#39;point&#39;][1], z=cell[&#39;point&#39;][0])
            starting_cell_voxel = grid.get_voxel(starting_cell_point)
            ending_cell_voxel = grid.get_voxel(
                Point(
                    x=grid.x[cell_voxel.x + target_voxel_offset[0]],
                    y=grid.y[cell_voxel.y + target_voxel_offset[1]],
                    z=grid.z[cell_voxel.z + target_voxel_offset[2]],
                )
            )
            ending_cell_point = (
                starting_cell_point
                + grid.get_voxel_center(ending_cell_voxel)
                - grid.get_voxel_center(starting_cell_voxel)
            )

            cell[&#39;point&#39;] = ending_cell_point
            self.update_voxel_index([cell_index])

            for i in range(0, self.len_phagosome(cell_index)):
                f_index = cell[&#39;phagosome&#39;][i]
                fungus[f_index][&#39;point&#39;] = ending_cell_point
                fungus.update_voxel_index([f_index])

    def internalize_conidia(self, m_det, max_spores, p_in, grid, fungus: FungusCellList):
        for i in self.alive():
            cell = self[i]
            vox = grid.get_voxel(cell[&#39;point&#39;])

            # Moore neighborhood, but order partially randomized. Closest to furthest order, but
            # the order of any set of points of equal distance is random
            neighborhood = list(itertools.product(tuple(range(-1 * m_det, m_det + 1)), repeat=3))
            shuffle(neighborhood)
            neighborhood = sorted(neighborhood, key=lambda v: v[0] ** 2 + v[1] ** 2 + v[2] ** 2)

            for dx, dy, dz in neighborhood:
                zi = vox.z + dz
                yj = vox.y + dy
                xk = vox.x + dx
                if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                    index_arr = fungus.get_cells_in_voxel(Voxel(x=xk, y=yj, z=zi))
                    for index in index_arr:
                        if (
                            fungus[index][&#39;form&#39;] == FungusCellData.Form.CONIDIA
                            and not fungus[index][&#39;internalized&#39;]
                            and p_in &gt; rg.random()
                        ):
                            fungus[index][&#39;internalized&#39;] = True
                            self.append_to_phagosome(i, index, max_spores)

    def damage_conidia(self, kill, t, health, fungus):
        for i in self.alive():
            cell = self[i]
            for ii in range(0, self.len_phagosome(i)):
                index = cell[&#39;phagosome&#39;][ii]
                fungus[index][&#39;health&#39;] = fungus[index][&#39;health&#39;] - (health * (t / kill))
                if fungus[index][&#39;dead&#39;]:
                    self.remove_from_phagosome(i, index)

    def remove_if_sporeless(self, val):
        living = self.alive()
        living_len = len(living)
        num = int(val * living_len)
        if num == 0 and living_len &gt; 0:
            num = 1
        for _ in range(num):
            r = rg.integers(living_len)
            self.cell_data[living[r]][&#39;dead&#39;] = True


def cell_list_factory(self: &#39;MacrophageState&#39;):
    return MacrophageCellList(grid=self.global_state.grid)


@attr.s(kw_only=True)
class MacrophageState(ModuleState):
    cells: MacrophageCellList = attr.ib(default=attr.Factory(cell_list_factory, takes_self=True))
    rec_r: float
    p_rec_r: float
    m_abs: float
    m_n: float
    kill: float
    m_det: int
    rec_rate_ph: int
    time_m: float
    max_conidia_in_phag: int
    p_internalization: float
    rm: float


class Macrophage(ModuleModel):
    name = &#39;macrophage&#39;
    StateClass = MacrophageState

    def initialize(self, state: State):
        macrophage: MacrophageState = state.macrophage
        grid: RectangularGrid = state.grid

        macrophage.rec_r = self.config.getfloat(&#39;rec_r&#39;)
        macrophage.p_rec_r = self.config.getfloat(&#39;p_rec_r&#39;)
        macrophage.m_abs = self.config.getfloat(&#39;m_abs&#39;)
        macrophage.m_n = self.config.getfloat(&#39;Mn&#39;)
        macrophage.kill = self.config.getfloat(&#39;kill&#39;)
        macrophage.m_det = self.config.getint(&#39;m_det&#39;)  # radius
        macrophage.rec_rate_ph = self.config.getint(&#39;rec_rate_ph&#39;)
        macrophage.time_m = self.config.getfloat(&#39;time_m&#39;)
        macrophage.max_conidia_in_phag = self.config.getint(&#39;max_conidia_in_phag&#39;)
        macrophage.rm = self.config.getfloat(&#39;rm&#39;)
        macrophage.p_internalization = self.config.getfloat(&#39;p_internalization&#39;)
        macrophage.cells = MacrophageCellList(grid=grid)

        return state

    def advance(self, state: State, previous_time: float):
        macrophage: MacrophageState = state.macrophage
        m_cells: MacrophageCellList = macrophage.cells
        tissue = state.geometry.lung_tissue
        grid = state.grid
        cyto = state.molecules.grid[&#39;m_cyto&#39;]
        n_cyto = state.molecules.grid[&#39;n_cyto&#39;]
        fungus: FungusCellList = state.fungus.cells
        health = state.fungus.health

        # recruit new
        m_cells.recruit_new(
            macrophage.rec_rate_ph, macrophage.rec_r, macrophage.p_rec_r, tissue, grid, cyto
        )

        # absorb cytokines
        m_cells.absorb_cytokines(macrophage.m_abs, cyto, grid)

        # produce cytokines
        m_cells.produce_cytokines(macrophage.m_det, macrophage.m_n, grid, fungus, n_cyto)

        # move
        m_cells.move(macrophage.rec_r, grid, cyto, tissue, fungus)

        # internalize
        m_cells.internalize_conidia(
            macrophage.m_det,
            macrophage.max_conidia_in_phag,
            macrophage.p_internalization,
            grid,
            fungus,
        )

        # damage conidia
        m_cells.damage_conidia(macrophage.kill, macrophage.time_m, health, fungus)

        if len(fungus.alive(fungus.cell_data[&#39;form&#39;] == FungusCellData.Form.CONIDIA)) == 0:
            m_cells.remove_if_sporeless(macrophage.rm)

        return state

    def summary_stats(self, state: State) -&gt; Dict[str, Any]:
        macrophage: MacrophageState = state.macrophage

        num_phagosome: int = 0
        for cell_index in macrophage.cells.alive():
            cell: MacrophageCellData = macrophage.cells[cell_index]
            num_phagosome += np.sum(cell[&#39;phagosome&#39;] &gt;= 0)

        return {
            &#39;count&#39;: len(macrophage.cells.alive()),
            &#39;phagosome&#39;: int(num_phagosome),
        }

    def visualization_data(self, state: State) -&gt; Tuple[str, Any]:
        return &#39;cells&#39;, state.macrophage.cells</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nlisim.oldmodules.macrophage.cell_list_factory"><code class="name flex">
<span>def <span class="ident">cell_list_factory</span></span>(<span>self: <a title="nlisim.oldmodules.macrophage.MacrophageState" href="#nlisim.oldmodules.macrophage.MacrophageState">MacrophageState</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_list_factory(self: &#39;MacrophageState&#39;):
    return MacrophageCellList(grid=self.global_state.grid)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nlisim.oldmodules.macrophage.Macrophage"><code class="flex name class">
<span>class <span class="ident">Macrophage</span></span>
<span>(</span><span>config: <a title="nlisim.config.SimulationConfig" href="../config.html#nlisim.config.SimulationConfig">SimulationConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Macrophage(ModuleModel):
    name = &#39;macrophage&#39;
    StateClass = MacrophageState

    def initialize(self, state: State):
        macrophage: MacrophageState = state.macrophage
        grid: RectangularGrid = state.grid

        macrophage.rec_r = self.config.getfloat(&#39;rec_r&#39;)
        macrophage.p_rec_r = self.config.getfloat(&#39;p_rec_r&#39;)
        macrophage.m_abs = self.config.getfloat(&#39;m_abs&#39;)
        macrophage.m_n = self.config.getfloat(&#39;Mn&#39;)
        macrophage.kill = self.config.getfloat(&#39;kill&#39;)
        macrophage.m_det = self.config.getint(&#39;m_det&#39;)  # radius
        macrophage.rec_rate_ph = self.config.getint(&#39;rec_rate_ph&#39;)
        macrophage.time_m = self.config.getfloat(&#39;time_m&#39;)
        macrophage.max_conidia_in_phag = self.config.getint(&#39;max_conidia_in_phag&#39;)
        macrophage.rm = self.config.getfloat(&#39;rm&#39;)
        macrophage.p_internalization = self.config.getfloat(&#39;p_internalization&#39;)
        macrophage.cells = MacrophageCellList(grid=grid)

        return state

    def advance(self, state: State, previous_time: float):
        macrophage: MacrophageState = state.macrophage
        m_cells: MacrophageCellList = macrophage.cells
        tissue = state.geometry.lung_tissue
        grid = state.grid
        cyto = state.molecules.grid[&#39;m_cyto&#39;]
        n_cyto = state.molecules.grid[&#39;n_cyto&#39;]
        fungus: FungusCellList = state.fungus.cells
        health = state.fungus.health

        # recruit new
        m_cells.recruit_new(
            macrophage.rec_rate_ph, macrophage.rec_r, macrophage.p_rec_r, tissue, grid, cyto
        )

        # absorb cytokines
        m_cells.absorb_cytokines(macrophage.m_abs, cyto, grid)

        # produce cytokines
        m_cells.produce_cytokines(macrophage.m_det, macrophage.m_n, grid, fungus, n_cyto)

        # move
        m_cells.move(macrophage.rec_r, grid, cyto, tissue, fungus)

        # internalize
        m_cells.internalize_conidia(
            macrophage.m_det,
            macrophage.max_conidia_in_phag,
            macrophage.p_internalization,
            grid,
            fungus,
        )

        # damage conidia
        m_cells.damage_conidia(macrophage.kill, macrophage.time_m, health, fungus)

        if len(fungus.alive(fungus.cell_data[&#39;form&#39;] == FungusCellData.Form.CONIDIA)) == 0:
            m_cells.remove_if_sporeless(macrophage.rm)

        return state

    def summary_stats(self, state: State) -&gt; Dict[str, Any]:
        macrophage: MacrophageState = state.macrophage

        num_phagosome: int = 0
        for cell_index in macrophage.cells.alive():
            cell: MacrophageCellData = macrophage.cells[cell_index]
            num_phagosome += np.sum(cell[&#39;phagosome&#39;] &gt;= 0)

        return {
            &#39;count&#39;: len(macrophage.cells.alive()),
            &#39;phagosome&#39;: int(num_phagosome),
        }

    def visualization_data(self, state: State) -&gt; Tuple[str, Any]:
        return &#39;cells&#39;, state.macrophage.cells</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleModel.StateClass" href="../module.html#nlisim.module.ModuleModel.StateClass">StateClass</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.advance" href="../module.html#nlisim.module.ModuleModel.advance">advance</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.construct" href="../module.html#nlisim.module.ModuleModel.construct">construct</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.finalize" href="../module.html#nlisim.module.ModuleModel.finalize">finalize</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.initialize" href="../module.html#nlisim.module.ModuleModel.initialize">initialize</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.name" href="../module.html#nlisim.module.ModuleModel.name">name</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.section" href="../module.html#nlisim.module.ModuleModel.section">section</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.summary_stats" href="../module.html#nlisim.module.ModuleModel.summary_stats">summary_stats</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.time_step" href="../module.html#nlisim.module.ModuleModel.time_step">time_step</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.visualization_data" href="../module.html#nlisim.module.ModuleModel.visualization_data">visualization_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellData"><code class="flex name class">
<span>class <span class="ident">MacrophageCellData</span></span>
<span>(</span><span>arg: Union[int, Iterable[ForwardRef('CellData')]], initialize: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A low-level data contain for an array cells.</p>
<p>This class is a subtype of
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html">numpy.recarray</a>
containing the lowest level representation of a list of "cells" in a
simulation.
The underlying data format of this type are identical to a
simple array of C structures with the fields given in the static "dtype"
variable.</p>
<p>The base class contains only a single coordinate representing the location
of the center of the cell.
Most implementations will want to override this
class to append more fields.
Subclasses must also override the base
implementation of <code>create_cell</code> to construct a single record containing
the additional fields.</p>
<p>For example, the following derived class adds an addition floating point value
associated with each cell.</p>
<pre><code class="language-python">class DerivedCell(CellData):
    FIELDS = CellData.FIELDS + [
        ('iron_content', 'f8')
    ]

    dtype = np.dtype(CellData.FIELDS, align=True)

    @classmethod
    def create_cell_tuple(cls, iron_content=0, **kwargs) -&gt; Tuple:
        return CellData.create_cell_tuple(**kwargs) + (iron_content,)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MacrophageCellData(CellData):
    MACROPHAGE_FIELDS = [
        (&#39;iteration&#39;, &#39;i4&#39;),
        (&#39;phagosome&#39;, (np.int32, (MAX_CONIDIA))),
    ]

    dtype = np.dtype(CellData.FIELDS + MACROPHAGE_FIELDS, align=True)  # type: ignore

    @classmethod
    def create_cell_tuple(
        cls,
        **kwargs,
    ) -&gt; Tuple:
        iteration = 0
        phagosome = np.empty(MAX_CONIDIA)
        phagosome.fill(-1)
        return CellData.create_cell_tuple(**kwargs) + (
            iteration,
            phagosome,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></li>
<li>numpy.ndarray</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellData.MACROPHAGE_FIELDS"><code class="name">var <span class="ident">MACROPHAGE_FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellData.FIELDS" href="../cell.html#nlisim.cell.CellData.FIELDS">FIELDS</a></code></li>
<li><code><a title="nlisim.cell.CellData.create_cell" href="../cell.html#nlisim.cell.CellData.create_cell">create_cell</a></code></li>
<li><code><a title="nlisim.cell.CellData.create_cell_tuple" href="../cell.html#nlisim.cell.CellData.create_cell_tuple">create_cell_tuple</a></code></li>
<li><code><a title="nlisim.cell.CellData.dtype" href="../cell.html#nlisim.cell.CellData.dtype">dtype</a></code></li>
<li><code><a title="nlisim.cell.CellData.point_mask" href="../cell.html#nlisim.cell.CellData.point_mask">point_mask</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList"><code class="flex name class">
<span>class <span class="ident">MacrophageCellList</span></span>
<span>(</span><span>*, grid: <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a>, max_cells: int = 1000000, cell_data: <a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>A python view on top of a CellData array.</p>
<p>This class represents a pythonic interface to the data contained in a
CellData array.
Because the CellData class is a low-level object, it does
not allow dynamically appending new elements.
Objects of this class get
around this limitation by pre-allocating a large block of memory that is
transparently available.
User-facing properties are sliced to make it
appear as if the extra data is not there.</p>
<p>Subclassed types are expected to set the <code>CellDataClass</code> attribute to
a subclass of <code>CellData</code>.
This provides information about the underlying
low-level array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>simulation.grid.RectangularGrid</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_cells</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>cells</code></strong> :&ensp;<code>simulation.cell.CellData</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Method generated by attrs for class MacrophageCellList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MacrophageCellList(CellList):
    CellDataClass = MacrophageCellData

    def len_phagosome(self, index):
        cell = self[index]
        return len(np.argwhere(cell[&#39;phagosome&#39;] != -1))

    def append_to_phagosome(self, index, pathogen_index, max_size):
        cell = self[index]
        index_to_append = MacrophageCellList.len_phagosome(self, index)
        if (
            index_to_append &lt; MAX_CONIDIA
            and index_to_append &lt; max_size
            and pathogen_index not in cell[&#39;phagosome&#39;]
        ):
            cell[&#39;phagosome&#39;][index_to_append] = pathogen_index
            return True
        else:
            return False

    def remove_from_phagosome(self, index, pathogen_index):
        phagosome = self[index][&#39;phagosome&#39;]
        if pathogen_index in phagosome:
            itemindex = np.argwhere(phagosome == pathogen_index)[0][0]
            size = MacrophageCellList.len_phagosome(self, index)
            if itemindex == size - 1:
                # full phagosome
                phagosome[itemindex] = -1
                return True
            else:
                phagosome[itemindex:-1] = phagosome[itemindex + 1 :]
                phagosome[-1] = -1
                return True
        else:
            return False

    def clear_all_phagosome(self, index, fungus: FungusCellList):
        for i in range(0, self.len_phagosome(index)):
            index = self[index][&#39;phagosome&#39;][i]
            fungus[index][&#39;internalized&#39;] = False
        self[index][&#39;phagosome&#39;].fill(-1)

    def recruit_new(self, rec_rate_ph, rec_r, p_rec_r, tissue, grid, cyto):
        num_reps = rec_rate_ph  # maximum number of macrophages recruited per time step

        cyto_index = np.argwhere(np.logical_and(tissue == TissueType.BLOOD.value, cyto &gt;= rec_r))
        if len(cyto_index) == 0:
            # nowhere to place cells
            return

        for _ in range(num_reps):
            if p_rec_r &gt; rg.random():
                ii = rg.integers(cyto_index.shape[0])
                point = Point(
                    x=grid.x[cyto_index[ii, 2]],
                    y=grid.y[cyto_index[ii, 1]],
                    z=grid.z[cyto_index[ii, 0]],
                )
                # Do we really want these things to always be in the exact center of the voxel?
                # No we do not. Should not have any effect on model, but maybe some on
                # visualization.
                perturbation = rg.multivariate_normal(
                    mean=[0.0, 0.0, 0.0], cov=[[0.25, 0.0, 0.0], [0.0, 0.25, 0.0], [0.0, 0.0, 0.25]]
                )
                perturbation_magnitude = np.linalg.norm(perturbation)
                perturbation /= max(1.0, perturbation_magnitude)
                point += perturbation
                self.append(MacrophageCellData.create_cell(point=point))

    def absorb_cytokines(self, m_abs, cyto, grid):
        for index in self.alive():
            vox = grid.get_voxel(self[index][&#39;point&#39;])
            x = vox.x
            y = vox.y
            z = vox.z
            cyto[z, y, x] = (1 - m_abs) * cyto[z, y, x]

    def produce_cytokines(self, m_det, m_n, grid, fungus: FungusCellList, cyto):
        for i in self.alive():
            vox = grid.get_voxel(self[i][&#39;point&#39;])

            hyphae_count = 0

            # Moore neighborhood
            neighborhood = tuple(itertools.product(tuple(range(-1 * m_det, m_det + 1)), repeat=3))

            for dx, dy, dz in neighborhood:
                zi = vox.z + dz
                yj = vox.y + dy
                xk = vox.x + dx
                if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                    index_arr = fungus.get_cells_in_voxel(Voxel(x=xk, y=yj, z=zi))
                    for index in index_arr:
                        if fungus[index][&#39;form&#39;] == FungusCellData.Form.HYPHAE:
                            hyphae_count += 1

            cyto[vox.z, vox.y, vox.x] = cyto[vox.z, vox.y, vox.x] + m_n * hyphae_count

    def move(self, rec_r, grid, cyto, tissue, fungus: FungusCellList):
        for cell_index in self.alive():
            cell = self[cell_index]
            cell_voxel = grid.get_voxel(cell[&#39;point&#39;])

            valid_voxel_offsets = []
            above_threshold_voxel_offsets = []

            # iterate over nearby voxels, recording the cytokine levels
            for dx, dy, dz in itertools.product((-1, 0, 1), repeat=3):
                zi = cell_voxel.z + dz
                yj = cell_voxel.y + dy
                xk = cell_voxel.x + dx
                if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                    if tissue[zi, yj, xk] != TissueType.AIR.value:
                        valid_voxel_offsets.append((dx, dy, dz))
                        if cyto[zi, yj, xk] &gt;= rec_r:
                            above_threshold_voxel_offsets.append((cyto[zi, yj, xk], (dx, dy, dz)))

            # pick a target for the move
            if len(above_threshold_voxel_offsets) &gt; 0:
                # shuffle + sort (with _only_ 0-key, not lexicographic as tuples) ensures
                # randomization when there are equal top cytokine levels
                # note that numpy&#39;s shuffle will complain about ragged arrays
                shuffle(above_threshold_voxel_offsets)
                above_threshold_voxel_offsets = sorted(
                    above_threshold_voxel_offsets, key=lambda x: x[0], reverse=True
                )
                _, target_voxel_offset = above_threshold_voxel_offsets[0]
            elif len(valid_voxel_offsets) &gt; 0:
                target_voxel_offset = choice(valid_voxel_offsets)
            else:
                raise AssertionError(
                    &#39;This cell has no valid voxel to move to, including the one that it is in!&#39;
                )

            # Some nonsense here, b/c jump is happening at the voxel level, not the point level
            starting_cell_point = Point(x=cell[&#39;point&#39;][2], y=cell[&#39;point&#39;][1], z=cell[&#39;point&#39;][0])
            starting_cell_voxel = grid.get_voxel(starting_cell_point)
            ending_cell_voxel = grid.get_voxel(
                Point(
                    x=grid.x[cell_voxel.x + target_voxel_offset[0]],
                    y=grid.y[cell_voxel.y + target_voxel_offset[1]],
                    z=grid.z[cell_voxel.z + target_voxel_offset[2]],
                )
            )
            ending_cell_point = (
                starting_cell_point
                + grid.get_voxel_center(ending_cell_voxel)
                - grid.get_voxel_center(starting_cell_voxel)
            )

            cell[&#39;point&#39;] = ending_cell_point
            self.update_voxel_index([cell_index])

            for i in range(0, self.len_phagosome(cell_index)):
                f_index = cell[&#39;phagosome&#39;][i]
                fungus[f_index][&#39;point&#39;] = ending_cell_point
                fungus.update_voxel_index([f_index])

    def internalize_conidia(self, m_det, max_spores, p_in, grid, fungus: FungusCellList):
        for i in self.alive():
            cell = self[i]
            vox = grid.get_voxel(cell[&#39;point&#39;])

            # Moore neighborhood, but order partially randomized. Closest to furthest order, but
            # the order of any set of points of equal distance is random
            neighborhood = list(itertools.product(tuple(range(-1 * m_det, m_det + 1)), repeat=3))
            shuffle(neighborhood)
            neighborhood = sorted(neighborhood, key=lambda v: v[0] ** 2 + v[1] ** 2 + v[2] ** 2)

            for dx, dy, dz in neighborhood:
                zi = vox.z + dz
                yj = vox.y + dy
                xk = vox.x + dx
                if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                    index_arr = fungus.get_cells_in_voxel(Voxel(x=xk, y=yj, z=zi))
                    for index in index_arr:
                        if (
                            fungus[index][&#39;form&#39;] == FungusCellData.Form.CONIDIA
                            and not fungus[index][&#39;internalized&#39;]
                            and p_in &gt; rg.random()
                        ):
                            fungus[index][&#39;internalized&#39;] = True
                            self.append_to_phagosome(i, index, max_spores)

    def damage_conidia(self, kill, t, health, fungus):
        for i in self.alive():
            cell = self[i]
            for ii in range(0, self.len_phagosome(i)):
                index = cell[&#39;phagosome&#39;][ii]
                fungus[index][&#39;health&#39;] = fungus[index][&#39;health&#39;] - (health * (t / kill))
                if fungus[index][&#39;dead&#39;]:
                    self.remove_from_phagosome(i, index)

    def remove_if_sporeless(self, val):
        living = self.alive()
        living_len = len(living)
        num = int(val * living_len)
        if num == 0 and living_len &gt; 0:
            num = 1
        for _ in range(num):
            r = rg.integers(living_len)
            self.cell_data[living[r]][&#39;dead&#39;] = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.grid"><code class="name">var <span class="ident">grid</span> : <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.max_cells"><code class="name">var <span class="ident">max_cells</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.absorb_cytokines"><code class="name flex">
<span>def <span class="ident">absorb_cytokines</span></span>(<span>self, m_abs, cyto, grid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absorb_cytokines(self, m_abs, cyto, grid):
    for index in self.alive():
        vox = grid.get_voxel(self[index][&#39;point&#39;])
        x = vox.x
        y = vox.y
        z = vox.z
        cyto[z, y, x] = (1 - m_abs) * cyto[z, y, x]</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.append_to_phagosome"><code class="name flex">
<span>def <span class="ident">append_to_phagosome</span></span>(<span>self, index, pathogen_index, max_size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_to_phagosome(self, index, pathogen_index, max_size):
    cell = self[index]
    index_to_append = MacrophageCellList.len_phagosome(self, index)
    if (
        index_to_append &lt; MAX_CONIDIA
        and index_to_append &lt; max_size
        and pathogen_index not in cell[&#39;phagosome&#39;]
    ):
        cell[&#39;phagosome&#39;][index_to_append] = pathogen_index
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.clear_all_phagosome"><code class="name flex">
<span>def <span class="ident">clear_all_phagosome</span></span>(<span>self, index, fungus: <a title="nlisim.oldmodules.fungus.FungusCellList" href="fungus.html#nlisim.oldmodules.fungus.FungusCellList">FungusCellList</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_all_phagosome(self, index, fungus: FungusCellList):
    for i in range(0, self.len_phagosome(index)):
        index = self[index][&#39;phagosome&#39;][i]
        fungus[index][&#39;internalized&#39;] = False
    self[index][&#39;phagosome&#39;].fill(-1)</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.damage_conidia"><code class="name flex">
<span>def <span class="ident">damage_conidia</span></span>(<span>self, kill, t, health, fungus)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def damage_conidia(self, kill, t, health, fungus):
    for i in self.alive():
        cell = self[i]
        for ii in range(0, self.len_phagosome(i)):
            index = cell[&#39;phagosome&#39;][ii]
            fungus[index][&#39;health&#39;] = fungus[index][&#39;health&#39;] - (health * (t / kill))
            if fungus[index][&#39;dead&#39;]:
                self.remove_from_phagosome(i, index)</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.internalize_conidia"><code class="name flex">
<span>def <span class="ident">internalize_conidia</span></span>(<span>self, m_det, max_spores, p_in, grid, fungus: <a title="nlisim.oldmodules.fungus.FungusCellList" href="fungus.html#nlisim.oldmodules.fungus.FungusCellList">FungusCellList</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def internalize_conidia(self, m_det, max_spores, p_in, grid, fungus: FungusCellList):
    for i in self.alive():
        cell = self[i]
        vox = grid.get_voxel(cell[&#39;point&#39;])

        # Moore neighborhood, but order partially randomized. Closest to furthest order, but
        # the order of any set of points of equal distance is random
        neighborhood = list(itertools.product(tuple(range(-1 * m_det, m_det + 1)), repeat=3))
        shuffle(neighborhood)
        neighborhood = sorted(neighborhood, key=lambda v: v[0] ** 2 + v[1] ** 2 + v[2] ** 2)

        for dx, dy, dz in neighborhood:
            zi = vox.z + dz
            yj = vox.y + dy
            xk = vox.x + dx
            if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                index_arr = fungus.get_cells_in_voxel(Voxel(x=xk, y=yj, z=zi))
                for index in index_arr:
                    if (
                        fungus[index][&#39;form&#39;] == FungusCellData.Form.CONIDIA
                        and not fungus[index][&#39;internalized&#39;]
                        and p_in &gt; rg.random()
                    ):
                        fungus[index][&#39;internalized&#39;] = True
                        self.append_to_phagosome(i, index, max_spores)</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.len_phagosome"><code class="name flex">
<span>def <span class="ident">len_phagosome</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def len_phagosome(self, index):
    cell = self[index]
    return len(np.argwhere(cell[&#39;phagosome&#39;] != -1))</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, rec_r, grid, cyto, tissue, fungus: <a title="nlisim.oldmodules.fungus.FungusCellList" href="fungus.html#nlisim.oldmodules.fungus.FungusCellList">FungusCellList</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, rec_r, grid, cyto, tissue, fungus: FungusCellList):
    for cell_index in self.alive():
        cell = self[cell_index]
        cell_voxel = grid.get_voxel(cell[&#39;point&#39;])

        valid_voxel_offsets = []
        above_threshold_voxel_offsets = []

        # iterate over nearby voxels, recording the cytokine levels
        for dx, dy, dz in itertools.product((-1, 0, 1), repeat=3):
            zi = cell_voxel.z + dz
            yj = cell_voxel.y + dy
            xk = cell_voxel.x + dx
            if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                if tissue[zi, yj, xk] != TissueType.AIR.value:
                    valid_voxel_offsets.append((dx, dy, dz))
                    if cyto[zi, yj, xk] &gt;= rec_r:
                        above_threshold_voxel_offsets.append((cyto[zi, yj, xk], (dx, dy, dz)))

        # pick a target for the move
        if len(above_threshold_voxel_offsets) &gt; 0:
            # shuffle + sort (with _only_ 0-key, not lexicographic as tuples) ensures
            # randomization when there are equal top cytokine levels
            # note that numpy&#39;s shuffle will complain about ragged arrays
            shuffle(above_threshold_voxel_offsets)
            above_threshold_voxel_offsets = sorted(
                above_threshold_voxel_offsets, key=lambda x: x[0], reverse=True
            )
            _, target_voxel_offset = above_threshold_voxel_offsets[0]
        elif len(valid_voxel_offsets) &gt; 0:
            target_voxel_offset = choice(valid_voxel_offsets)
        else:
            raise AssertionError(
                &#39;This cell has no valid voxel to move to, including the one that it is in!&#39;
            )

        # Some nonsense here, b/c jump is happening at the voxel level, not the point level
        starting_cell_point = Point(x=cell[&#39;point&#39;][2], y=cell[&#39;point&#39;][1], z=cell[&#39;point&#39;][0])
        starting_cell_voxel = grid.get_voxel(starting_cell_point)
        ending_cell_voxel = grid.get_voxel(
            Point(
                x=grid.x[cell_voxel.x + target_voxel_offset[0]],
                y=grid.y[cell_voxel.y + target_voxel_offset[1]],
                z=grid.z[cell_voxel.z + target_voxel_offset[2]],
            )
        )
        ending_cell_point = (
            starting_cell_point
            + grid.get_voxel_center(ending_cell_voxel)
            - grid.get_voxel_center(starting_cell_voxel)
        )

        cell[&#39;point&#39;] = ending_cell_point
        self.update_voxel_index([cell_index])

        for i in range(0, self.len_phagosome(cell_index)):
            f_index = cell[&#39;phagosome&#39;][i]
            fungus[f_index][&#39;point&#39;] = ending_cell_point
            fungus.update_voxel_index([f_index])</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.produce_cytokines"><code class="name flex">
<span>def <span class="ident">produce_cytokines</span></span>(<span>self, m_det, m_n, grid, fungus: <a title="nlisim.oldmodules.fungus.FungusCellList" href="fungus.html#nlisim.oldmodules.fungus.FungusCellList">FungusCellList</a>, cyto)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def produce_cytokines(self, m_det, m_n, grid, fungus: FungusCellList, cyto):
    for i in self.alive():
        vox = grid.get_voxel(self[i][&#39;point&#39;])

        hyphae_count = 0

        # Moore neighborhood
        neighborhood = tuple(itertools.product(tuple(range(-1 * m_det, m_det + 1)), repeat=3))

        for dx, dy, dz in neighborhood:
            zi = vox.z + dz
            yj = vox.y + dy
            xk = vox.x + dx
            if grid.is_valid_voxel(Voxel(x=xk, y=yj, z=zi)):
                index_arr = fungus.get_cells_in_voxel(Voxel(x=xk, y=yj, z=zi))
                for index in index_arr:
                    if fungus[index][&#39;form&#39;] == FungusCellData.Form.HYPHAE:
                        hyphae_count += 1

        cyto[vox.z, vox.y, vox.x] = cyto[vox.z, vox.y, vox.x] + m_n * hyphae_count</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.recruit_new"><code class="name flex">
<span>def <span class="ident">recruit_new</span></span>(<span>self, rec_rate_ph, rec_r, p_rec_r, tissue, grid, cyto)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recruit_new(self, rec_rate_ph, rec_r, p_rec_r, tissue, grid, cyto):
    num_reps = rec_rate_ph  # maximum number of macrophages recruited per time step

    cyto_index = np.argwhere(np.logical_and(tissue == TissueType.BLOOD.value, cyto &gt;= rec_r))
    if len(cyto_index) == 0:
        # nowhere to place cells
        return

    for _ in range(num_reps):
        if p_rec_r &gt; rg.random():
            ii = rg.integers(cyto_index.shape[0])
            point = Point(
                x=grid.x[cyto_index[ii, 2]],
                y=grid.y[cyto_index[ii, 1]],
                z=grid.z[cyto_index[ii, 0]],
            )
            # Do we really want these things to always be in the exact center of the voxel?
            # No we do not. Should not have any effect on model, but maybe some on
            # visualization.
            perturbation = rg.multivariate_normal(
                mean=[0.0, 0.0, 0.0], cov=[[0.25, 0.0, 0.0], [0.0, 0.25, 0.0], [0.0, 0.0, 0.25]]
            )
            perturbation_magnitude = np.linalg.norm(perturbation)
            perturbation /= max(1.0, perturbation_magnitude)
            point += perturbation
            self.append(MacrophageCellData.create_cell(point=point))</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.remove_from_phagosome"><code class="name flex">
<span>def <span class="ident">remove_from_phagosome</span></span>(<span>self, index, pathogen_index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_from_phagosome(self, index, pathogen_index):
    phagosome = self[index][&#39;phagosome&#39;]
    if pathogen_index in phagosome:
        itemindex = np.argwhere(phagosome == pathogen_index)[0][0]
        size = MacrophageCellList.len_phagosome(self, index)
        if itemindex == size - 1:
            # full phagosome
            phagosome[itemindex] = -1
            return True
        else:
            phagosome[itemindex:-1] = phagosome[itemindex + 1 :]
            phagosome[-1] = -1
            return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageCellList.remove_if_sporeless"><code class="name flex">
<span>def <span class="ident">remove_if_sporeless</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_if_sporeless(self, val):
    living = self.alive()
    living_len = len(living)
    num = int(val * living_len)
    if num == 0 and living_len &gt; 0:
        num = 1
    for _ in range(num):
        r = rg.integers(living_len)
        self.cell_data[living[r]][&#39;dead&#39;] = True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellList.CellDataClass" href="../cell.html#nlisim.cell.CellList.CellDataClass">CellDataClass</a></code></li>
<li><code><a title="nlisim.cell.CellList.alive" href="../cell.html#nlisim.cell.CellList.alive">alive</a></code></li>
<li><code><a title="nlisim.cell.CellList.append" href="../cell.html#nlisim.cell.CellList.append">append</a></code></li>
<li><code><a title="nlisim.cell.CellList.cell_data" href="../cell.html#nlisim.cell.CellList.cell_data">cell_data</a></code></li>
<li><code><a title="nlisim.cell.CellList.create_from_seed" href="../cell.html#nlisim.cell.CellList.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="nlisim.cell.CellList.extend" href="../cell.html#nlisim.cell.CellList.extend">extend</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_cells_in_voxel" href="../cell.html#nlisim.cell.CellList.get_cells_in_voxel">get_cells_in_voxel</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_neighboring_cells" href="../cell.html#nlisim.cell.CellList.get_neighboring_cells">get_neighboring_cells</a></code></li>
<li><code><a title="nlisim.cell.CellList.load" href="../cell.html#nlisim.cell.CellList.load">load</a></code></li>
<li><code><a title="nlisim.cell.CellList.save" href="../cell.html#nlisim.cell.CellList.save">save</a></code></li>
<li><code><a title="nlisim.cell.CellList.update_voxel_index" href="../cell.html#nlisim.cell.CellList.update_voxel_index">update_voxel_index</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState"><code class="flex name class">
<span>class <span class="ident">MacrophageState</span></span>
<span>(</span><span>*, global_state: State, cells: <a title="nlisim.oldmodules.macrophage.MacrophageCellList" href="#nlisim.oldmodules.macrophage.MacrophageCellList">MacrophageCellList</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>Base type intended to store the state for simulation modules.</p>
<p>This class contains serialization support for basic types (float, int, str,
bool) and numpy arrays of those types.
Modules containing more complicated
state must override the serialization mechanism with custom behavior.</p>
<p>Method generated by attrs for class MacrophageState.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MacrophageState(ModuleState):
    cells: MacrophageCellList = attr.ib(default=attr.Factory(cell_list_factory, takes_self=True))
    rec_r: float
    p_rec_r: float
    m_abs: float
    m_n: float
    kill: float
    m_det: int
    rec_rate_ph: int
    time_m: float
    max_conidia_in_phag: int
    p_internalization: float
    rm: float</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.cells"><code class="name">var <span class="ident">cells</span> : <a title="nlisim.oldmodules.macrophage.MacrophageCellList" href="#nlisim.oldmodules.macrophage.MacrophageCellList">MacrophageCellList</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.kill"><code class="name">var <span class="ident">kill</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.m_abs"><code class="name">var <span class="ident">m_abs</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.m_det"><code class="name">var <span class="ident">m_det</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.m_n"><code class="name">var <span class="ident">m_n</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.max_conidia_in_phag"><code class="name">var <span class="ident">max_conidia_in_phag</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.p_internalization"><code class="name">var <span class="ident">p_internalization</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.p_rec_r"><code class="name">var <span class="ident">p_rec_r</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.rec_r"><code class="name">var <span class="ident">rec_r</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.rec_rate_ph"><code class="name">var <span class="ident">rec_rate_ph</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.rm"><code class="name">var <span class="ident">rm</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.oldmodules.macrophage.MacrophageState.time_m"><code class="name">var <span class="ident">time_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleState.load_attribute" href="../module.html#nlisim.module.ModuleState.load_attribute">load_attribute</a></code></li>
<li><code><a title="nlisim.module.ModuleState.load_state" href="../module.html#nlisim.module.ModuleState.load_state">load_state</a></code></li>
<li><code><a title="nlisim.module.ModuleState.save_attribute" href="../module.html#nlisim.module.ModuleState.save_attribute">save_attribute</a></code></li>
<li><code><a title="nlisim.module.ModuleState.save_state" href="../module.html#nlisim.module.ModuleState.save_state">save_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nlisim.oldmodules" href="index.html">nlisim.oldmodules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nlisim.oldmodules.macrophage.cell_list_factory" href="#nlisim.oldmodules.macrophage.cell_list_factory">cell_list_factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nlisim.oldmodules.macrophage.Macrophage" href="#nlisim.oldmodules.macrophage.Macrophage">Macrophage</a></code></h4>
</li>
<li>
<h4><code><a title="nlisim.oldmodules.macrophage.MacrophageCellData" href="#nlisim.oldmodules.macrophage.MacrophageCellData">MacrophageCellData</a></code></h4>
<ul class="">
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellData.MACROPHAGE_FIELDS" href="#nlisim.oldmodules.macrophage.MacrophageCellData.MACROPHAGE_FIELDS">MACROPHAGE_FIELDS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList" href="#nlisim.oldmodules.macrophage.MacrophageCellList">MacrophageCellList</a></code></h4>
<ul class="">
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.absorb_cytokines" href="#nlisim.oldmodules.macrophage.MacrophageCellList.absorb_cytokines">absorb_cytokines</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.append_to_phagosome" href="#nlisim.oldmodules.macrophage.MacrophageCellList.append_to_phagosome">append_to_phagosome</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.clear_all_phagosome" href="#nlisim.oldmodules.macrophage.MacrophageCellList.clear_all_phagosome">clear_all_phagosome</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.damage_conidia" href="#nlisim.oldmodules.macrophage.MacrophageCellList.damage_conidia">damage_conidia</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.grid" href="#nlisim.oldmodules.macrophage.MacrophageCellList.grid">grid</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.internalize_conidia" href="#nlisim.oldmodules.macrophage.MacrophageCellList.internalize_conidia">internalize_conidia</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.len_phagosome" href="#nlisim.oldmodules.macrophage.MacrophageCellList.len_phagosome">len_phagosome</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.max_cells" href="#nlisim.oldmodules.macrophage.MacrophageCellList.max_cells">max_cells</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.move" href="#nlisim.oldmodules.macrophage.MacrophageCellList.move">move</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.produce_cytokines" href="#nlisim.oldmodules.macrophage.MacrophageCellList.produce_cytokines">produce_cytokines</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.recruit_new" href="#nlisim.oldmodules.macrophage.MacrophageCellList.recruit_new">recruit_new</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.remove_from_phagosome" href="#nlisim.oldmodules.macrophage.MacrophageCellList.remove_from_phagosome">remove_from_phagosome</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageCellList.remove_if_sporeless" href="#nlisim.oldmodules.macrophage.MacrophageCellList.remove_if_sporeless">remove_if_sporeless</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.oldmodules.macrophage.MacrophageState" href="#nlisim.oldmodules.macrophage.MacrophageState">MacrophageState</a></code></h4>
<ul class="two-column">
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.cells" href="#nlisim.oldmodules.macrophage.MacrophageState.cells">cells</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.kill" href="#nlisim.oldmodules.macrophage.MacrophageState.kill">kill</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.m_abs" href="#nlisim.oldmodules.macrophage.MacrophageState.m_abs">m_abs</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.m_det" href="#nlisim.oldmodules.macrophage.MacrophageState.m_det">m_det</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.m_n" href="#nlisim.oldmodules.macrophage.MacrophageState.m_n">m_n</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.max_conidia_in_phag" href="#nlisim.oldmodules.macrophage.MacrophageState.max_conidia_in_phag">max_conidia_in_phag</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.p_internalization" href="#nlisim.oldmodules.macrophage.MacrophageState.p_internalization">p_internalization</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.p_rec_r" href="#nlisim.oldmodules.macrophage.MacrophageState.p_rec_r">p_rec_r</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.rec_r" href="#nlisim.oldmodules.macrophage.MacrophageState.rec_r">rec_r</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.rec_rate_ph" href="#nlisim.oldmodules.macrophage.MacrophageState.rec_rate_ph">rec_rate_ph</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.rm" href="#nlisim.oldmodules.macrophage.MacrophageState.rm">rm</a></code></li>
<li><code><a title="nlisim.oldmodules.macrophage.MacrophageState.time_m" href="#nlisim.oldmodules.macrophage.MacrophageState.time_m">time_m</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>