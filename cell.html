<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>simulation.cell API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simulation.cell</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict
from typing import Any, cast, Dict, Iterable, List, Set, Type, Union

import attr
from h5py import Group
import numpy as np

from simulation.coordinates import Point, Voxel
from simulation.grid import RectangularGrid
from simulation.state import get_class_path, State

MAX_CELL_LIST_SIZE = 1000000

# the way numpy types single records is strange...
CellType = Any


class CellData(np.ndarray):
    &#34;&#34;&#34;A low-level data contain for an array cells.

    This class is a subtype of
    [numpy.recarray](https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html)
    containing the lowest level representation of a list of &#34;cells&#34; in a
    simulation.  The underlying data format of this type are identical to a
    simple array of C structures with the fields given in the static &#34;dtype&#34;
    variable.

    The base class contains only a single coordinate representing the location
    of the center of the cell.  Most implementations will want to override this
    class to append more fields.  Subclasses must also override the base
    implementation of `create_cell` to construct a single record containing
    the additional fields.

    For example, the following derived class adds an addition floating point value
    associated with each cell.

    ```python
    class DerivedCell(CellData):
        FIELDS = CellData.FIELDS + [
            (&#39;iron_content&#39;, &#39;f8&#39;)
        ]

        dtype = np.dtype(CellData.FIELDS, align=True)

        @classmethod
        def create_cell_tuple(cls, iron_content=0, **kwargs):
            return CellData.create_cell_tuple(**kwargs) + (iron_content,)
    ```
    &#34;&#34;&#34;

    FIELDS: List[Any] = [
        (&#39;point&#39;, Point.dtype),
        (&#39;dead&#39;, &#39;b1&#39;),
    ]
    &#34;&#34;&#34;
    This variable contains the base fields that all subclasses should include
    in their derived data type.
    &#34;&#34;&#34;

    # typing for dtype doesn&#39;t work correctly with this argument
    dtype = np.dtype(FIELDS, align=True)  # type: ignore
    &#34;&#34;&#34;
    Subclasses **must** override this value to append custom fields into each
    cell record.
    &#34;&#34;&#34;

    def __new__(cls, arg: Union[int, Iterable[np.record]], initialize: bool = False, **kwargs):
        if isinstance(arg, (int, np.int64, np.int32)):
            arg = cast(int, arg)
            array = np.ndarray(shape=(arg,), dtype=cls.dtype).view(cls)
            if initialize:
                for index in range(arg):
                    array[index] = cls.create_cell(**kwargs)
            return array

        return np.asarray(arg, dtype=cls.dtype).view(cls)

    @classmethod
    def create_cell_tuple(cls, *, point: Point = None, dead: bool = False):
        &#34;&#34;&#34;Create a tuple of fields attached to a single cell.

        The base class version of this method returns the fields associated with
        just the bare cell.  Subclasses that append additional attributes onto
        the cell must override this method to append their own fields to this
        tuple.  Care must be taken to ensure that the order of the tuple is
        identical to the order of the fields listed in `cls.dtype`.
        &#34;&#34;&#34;
        if point is None:
            point = Point()

        return (point, dead)

    @classmethod
    def create_cell(cls, **kwargs) -&gt; np.record:
        &#34;&#34;&#34;Create a single record with type `cls.dtype`.

        Subclasses appending fields must override this with custom default
        values.
        &#34;&#34;&#34;
        return np.rec.array([cls.create_cell_tuple(**kwargs)], dtype=cls.dtype)[0]

    @classmethod
    def point_mask(cls, points: np.ndarray, grid: RectangularGrid):
        &#34;&#34;&#34;Generate a mask array from a set of points.

        The output is a boolean array indicating if the point at that index
        is a valid location for a cell.
        &#34;&#34;&#34;
        assert points.shape[1] == 3, &#39;Invalid point array shape&#39;
        point = points.T.view(Point)

        # TODO: add geometry restriction
        return (
            (grid.xv[0] &lt;= point.x)
            &amp; (point.x &lt;= grid.xv[-1])
            &amp; (grid.yv[0] &lt;= point.y)
            &amp; (point.y &lt;= grid.yv[-1])
            &amp; (grid.zv[0] &lt;= point.z)
            &amp; (point.z &lt;= grid.zv[-1])
        )


@attr.s(kw_only=True, frozen=True, repr=False)
class CellList(object):
    &#34;&#34;&#34;A python view on top of a CellData array.

    This class represents a pythonic interface to the data contained in a
    CellData array.  Because the CellData class is a low-level object, it does
    not allow dynamically appending new elements.  Objects of this class get
    around this limitation by pre-allocating a large block of memory that is
    transparently available.  User-facing properties are sliced to make it
    appear as if the extra data is not there.

    Subclassed types are expected to set the `CellDataClass` attribute to
    a subclass of `CellData`.  This provides information about the underlying
    low-level array.

    Parameters
    ------
    grid : `simulation.grid.RectangularGrid`
    max_cells : int, optional
    cells : `simulation.cell.CellData`, optional

    &#34;&#34;&#34;

    CellDataClass: Type[CellData] = CellData
    &#34;&#34;&#34;
    A class that overrides `CellData` that represents the format of the data
    contained in the list.
    &#34;&#34;&#34;

    grid: RectangularGrid = attr.ib()
    max_cells: int = attr.ib(default=MAX_CELL_LIST_SIZE)
    _cell_data: CellData = attr.ib()
    _ncells: int = attr.ib(init=False)
    _voxel_index: Dict[Voxel, Set[int]] = attr.ib(init=False, factory=lambda: defaultdict(set))
    _reverse_voxel_index: List[Voxel] = attr.ib(init=False, factory=list)

    @_cell_data.default
    def __set_default_cells(self) -&gt; CellData:
        return self.CellDataClass(0)

    def __attrs_post_init__(self):
        cells = self._cell_data

        object.__setattr__(self, &#39;_ncells&#39;, len(cells))
        object.__setattr__(self, &#39;_cell_data&#39;, self.CellDataClass(self.max_cells))

        if len(cells) &gt; 0:
            self._cell_data[: len(cells)] = cells

        self._compute_voxel_index()

    def __len__(self) -&gt; int:
        return self._ncells

    def __repr__(self) -&gt; str:
        return f&#39;CellList[{self._ncells}]&#39;

    def __getitem__(self, index: int) -&gt; CellType:
        if isinstance(index, str):
            raise TypeError(&#39;Expected an integer index, did you mean `cells.cell_data[key]`?&#39;)
        return self.cell_data[index]

    @property
    def cell_data(self) -&gt; CellData:
        &#34;&#34;&#34;Return the portion of the underlying data array containing valid data.&#34;&#34;&#34;
        return self._cell_data[: self._ncells]

    @property
    def voxel_index(self):
        return self._reverse_voxel_index

    @classmethod
    def create_from_seed(cls, grid: RectangularGrid, **kwargs) -&gt; &#39;CellList&#39;:
        &#34;&#34;&#34;Create a new cell list initialized with a single cell.

        The kwargs provided are passed on to the `create_cell` method of the
        data array class.
        &#34;&#34;&#34;
        cell = cls.CellDataClass.create_cell(**kwargs)
        cell_data = cls.CellDataClass([cell])

        return cls(grid=grid, cell_data=cell_data)

    def alive(self, sample: Iterable = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Get a list of indices containing cells that are alive.

        This method will filter out cells that are dead according to the
        value of the `dead` field.  Optionally, you can also pass in a boolean
        mask or index array.  This method will then filter the given list of
        cells rather than the full list.

        For example, to iterate over all living cells:
        ```python
        for index in cells.alive():
            cell = cells[index]
            # do something...
        ```

        To iterate over a sub-sample of living cells:
        ```python
        sample = [1, 10, 15]
        for index in cells.alive(sample):
            cell = cells[index]
            # do something...
        ```

        To iterate over a boolean mask of living cells:
        ```python
        sample = cells.cell_data[&#39;iron&#39;] &gt; 0.5
        for index in cells.alive(sample):
            cell = cells[index]
            # do something...
        ```
        &#34;&#34;&#34;
        cell_data = self.cell_data
        if sample is None:
            return (cell_data[&#39;dead&#39;] == False).nonzero()[0]  # noqa: E712

        sample_indices = np.asarray(sample)
        if sample_indices.dtype == &#39;b1&#39;:
            if sample_indices.shape != self.cell_data.shape:
                raise ValueError(&#39;Expected boolean mask the same size as the cell list&#39;)
            sample_indices = sample_indices.nonzero()[0]

        mask = (cell_data[sample_indices][&#39;dead&#39;] == False).nonzero()[0]  # noqa: E712
        return sample_indices[mask]

    def append(self, cell: CellType) -&gt; None:
        &#34;&#34;&#34;Append a new cell the the list.&#34;&#34;&#34;
        if len(self) &gt;= self.max_cells:
            raise Exception(&#39;Not enough free space in cell tree&#39;)

        index = self._ncells
        object.__setattr__(self, &#39;_ncells&#39;, self._ncells + 1)
        self._cell_data[index] = cell
        voxel = self.grid.get_voxel(cell[&#39;point&#39;])
        self._voxel_index[voxel].add(index)
        self._reverse_voxel_index.append(voxel)

    def extend(self, cells: Iterable[CellData]) -&gt; None:
        &#34;&#34;&#34;Extend the cell list by multiple cells.&#34;&#34;&#34;
        for cell in cells:
            self.append(cell)

    def save(self, group: Group, name: str, metadata: dict) -&gt; Group:
        &#34;&#34;&#34;Save the cell list.

        Save the list of cells as a new composite data structure inside
        an HDF5 group.  Subclasses should not need to over-ride this method.
        It will automatically create a new variable in the file with the
        correct data-type.  It will also create a reference to the original
        class so that it can be deserialized into the correct type.
        &#34;&#34;&#34;
        composite_group = group.create_group(name)

        composite_group.attrs[&#39;type&#39;] = &#39;CellList&#39;
        composite_group.attrs[&#39;class&#39;] = get_class_path(self)
        composite_group.attrs[&#39;max_cells&#39;] = self.max_cells

        composite_group.create_dataset(name=&#39;cell_data&#39;, data=self.cell_data)
        return composite_group

    @classmethod
    def load(cls, global_state: State, group: Group, name: str, metadata: dict) -&gt; &#39;CellList&#39;:
        &#34;&#34;&#34;Load a cell list object.

        Load a `CellList` subclass from a composite group inside an HDF5 file.  As with
        `simulation.cell.CellList.save`, subclasses should not need to override this
        method.
        &#34;&#34;&#34;
        composite_dataset = group[name]

        attrs = composite_dataset.attrs
        max_cells = attrs.get(&#39;max_cells&#39;, MAX_CELL_LIST_SIZE)
        cell_data = composite_dataset[&#39;cell_data&#39;][:].view(cls.CellDataClass)

        return cls(max_cells=max_cells, grid=global_state.grid, cell_data=cell_data)

    def get_cells_in_voxel(self, voxel: Voxel) -&gt; np.ndarray:
        &#34;&#34;&#34;Return a list of cell indices contained in a given voxel.&#34;&#34;&#34;
        return np.asarray(sorted((self._voxel_index[voxel])))

    def get_neighboring_cells(self, cell: CellData) -&gt; np.ndarray:
        &#34;&#34;&#34;Return a list of cells indices in the same voxel.&#34;&#34;&#34;
        return self.get_cells_in_voxel(self.grid.get_voxel(cell[&#39;point&#39;]))

    def update_voxel_index(self, indices: Iterable = None):
        &#34;&#34;&#34;Update the embedded voxel index.

        This method will update the voxel indices for a given list of cells,
        or if no parameter is provided, for all of the cells.  Currently,
        calling this method is only required if the `point` field of a cell
        is changed... i.e. if the cell is moved to a potentially different
        voxel.
        &#34;&#34;&#34;
        if indices is None:
            self._voxel_index.clear()
            self._reverse_voxel_index.clear()
            self._compute_voxel_index()
            return

        for index in indices:
            cell = self[index]
            old_voxel = self._reverse_voxel_index[index]
            new_voxel = self.grid.get_voxel(cell[&#39;point&#39;])
            if old_voxel != new_voxel:
                self._voxel_index[old_voxel].remove(index)
                self._voxel_index[new_voxel].add(index)
                self._reverse_voxel_index[index] = new_voxel

    def _compute_voxel_index(self):
        &#34;&#34;&#34;Generate a dictionary mapping voxel index to cell index.

        This index exists to maintain efficient (sub-linear) access to cells contained
        in a single voxel.  This method is called automatically on initialization.
        &#34;&#34;&#34;
        for cell_index in range(len(self)):
            cell = self[cell_index]
            voxel = self.grid.get_voxel(cell[&#39;point&#39;])
            self._voxel_index[voxel].add(cell_index)
            self._reverse_voxel_index.append(voxel)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simulation.cell.CellData"><code class="flex name class">
<span>class <span class="ident">CellData</span></span>
<span>(</span><span>arg: Union[int, Iterable[numpy.record]], initialize: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A low-level data contain for an array cells.</p>
<p>This class is a subtype of
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html">numpy.recarray</a>
containing the lowest level representation of a list of "cells" in a
simulation.
The underlying data format of this type are identical to a
simple array of C structures with the fields given in the static "dtype"
variable.</p>
<p>The base class contains only a single coordinate representing the location
of the center of the cell.
Most implementations will want to override this
class to append more fields.
Subclasses must also override the base
implementation of <code>create_cell</code> to construct a single record containing
the additional fields.</p>
<p>For example, the following derived class adds an addition floating point value
associated with each cell.</p>
<pre><code class="python">class DerivedCell(CellData):
    FIELDS = CellData.FIELDS + [
        ('iron_content', 'f8')
    ]

    dtype = np.dtype(CellData.FIELDS, align=True)

    @classmethod
    def create_cell_tuple(cls, iron_content=0, **kwargs):
        return CellData.create_cell_tuple(**kwargs) + (iron_content,)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CellData(np.ndarray):
    &#34;&#34;&#34;A low-level data contain for an array cells.

    This class is a subtype of
    [numpy.recarray](https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html)
    containing the lowest level representation of a list of &#34;cells&#34; in a
    simulation.  The underlying data format of this type are identical to a
    simple array of C structures with the fields given in the static &#34;dtype&#34;
    variable.

    The base class contains only a single coordinate representing the location
    of the center of the cell.  Most implementations will want to override this
    class to append more fields.  Subclasses must also override the base
    implementation of `create_cell` to construct a single record containing
    the additional fields.

    For example, the following derived class adds an addition floating point value
    associated with each cell.

    ```python
    class DerivedCell(CellData):
        FIELDS = CellData.FIELDS + [
            (&#39;iron_content&#39;, &#39;f8&#39;)
        ]

        dtype = np.dtype(CellData.FIELDS, align=True)

        @classmethod
        def create_cell_tuple(cls, iron_content=0, **kwargs):
            return CellData.create_cell_tuple(**kwargs) + (iron_content,)
    ```
    &#34;&#34;&#34;

    FIELDS: List[Any] = [
        (&#39;point&#39;, Point.dtype),
        (&#39;dead&#39;, &#39;b1&#39;),
    ]
    &#34;&#34;&#34;
    This variable contains the base fields that all subclasses should include
    in their derived data type.
    &#34;&#34;&#34;

    # typing for dtype doesn&#39;t work correctly with this argument
    dtype = np.dtype(FIELDS, align=True)  # type: ignore
    &#34;&#34;&#34;
    Subclasses **must** override this value to append custom fields into each
    cell record.
    &#34;&#34;&#34;

    def __new__(cls, arg: Union[int, Iterable[np.record]], initialize: bool = False, **kwargs):
        if isinstance(arg, (int, np.int64, np.int32)):
            arg = cast(int, arg)
            array = np.ndarray(shape=(arg,), dtype=cls.dtype).view(cls)
            if initialize:
                for index in range(arg):
                    array[index] = cls.create_cell(**kwargs)
            return array

        return np.asarray(arg, dtype=cls.dtype).view(cls)

    @classmethod
    def create_cell_tuple(cls, *, point: Point = None, dead: bool = False):
        &#34;&#34;&#34;Create a tuple of fields attached to a single cell.

        The base class version of this method returns the fields associated with
        just the bare cell.  Subclasses that append additional attributes onto
        the cell must override this method to append their own fields to this
        tuple.  Care must be taken to ensure that the order of the tuple is
        identical to the order of the fields listed in `cls.dtype`.
        &#34;&#34;&#34;
        if point is None:
            point = Point()

        return (point, dead)

    @classmethod
    def create_cell(cls, **kwargs) -&gt; np.record:
        &#34;&#34;&#34;Create a single record with type `cls.dtype`.

        Subclasses appending fields must override this with custom default
        values.
        &#34;&#34;&#34;
        return np.rec.array([cls.create_cell_tuple(**kwargs)], dtype=cls.dtype)[0]

    @classmethod
    def point_mask(cls, points: np.ndarray, grid: RectangularGrid):
        &#34;&#34;&#34;Generate a mask array from a set of points.

        The output is a boolean array indicating if the point at that index
        is a valid location for a cell.
        &#34;&#34;&#34;
        assert points.shape[1] == 3, &#39;Invalid point array shape&#39;
        point = points.T.view(Point)

        # TODO: add geometry restriction
        return (
            (grid.xv[0] &lt;= point.x)
            &amp; (point.x &lt;= grid.xv[-1])
            &amp; (grid.yv[0] &lt;= point.y)
            &amp; (point.y &lt;= grid.yv[-1])
            &amp; (grid.zv[0] &lt;= point.z)
            &amp; (point.z &lt;= grid.zv[-1])
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>numpy.ndarray</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="simulation.modules.afumigatus.AfumigatusCellData" href="modules/afumigatus.html#simulation.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a></li>
<li><a title="simulation.modules.epithelium.EpitheliumCellData" href="modules/epithelium.html#simulation.modules.epithelium.EpitheliumCellData">EpitheliumCellData</a></li>
<li><a title="simulation.modules.fungus.FungusCellData" href="modules/fungus.html#simulation.modules.fungus.FungusCellData">FungusCellData</a></li>
<li><a title="simulation.modules.macrophage.MacrophageCellData" href="modules/macrophage.html#simulation.modules.macrophage.MacrophageCellData">MacrophageCellData</a></li>
<li><a title="simulation.modules.neutrophil.NeutrophilCellData" href="modules/neutrophil.html#simulation.modules.neutrophil.NeutrophilCellData">NeutrophilCellData</a></li>
<li><a title="simulation.modules.phagocyte.PhagocyteCellData" href="modules/phagocyte.html#simulation.modules.phagocyte.PhagocyteCellData">PhagocyteCellData</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulation.cell.CellData.FIELDS"><code class="name">var <span class="ident">FIELDS</span> : List[Any]</code></dt>
<dd>
<div class="desc"><p>This variable contains the base fields that all subclasses should include
in their derived data type.</p></div>
</dd>
<dt id="simulation.cell.CellData.dtype"><code class="name">var <span class="ident">dtype</span></code></dt>
<dd>
<div class="desc"><p>Subclasses <strong>must</strong> override this value to append custom fields into each
cell record.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="simulation.cell.CellData.create_cell"><code class="name flex">
<span>def <span class="ident">create_cell</span></span>(<span>**kwargs) ‑> numpy.record</span>
</code></dt>
<dd>
<div class="desc"><p>Create a single record with type <code>cls.dtype</code>.</p>
<p>Subclasses appending fields must override this with custom default
values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_cell(cls, **kwargs) -&gt; np.record:
    &#34;&#34;&#34;Create a single record with type `cls.dtype`.

    Subclasses appending fields must override this with custom default
    values.
    &#34;&#34;&#34;
    return np.rec.array([cls.create_cell_tuple(**kwargs)], dtype=cls.dtype)[0]</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellData.create_cell_tuple"><code class="name flex">
<span>def <span class="ident">create_cell_tuple</span></span>(<span>*, point: <a title="simulation.coordinates.Point" href="coordinates.html#simulation.coordinates.Point">Point</a> = None, dead: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tuple of fields attached to a single cell.</p>
<p>The base class version of this method returns the fields associated with
just the bare cell.
Subclasses that append additional attributes onto
the cell must override this method to append their own fields to this
tuple.
Care must be taken to ensure that the order of the tuple is
identical to the order of the fields listed in <code>cls.dtype</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_cell_tuple(cls, *, point: Point = None, dead: bool = False):
    &#34;&#34;&#34;Create a tuple of fields attached to a single cell.

    The base class version of this method returns the fields associated with
    just the bare cell.  Subclasses that append additional attributes onto
    the cell must override this method to append their own fields to this
    tuple.  Care must be taken to ensure that the order of the tuple is
    identical to the order of the fields listed in `cls.dtype`.
    &#34;&#34;&#34;
    if point is None:
        point = Point()

    return (point, dead)</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellData.point_mask"><code class="name flex">
<span>def <span class="ident">point_mask</span></span>(<span>points: numpy.ndarray, grid: <a title="simulation.grid.RectangularGrid" href="grid.html#simulation.grid.RectangularGrid">RectangularGrid</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a mask array from a set of points.</p>
<p>The output is a boolean array indicating if the point at that index
is a valid location for a cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def point_mask(cls, points: np.ndarray, grid: RectangularGrid):
    &#34;&#34;&#34;Generate a mask array from a set of points.

    The output is a boolean array indicating if the point at that index
    is a valid location for a cell.
    &#34;&#34;&#34;
    assert points.shape[1] == 3, &#39;Invalid point array shape&#39;
    point = points.T.view(Point)

    # TODO: add geometry restriction
    return (
        (grid.xv[0] &lt;= point.x)
        &amp; (point.x &lt;= grid.xv[-1])
        &amp; (grid.yv[0] &lt;= point.y)
        &amp; (point.y &lt;= grid.yv[-1])
        &amp; (grid.zv[0] &lt;= point.z)
        &amp; (point.z &lt;= grid.zv[-1])
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="simulation.cell.CellList"><code class="flex name class">
<span>class <span class="ident">CellList</span></span>
<span>(</span><span>*, grid: <a title="simulation.grid.RectangularGrid" href="grid.html#simulation.grid.RectangularGrid">RectangularGrid</a>, max_cells: int = 1000000, cell_data: <a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>A python view on top of a CellData array.</p>
<p>This class represents a pythonic interface to the data contained in a
CellData array.
Because the CellData class is a low-level object, it does
not allow dynamically appending new elements.
Objects of this class get
around this limitation by pre-allocating a large block of memory that is
transparently available.
User-facing properties are sliced to make it
appear as if the extra data is not there.</p>
<p>Subclassed types are expected to set the <code>CellDataClass</code> attribute to
a subclass of <code><a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a></code>.
This provides information about the underlying
low-level array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code><a title="simulation.grid.RectangularGrid" href="grid.html#simulation.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_cells</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>cells</code></strong> :&ensp;<code><a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a></code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Method generated by attrs for class CellList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CellList(object):
    &#34;&#34;&#34;A python view on top of a CellData array.

    This class represents a pythonic interface to the data contained in a
    CellData array.  Because the CellData class is a low-level object, it does
    not allow dynamically appending new elements.  Objects of this class get
    around this limitation by pre-allocating a large block of memory that is
    transparently available.  User-facing properties are sliced to make it
    appear as if the extra data is not there.

    Subclassed types are expected to set the `CellDataClass` attribute to
    a subclass of `CellData`.  This provides information about the underlying
    low-level array.

    Parameters
    ------
    grid : `simulation.grid.RectangularGrid`
    max_cells : int, optional
    cells : `simulation.cell.CellData`, optional

    &#34;&#34;&#34;

    CellDataClass: Type[CellData] = CellData
    &#34;&#34;&#34;
    A class that overrides `CellData` that represents the format of the data
    contained in the list.
    &#34;&#34;&#34;

    grid: RectangularGrid = attr.ib()
    max_cells: int = attr.ib(default=MAX_CELL_LIST_SIZE)
    _cell_data: CellData = attr.ib()
    _ncells: int = attr.ib(init=False)
    _voxel_index: Dict[Voxel, Set[int]] = attr.ib(init=False, factory=lambda: defaultdict(set))
    _reverse_voxel_index: List[Voxel] = attr.ib(init=False, factory=list)

    @_cell_data.default
    def __set_default_cells(self) -&gt; CellData:
        return self.CellDataClass(0)

    def __attrs_post_init__(self):
        cells = self._cell_data

        object.__setattr__(self, &#39;_ncells&#39;, len(cells))
        object.__setattr__(self, &#39;_cell_data&#39;, self.CellDataClass(self.max_cells))

        if len(cells) &gt; 0:
            self._cell_data[: len(cells)] = cells

        self._compute_voxel_index()

    def __len__(self) -&gt; int:
        return self._ncells

    def __repr__(self) -&gt; str:
        return f&#39;CellList[{self._ncells}]&#39;

    def __getitem__(self, index: int) -&gt; CellType:
        if isinstance(index, str):
            raise TypeError(&#39;Expected an integer index, did you mean `cells.cell_data[key]`?&#39;)
        return self.cell_data[index]

    @property
    def cell_data(self) -&gt; CellData:
        &#34;&#34;&#34;Return the portion of the underlying data array containing valid data.&#34;&#34;&#34;
        return self._cell_data[: self._ncells]

    @property
    def voxel_index(self):
        return self._reverse_voxel_index

    @classmethod
    def create_from_seed(cls, grid: RectangularGrid, **kwargs) -&gt; &#39;CellList&#39;:
        &#34;&#34;&#34;Create a new cell list initialized with a single cell.

        The kwargs provided are passed on to the `create_cell` method of the
        data array class.
        &#34;&#34;&#34;
        cell = cls.CellDataClass.create_cell(**kwargs)
        cell_data = cls.CellDataClass([cell])

        return cls(grid=grid, cell_data=cell_data)

    def alive(self, sample: Iterable = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Get a list of indices containing cells that are alive.

        This method will filter out cells that are dead according to the
        value of the `dead` field.  Optionally, you can also pass in a boolean
        mask or index array.  This method will then filter the given list of
        cells rather than the full list.

        For example, to iterate over all living cells:
        ```python
        for index in cells.alive():
            cell = cells[index]
            # do something...
        ```

        To iterate over a sub-sample of living cells:
        ```python
        sample = [1, 10, 15]
        for index in cells.alive(sample):
            cell = cells[index]
            # do something...
        ```

        To iterate over a boolean mask of living cells:
        ```python
        sample = cells.cell_data[&#39;iron&#39;] &gt; 0.5
        for index in cells.alive(sample):
            cell = cells[index]
            # do something...
        ```
        &#34;&#34;&#34;
        cell_data = self.cell_data
        if sample is None:
            return (cell_data[&#39;dead&#39;] == False).nonzero()[0]  # noqa: E712

        sample_indices = np.asarray(sample)
        if sample_indices.dtype == &#39;b1&#39;:
            if sample_indices.shape != self.cell_data.shape:
                raise ValueError(&#39;Expected boolean mask the same size as the cell list&#39;)
            sample_indices = sample_indices.nonzero()[0]

        mask = (cell_data[sample_indices][&#39;dead&#39;] == False).nonzero()[0]  # noqa: E712
        return sample_indices[mask]

    def append(self, cell: CellType) -&gt; None:
        &#34;&#34;&#34;Append a new cell the the list.&#34;&#34;&#34;
        if len(self) &gt;= self.max_cells:
            raise Exception(&#39;Not enough free space in cell tree&#39;)

        index = self._ncells
        object.__setattr__(self, &#39;_ncells&#39;, self._ncells + 1)
        self._cell_data[index] = cell
        voxel = self.grid.get_voxel(cell[&#39;point&#39;])
        self._voxel_index[voxel].add(index)
        self._reverse_voxel_index.append(voxel)

    def extend(self, cells: Iterable[CellData]) -&gt; None:
        &#34;&#34;&#34;Extend the cell list by multiple cells.&#34;&#34;&#34;
        for cell in cells:
            self.append(cell)

    def save(self, group: Group, name: str, metadata: dict) -&gt; Group:
        &#34;&#34;&#34;Save the cell list.

        Save the list of cells as a new composite data structure inside
        an HDF5 group.  Subclasses should not need to over-ride this method.
        It will automatically create a new variable in the file with the
        correct data-type.  It will also create a reference to the original
        class so that it can be deserialized into the correct type.
        &#34;&#34;&#34;
        composite_group = group.create_group(name)

        composite_group.attrs[&#39;type&#39;] = &#39;CellList&#39;
        composite_group.attrs[&#39;class&#39;] = get_class_path(self)
        composite_group.attrs[&#39;max_cells&#39;] = self.max_cells

        composite_group.create_dataset(name=&#39;cell_data&#39;, data=self.cell_data)
        return composite_group

    @classmethod
    def load(cls, global_state: State, group: Group, name: str, metadata: dict) -&gt; &#39;CellList&#39;:
        &#34;&#34;&#34;Load a cell list object.

        Load a `CellList` subclass from a composite group inside an HDF5 file.  As with
        `simulation.cell.CellList.save`, subclasses should not need to override this
        method.
        &#34;&#34;&#34;
        composite_dataset = group[name]

        attrs = composite_dataset.attrs
        max_cells = attrs.get(&#39;max_cells&#39;, MAX_CELL_LIST_SIZE)
        cell_data = composite_dataset[&#39;cell_data&#39;][:].view(cls.CellDataClass)

        return cls(max_cells=max_cells, grid=global_state.grid, cell_data=cell_data)

    def get_cells_in_voxel(self, voxel: Voxel) -&gt; np.ndarray:
        &#34;&#34;&#34;Return a list of cell indices contained in a given voxel.&#34;&#34;&#34;
        return np.asarray(sorted((self._voxel_index[voxel])))

    def get_neighboring_cells(self, cell: CellData) -&gt; np.ndarray:
        &#34;&#34;&#34;Return a list of cells indices in the same voxel.&#34;&#34;&#34;
        return self.get_cells_in_voxel(self.grid.get_voxel(cell[&#39;point&#39;]))

    def update_voxel_index(self, indices: Iterable = None):
        &#34;&#34;&#34;Update the embedded voxel index.

        This method will update the voxel indices for a given list of cells,
        or if no parameter is provided, for all of the cells.  Currently,
        calling this method is only required if the `point` field of a cell
        is changed... i.e. if the cell is moved to a potentially different
        voxel.
        &#34;&#34;&#34;
        if indices is None:
            self._voxel_index.clear()
            self._reverse_voxel_index.clear()
            self._compute_voxel_index()
            return

        for index in indices:
            cell = self[index]
            old_voxel = self._reverse_voxel_index[index]
            new_voxel = self.grid.get_voxel(cell[&#39;point&#39;])
            if old_voxel != new_voxel:
                self._voxel_index[old_voxel].remove(index)
                self._voxel_index[new_voxel].add(index)
                self._reverse_voxel_index[index] = new_voxel

    def _compute_voxel_index(self):
        &#34;&#34;&#34;Generate a dictionary mapping voxel index to cell index.

        This index exists to maintain efficient (sub-linear) access to cells contained
        in a single voxel.  This method is called automatically on initialization.
        &#34;&#34;&#34;
        for cell_index in range(len(self)):
            cell = self[cell_index]
            voxel = self.grid.get_voxel(cell[&#39;point&#39;])
            self._voxel_index[voxel].add(cell_index)
            self._reverse_voxel_index.append(voxel)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="simulation.modules.afumigatus.AfumigatusCellList" href="modules/afumigatus.html#simulation.modules.afumigatus.AfumigatusCellList">AfumigatusCellList</a></li>
<li><a title="simulation.modules.epithelium.EpitheliumCellList" href="modules/epithelium.html#simulation.modules.epithelium.EpitheliumCellList">EpitheliumCellList</a></li>
<li><a title="simulation.modules.fungus.FungusCellList" href="modules/fungus.html#simulation.modules.fungus.FungusCellList">FungusCellList</a></li>
<li><a title="simulation.modules.macrophage.MacrophageCellList" href="modules/macrophage.html#simulation.modules.macrophage.MacrophageCellList">MacrophageCellList</a></li>
<li><a title="simulation.modules.neutrophil.NeutrophilCellList" href="modules/neutrophil.html#simulation.modules.neutrophil.NeutrophilCellList">NeutrophilCellList</a></li>
<li><a title="simulation.modules.phagocyte.PhagocyteCellList" href="modules/phagocyte.html#simulation.modules.phagocyte.PhagocyteCellList">PhagocyteCellList</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simulation.cell.CellList.CellDataClass"><code class="name">var <span class="ident">CellDataClass</span> : Type[<a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a>]</code></dt>
<dd>
<div class="desc"><p>A class that overrides <code><a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a></code> that represents the format of the data
contained in the list.</p></div>
</dd>
<dt id="simulation.cell.CellList.grid"><code class="name">var <span class="ident">grid</span> : <a title="simulation.grid.RectangularGrid" href="grid.html#simulation.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="simulation.cell.CellList.max_cells"><code class="name">var <span class="ident">max_cells</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="simulation.cell.CellList.create_from_seed"><code class="name flex">
<span>def <span class="ident">create_from_seed</span></span>(<span>grid: <a title="simulation.grid.RectangularGrid" href="grid.html#simulation.grid.RectangularGrid">RectangularGrid</a>, **kwargs) ‑> <a title="simulation.cell.CellList" href="#simulation.cell.CellList">CellList</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new cell list initialized with a single cell.</p>
<p>The kwargs provided are passed on to the <code>create_cell</code> method of the
data array class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_seed(cls, grid: RectangularGrid, **kwargs) -&gt; &#39;CellList&#39;:
    &#34;&#34;&#34;Create a new cell list initialized with a single cell.

    The kwargs provided are passed on to the `create_cell` method of the
    data array class.
    &#34;&#34;&#34;
    cell = cls.CellDataClass.create_cell(**kwargs)
    cell_data = cls.CellDataClass([cell])

    return cls(grid=grid, cell_data=cell_data)</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>global_state: <a title="simulation.state.State" href="state.html#simulation.state.State">State</a>, group: h5py._hl.group.Group, name: str, metadata: dict) ‑> <a title="simulation.cell.CellList" href="#simulation.cell.CellList">CellList</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a cell list object.</p>
<p>Load a <code><a title="simulation.cell.CellList" href="#simulation.cell.CellList">CellList</a></code> subclass from a composite group inside an HDF5 file.
As with
<code><a title="simulation.cell.CellList.save" href="#simulation.cell.CellList.save">CellList.save()</a></code>, subclasses should not need to override this
method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, global_state: State, group: Group, name: str, metadata: dict) -&gt; &#39;CellList&#39;:
    &#34;&#34;&#34;Load a cell list object.

    Load a `CellList` subclass from a composite group inside an HDF5 file.  As with
    `simulation.cell.CellList.save`, subclasses should not need to override this
    method.
    &#34;&#34;&#34;
    composite_dataset = group[name]

    attrs = composite_dataset.attrs
    max_cells = attrs.get(&#39;max_cells&#39;, MAX_CELL_LIST_SIZE)
    cell_data = composite_dataset[&#39;cell_data&#39;][:].view(cls.CellDataClass)

    return cls(max_cells=max_cells, grid=global_state.grid, cell_data=cell_data)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="simulation.cell.CellList.cell_data"><code class="name">var <span class="ident">cell_data</span> : <a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a></code></dt>
<dd>
<div class="desc"><p>Return the portion of the underlying data array containing valid data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cell_data(self) -&gt; CellData:
    &#34;&#34;&#34;Return the portion of the underlying data array containing valid data.&#34;&#34;&#34;
    return self._cell_data[: self._ncells]</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.voxel_index"><code class="name">var <span class="ident">voxel_index</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def voxel_index(self):
    return self._reverse_voxel_index</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simulation.cell.CellList.alive"><code class="name flex">
<span>def <span class="ident">alive</span></span>(<span>self, sample: Iterable = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of indices containing cells that are alive.</p>
<p>This method will filter out cells that are dead according to the
value of the <code>dead</code> field.
Optionally, you can also pass in a boolean
mask or index array.
This method will then filter the given list of
cells rather than the full list.</p>
<p>For example, to iterate over all living cells:</p>
<pre><code class="python">for index in cells.alive():
    cell = cells[index]
    # do something...
</code></pre>
<p>To iterate over a sub-sample of living cells:</p>
<pre><code class="python">sample = [1, 10, 15]
for index in cells.alive(sample):
    cell = cells[index]
    # do something...
</code></pre>
<p>To iterate over a boolean mask of living cells:</p>
<pre><code class="python">sample = cells.cell_data['iron'] &gt; 0.5
for index in cells.alive(sample):
    cell = cells[index]
    # do something...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alive(self, sample: Iterable = None) -&gt; np.ndarray:
    &#34;&#34;&#34;Get a list of indices containing cells that are alive.

    This method will filter out cells that are dead according to the
    value of the `dead` field.  Optionally, you can also pass in a boolean
    mask or index array.  This method will then filter the given list of
    cells rather than the full list.

    For example, to iterate over all living cells:
    ```python
    for index in cells.alive():
        cell = cells[index]
        # do something...
    ```

    To iterate over a sub-sample of living cells:
    ```python
    sample = [1, 10, 15]
    for index in cells.alive(sample):
        cell = cells[index]
        # do something...
    ```

    To iterate over a boolean mask of living cells:
    ```python
    sample = cells.cell_data[&#39;iron&#39;] &gt; 0.5
    for index in cells.alive(sample):
        cell = cells[index]
        # do something...
    ```
    &#34;&#34;&#34;
    cell_data = self.cell_data
    if sample is None:
        return (cell_data[&#39;dead&#39;] == False).nonzero()[0]  # noqa: E712

    sample_indices = np.asarray(sample)
    if sample_indices.dtype == &#39;b1&#39;:
        if sample_indices.shape != self.cell_data.shape:
            raise ValueError(&#39;Expected boolean mask the same size as the cell list&#39;)
        sample_indices = sample_indices.nonzero()[0]

    mask = (cell_data[sample_indices][&#39;dead&#39;] == False).nonzero()[0]  # noqa: E712
    return sample_indices[mask]</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cell: Any) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append a new cell the the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, cell: CellType) -&gt; None:
    &#34;&#34;&#34;Append a new cell the the list.&#34;&#34;&#34;
    if len(self) &gt;= self.max_cells:
        raise Exception(&#39;Not enough free space in cell tree&#39;)

    index = self._ncells
    object.__setattr__(self, &#39;_ncells&#39;, self._ncells + 1)
    self._cell_data[index] = cell
    voxel = self.grid.get_voxel(cell[&#39;point&#39;])
    self._voxel_index[voxel].add(index)
    self._reverse_voxel_index.append(voxel)</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, cells: Iterable[<a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a>]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the cell list by multiple cells.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, cells: Iterable[CellData]) -&gt; None:
    &#34;&#34;&#34;Extend the cell list by multiple cells.&#34;&#34;&#34;
    for cell in cells:
        self.append(cell)</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.get_cells_in_voxel"><code class="name flex">
<span>def <span class="ident">get_cells_in_voxel</span></span>(<span>self, voxel: <a title="simulation.coordinates.Voxel" href="coordinates.html#simulation.coordinates.Voxel">Voxel</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of cell indices contained in a given voxel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells_in_voxel(self, voxel: Voxel) -&gt; np.ndarray:
    &#34;&#34;&#34;Return a list of cell indices contained in a given voxel.&#34;&#34;&#34;
    return np.asarray(sorted((self._voxel_index[voxel])))</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.get_neighboring_cells"><code class="name flex">
<span>def <span class="ident">get_neighboring_cells</span></span>(<span>self, cell: <a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of cells indices in the same voxel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighboring_cells(self, cell: CellData) -&gt; np.ndarray:
    &#34;&#34;&#34;Return a list of cells indices in the same voxel.&#34;&#34;&#34;
    return self.get_cells_in_voxel(self.grid.get_voxel(cell[&#39;point&#39;]))</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, group: h5py._hl.group.Group, name: str, metadata: dict) ‑> h5py._hl.group.Group</span>
</code></dt>
<dd>
<div class="desc"><p>Save the cell list.</p>
<p>Save the list of cells as a new composite data structure inside
an HDF5 group.
Subclasses should not need to over-ride this method.
It will automatically create a new variable in the file with the
correct data-type.
It will also create a reference to the original
class so that it can be deserialized into the correct type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, group: Group, name: str, metadata: dict) -&gt; Group:
    &#34;&#34;&#34;Save the cell list.

    Save the list of cells as a new composite data structure inside
    an HDF5 group.  Subclasses should not need to over-ride this method.
    It will automatically create a new variable in the file with the
    correct data-type.  It will also create a reference to the original
    class so that it can be deserialized into the correct type.
    &#34;&#34;&#34;
    composite_group = group.create_group(name)

    composite_group.attrs[&#39;type&#39;] = &#39;CellList&#39;
    composite_group.attrs[&#39;class&#39;] = get_class_path(self)
    composite_group.attrs[&#39;max_cells&#39;] = self.max_cells

    composite_group.create_dataset(name=&#39;cell_data&#39;, data=self.cell_data)
    return composite_group</code></pre>
</details>
</dd>
<dt id="simulation.cell.CellList.update_voxel_index"><code class="name flex">
<span>def <span class="ident">update_voxel_index</span></span>(<span>self, indices: Iterable = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the embedded voxel index.</p>
<p>This method will update the voxel indices for a given list of cells,
or if no parameter is provided, for all of the cells.
Currently,
calling this method is only required if the <code>point</code> field of a cell
is changed&hellip; i.e. if the cell is moved to a potentially different
voxel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_voxel_index(self, indices: Iterable = None):
    &#34;&#34;&#34;Update the embedded voxel index.

    This method will update the voxel indices for a given list of cells,
    or if no parameter is provided, for all of the cells.  Currently,
    calling this method is only required if the `point` field of a cell
    is changed... i.e. if the cell is moved to a potentially different
    voxel.
    &#34;&#34;&#34;
    if indices is None:
        self._voxel_index.clear()
        self._reverse_voxel_index.clear()
        self._compute_voxel_index()
        return

    for index in indices:
        cell = self[index]
        old_voxel = self._reverse_voxel_index[index]
        new_voxel = self.grid.get_voxel(cell[&#39;point&#39;])
        if old_voxel != new_voxel:
            self._voxel_index[old_voxel].remove(index)
            self._voxel_index[new_voxel].add(index)
            self._reverse_voxel_index[index] = new_voxel</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="simulation" href="index.html">simulation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simulation.cell.CellData" href="#simulation.cell.CellData">CellData</a></code></h4>
<ul class="">
<li><code><a title="simulation.cell.CellData.FIELDS" href="#simulation.cell.CellData.FIELDS">FIELDS</a></code></li>
<li><code><a title="simulation.cell.CellData.create_cell" href="#simulation.cell.CellData.create_cell">create_cell</a></code></li>
<li><code><a title="simulation.cell.CellData.create_cell_tuple" href="#simulation.cell.CellData.create_cell_tuple">create_cell_tuple</a></code></li>
<li><code><a title="simulation.cell.CellData.dtype" href="#simulation.cell.CellData.dtype">dtype</a></code></li>
<li><code><a title="simulation.cell.CellData.point_mask" href="#simulation.cell.CellData.point_mask">point_mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simulation.cell.CellList" href="#simulation.cell.CellList">CellList</a></code></h4>
<ul class="">
<li><code><a title="simulation.cell.CellList.CellDataClass" href="#simulation.cell.CellList.CellDataClass">CellDataClass</a></code></li>
<li><code><a title="simulation.cell.CellList.alive" href="#simulation.cell.CellList.alive">alive</a></code></li>
<li><code><a title="simulation.cell.CellList.append" href="#simulation.cell.CellList.append">append</a></code></li>
<li><code><a title="simulation.cell.CellList.cell_data" href="#simulation.cell.CellList.cell_data">cell_data</a></code></li>
<li><code><a title="simulation.cell.CellList.create_from_seed" href="#simulation.cell.CellList.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="simulation.cell.CellList.extend" href="#simulation.cell.CellList.extend">extend</a></code></li>
<li><code><a title="simulation.cell.CellList.get_cells_in_voxel" href="#simulation.cell.CellList.get_cells_in_voxel">get_cells_in_voxel</a></code></li>
<li><code><a title="simulation.cell.CellList.get_neighboring_cells" href="#simulation.cell.CellList.get_neighboring_cells">get_neighboring_cells</a></code></li>
<li><code><a title="simulation.cell.CellList.grid" href="#simulation.cell.CellList.grid">grid</a></code></li>
<li><code><a title="simulation.cell.CellList.load" href="#simulation.cell.CellList.load">load</a></code></li>
<li><code><a title="simulation.cell.CellList.max_cells" href="#simulation.cell.CellList.max_cells">max_cells</a></code></li>
<li><code><a title="simulation.cell.CellList.save" href="#simulation.cell.CellList.save">save</a></code></li>
<li><code><a title="simulation.cell.CellList.update_voxel_index" href="#simulation.cell.CellList.update_voxel_index">update_voxel_index</a></code></li>
<li><code><a title="simulation.cell.CellList.voxel_index" href="#simulation.cell.CellList.voxel_index">voxel_index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>