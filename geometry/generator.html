<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nlisim.geometry.generator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nlisim.geometry.generator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import struct
import time
from typing import List, Tuple, Union

import h5py
import numpy as np
from scipy import ndimage
import vtk

from nlisim.coordinates import Point
from nlisim.diffusion import discrete_laplacian
from nlisim.geometry.math_function import Cylinder, Sphere
from nlisim.grid import RectangularGrid

# tissue type
SAC = &#39;sac&#39;
DUCT = &#39;duct&#39;
QUADRIC = &#39;quadric&#39;

# tissue number
AIR = 0
BLOOD = 1
REGULAR_TISSUE = 2
EPITHELIUM = 3
SURF = 4
PORES = 5

ShapeType = Tuple[int, int, int]
SpacingType = Tuple[float, float, float]


class Geometry(object):
    def __init__(self, shape: ShapeType, space: SpacingType, scale: int, randomness: int):
        self.scale = scale
        self.randomness = randomness
        self.shape = (shape[0] * scale, shape[1] * scale, shape[2] * scale)
        self.space = space
        self.grid = RectangularGrid.construct_uniform(self.shape, self.space)

        self.geo = self.grid.allocate_variable(dtype=np.dtype(np.int8))
        self.geo.fill(2)
        self.fixed = np.zeros(self.shape)

        self.duct_f: List[Union[Sphere, Cylinder]] = []
        self.sac_f: List[Union[Sphere, Cylinder]] = []

    def add(self, function):
        &#34;&#34;&#34;Add functions to the generator.&#34;&#34;&#34;
        function.scale(self.scale)
        if function.type == SAC:
            self.sac_f.append(function)
        elif function.type == DUCT:
            self.duct_f.append(function)
        else:
            raise Exception(&#39;Unknown tissue type&#39;)

    def construct_sphere(self, lungtissue, center: Point, r: float):
        &#34;&#34;&#34;Construct sphere within simulation space.&#34;&#34;&#34;
        coords = np.ogrid[: lungtissue.shape[0], : lungtissue.shape[1], : lungtissue.shape[2]]
        distance = np.sqrt(
            (coords[0] - center.z) ** 2 + (coords[1] - center.y) ** 2 + (coords[2] - center.x) ** 2
        )
        return 1 * (distance &lt;= r)

    def construct_cylinder(
        self,
        lung_tissue: np.ndarray,
        center: Point,
        length: float,
        direction: np.ndarray,
        r: np.ndarray,
    ):
        &#34;&#34;&#34;Construct cylinder within simulation space.&#34;&#34;&#34;
        coords = np.indices(lung_tissue.shape, dtype=np.float64).T

        # normalize direction, just in case
        direction = direction / np.linalg.norm(direction)

        relative_coords: np.ndarray = coords - center
        distance_along_axis: np.ndarray = relative_coords @ direction
        distance_from_axis = np.linalg.norm(
            relative_coords - np.multiply.outer(relative_coords @ direction, direction), axis=3
        )
        mask = np.logical_and(distance_from_axis &lt;= r.T, distance_along_axis &lt;= (length / 2.0)).T
        return mask

    def construct_air_duct(self, random_mask):
        print(&#39;constructing air duct...&#39;)
        tissue = self.geo
        fixed = self.fixed
        # construct air duct
        for function in self.duct_f:
            if isinstance(function, Cylinder):
                air_mask = self.construct_cylinder(
                    tissue,
                    function.center,
                    function.length,
                    function.direction,
                    function.radius + random_mask,
                )
                tissue[np.logical_and(air_mask == 1, fixed == 0)] = AIR

        # blur the noise to maintain the continuousness of the air
        blur_mask = np.where(tissue == AIR, 1, 0)
        blur_air_mask = ndimage.filters.convolve(blur_mask, np.ones((3, 3, 3)))
        tissue[blur_air_mask &gt; 13] = AIR
        tissue[blur_air_mask &lt;= 13] = REGULAR_TISSUE
        fixed[tissue == AIR] = 1

        # construct epithelium layer
        air_mask = np.where(tissue == AIR, 1, 0)
        epithelium_mask = ndimage.filters.convolve(air_mask, np.ones((3, 3, 3)))
        tissue[np.logical_and(epithelium_mask &gt; 0, tissue == REGULAR_TISSUE)] = EPITHELIUM

    def construct_alveolus(self, random_mask):
        tissue = self.geo
        fixed = self.fixed
        print(&#39;constructing alveolus...&#39;)
        # construct sac
        for function in self.sac_f:
            if isinstance(function, Sphere):
                air_mask = self.construct_sphere(
                    tissue, function.center, function.radius + random_mask
                )
                blur_air_mask = ndimage.filters.convolve(air_mask, np.ones((3, 3, 3)))
                fixed_air_mask = np.logical_and(blur_air_mask &gt; 13, fixed == 0)
                tissue[fixed_air_mask] = AIR
                tissue[
                    np.logical_and(np.logical_and(blur_air_mask &lt;= 13, fixed == 0), tissue == AIR)
                ] = REGULAR_TISSUE
                fixed[fixed_air_mask] = 1

                # construct epithelium layer
                epithelium_mask = ndimage.filters.convolve(fixed_air_mask, np.ones((3, 3, 3)))
                fixed_epithelium_mask = np.logical_and(epithelium_mask &gt; 0, fixed == 0)
                tissue[fixed_epithelium_mask] = EPITHELIUM
                fixed[fixed_epithelium_mask] = 1

    def construct(self, simple):
        &#34;&#34;&#34;Construct the simulation space with math functions.&#34;&#34;&#34;
        tissue = self.geo
        # fixed = self.fixed

        random_mask = np.random.normal(0, self.randomness, self.shape)

        self.construct_air_duct(random_mask)
        self.construct_alveolus(random_mask)

        epi_mask = np.where(tissue == EPITHELIUM, 2, 0)
        surf_mask = ndimage.filters.convolve(epi_mask, np.ones((3, 3, 3)))
        print(&#39;constructing surfactant layer and capillary...&#39;)
        # construct surfactant and blood vessel
        if not simple:
            tissue[np.logical_and(tissue == AIR, surf_mask &gt; 0)] = SURF
        tissue[np.logical_and(tissue == REGULAR_TISSUE, surf_mask &gt; 0)] = BLOOD

    def write_to_vtk(self, filename):
        zbin, ybin, xbin = self.shape

        f = open(filename, &#39;w&#39;)
        f.write(&#39;# vtk DataFile Version 4.2\n&#39;)
        f.write(&#39;Aspergillus simulation: Geometry\n&#39;)
        f.write(&#39;BINARY\n&#39;)
        f.write(&#39;DATASET STRUCTURED_POINTS\n&#39;)
        f.write(&#39;DIMENSIONS &#39; + str(xbin) + &#39; &#39; + str(ybin) + &#39; &#39; + str(zbin) + &#39;\n&#39;)
        f.write(&#39;ASPECT_RATIO 1 1 1\n&#39;)
        f.write(&#39;ORIGIN 0 0 0\n&#39;)
        f.write(&#39;POINT_DATA &#39; + str(xbin * ybin * zbin) + &#39;\n&#39;)
        f.write(&#39;SCALARS TissueType unsigned_char 1\n&#39;)
        f.write(&#39;LOOKUP_TABLE default\n&#39;)
        f.close()

        f = open(filename, &#39;ab&#39;)
        array = self.geo.flatten()
        array = array.astype(int)

        b = struct.pack(len(array) * &#39;B&#39;, *array)
        f.write(b)
        f.close()

    def write_to_hdf5(self, filename, laplacian):
        # Write data to HDF5
        with h5py.File(filename, &#39;w&#39;) as data_file:
            data_file.create_dataset(&#39;geometry&#39;, data=self.geo)

            if laplacian:
                # embed laplacian matrix for all layers
                # surfactant layer laplacian
                surf_lapl = discrete_laplacian(self.grid, self.geo == SURF)
                # epithelium layer laplacian
                epi_lapl = discrete_laplacian(self.grid, self.geo == EPITHELIUM)
                # capillary layer laplacian
                blood_lapl = discrete_laplacian(self.grid, self.geo == BLOOD)

                d = {&#39;surf_lapl&#39;: surf_lapl, &#39;epi_lapl&#39;: epi_lapl, &#39;blood_lapl&#39;: blood_lapl}
                matrices = data_file.create_group(&#39;lapl_matrices&#39;)
                for name, lapl in d.items():
                    matrix = matrices.create_group(name)
                    matrix.create_dataset(&#39;data&#39;, data=lapl.data)
                    matrix.create_dataset(&#39;indptr&#39;, data=lapl.indptr)
                    matrix.create_dataset(&#39;indices&#39;, data=lapl.indices)
                    matrix.attrs[&#39;shape&#39;] = lapl.shape

    def preview(self):
        zbin, ybin, xbin = self.shape
        data_importer = vtk.vtkImageImport()

        g = self.geo.flatten()
        g = np.uint8(g)
        data_string = g.tostring()
        data_importer.CopyImportVoidPointer(data_string, len(data_string))
        data_importer.SetDataScalarTypeToUnsignedChar()
        data_importer.SetNumberOfScalarComponents(1)

        data_importer.SetDataExtent(0, xbin - 1, 0, ybin - 1, 0, zbin - 1)
        data_importer.SetWholeExtent(0, xbin - 1, 0, ybin - 1, 0, zbin - 1)

        # Create transfer mapping scalar value to opacity
        opacity_transfer_function = vtk.vtkPiecewiseFunction()
        opacity_transfer_function.AddPoint(0, 0.0)
        opacity_transfer_function.AddPoint(1, 0.2)
        opacity_transfer_function.AddPoint(2, 0.005)
        opacity_transfer_function.AddPoint(3, 1)

        # Create transfer mapping scalar value to color
        color_transfer_function = vtk.vtkColorTransferFunction()
        color_transfer_function.AddRGBPoint(0, 0.0, 0.0, 1.0)
        color_transfer_function.AddRGBPoint(1, 1.0, 0.0, 0.0)
        color_transfer_function.AddRGBPoint(2, 0.0, 0.0, 1.0)
        color_transfer_function.AddRGBPoint(3, 1.0, 1.0, 1.0)

        # The property describes how the data will look
        volume_property = vtk.vtkVolumeProperty()
        volume_property.SetColor(color_transfer_function)
        volume_property.SetScalarOpacity(opacity_transfer_function)
        volume_property.SetInterpolationTypeToLinear()

        # The mapper / ray cast function know how to render the data
        volume_mapper = vtk.vtkGPUVolumeRayCastMapper()
        volume_mapper.SetBlendModeToComposite()
        volume_mapper.SetInputConnection(data_importer.GetOutputPort())

        # The volume holds the mapper and the property and
        # can be used to position/orient the volume
        volume = vtk.vtkVolume()
        volume.SetMapper(volume_mapper)
        volume.SetProperty(volume_property)

        ren = vtk.vtkRenderer()
        ren_win = vtk.vtkRenderWindow()
        ren_win.AddRenderer(ren)
        iren = vtk.vtkRenderWindowInteractor()
        iren.SetRenderWindow(ren_win)

        ren.AddVolume(volume)
        ren.SetBackground(1, 1, 1)
        ren_win.SetSize(600, 600)
        ren_win.Render()

        def check_abort(obj, event):
            if obj.GetEventPending() != 0:
                obj.SetAbortRender(1)

        ren_win.AddObserver(&#39;AbortCheckEvent&#39;, check_abort)

        iren.Initialize()
        ren_win.Render()
        iren.Start()


def generate_geometry(config, output, preview, simple, lapl):
    start_time = time.time()

    with open(config) as f:
        data = json.load(f)

        scale = data[&#39;scaling&#39;]
        randomness = data[&#39;randomness&#39;]
        shape = (data[&#39;shape&#39;][&#39;zbin&#39;], data[&#39;shape&#39;][&#39;ybin&#39;], data[&#39;shape&#39;][&#39;xbin&#39;])
        space = (data[&#39;space&#39;][&#39;dz&#39;], data[&#39;space&#39;][&#39;dy&#39;], data[&#39;space&#39;][&#39;dx&#39;])

        g = Geometry(shape, space, scale, randomness)

        for function in data[&#39;function&#39;]:
            if function[&#39;shape&#39;] == &#39;sphere&#39;:
                f = Sphere(function[&#39;center&#39;], function[&#39;radius&#39;], function[&#39;type&#39;])
                g.add(f)

            elif function[&#39;shape&#39;] == &#39;cylinder&#39;:
                f = Cylinder(
                    function[&#39;center&#39;],
                    function[&#39;direction&#39;],
                    function[&#39;radius&#39;],
                    function[&#39;length&#39;],
                    function[&#39;type&#39;],
                )
                g.add(f)

        # g.scaling(data[&#34;scaling&#34;])
        g.construct(simple)
        g.write_to_hdf5(output + &#39;.hdf5&#39;, lapl)
        g.write_to_vtk(output + &#39;.vtk&#39;)
    print(f&#39;--- {(time.time() - start_time)} seconds ---&#39;)
    if preview:
        g.preview()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nlisim.geometry.generator.generate_geometry"><code class="name flex">
<span>def <span class="ident">generate_geometry</span></span>(<span>config, output, preview, simple, lapl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_geometry(config, output, preview, simple, lapl):
    start_time = time.time()

    with open(config) as f:
        data = json.load(f)

        scale = data[&#39;scaling&#39;]
        randomness = data[&#39;randomness&#39;]
        shape = (data[&#39;shape&#39;][&#39;zbin&#39;], data[&#39;shape&#39;][&#39;ybin&#39;], data[&#39;shape&#39;][&#39;xbin&#39;])
        space = (data[&#39;space&#39;][&#39;dz&#39;], data[&#39;space&#39;][&#39;dy&#39;], data[&#39;space&#39;][&#39;dx&#39;])

        g = Geometry(shape, space, scale, randomness)

        for function in data[&#39;function&#39;]:
            if function[&#39;shape&#39;] == &#39;sphere&#39;:
                f = Sphere(function[&#39;center&#39;], function[&#39;radius&#39;], function[&#39;type&#39;])
                g.add(f)

            elif function[&#39;shape&#39;] == &#39;cylinder&#39;:
                f = Cylinder(
                    function[&#39;center&#39;],
                    function[&#39;direction&#39;],
                    function[&#39;radius&#39;],
                    function[&#39;length&#39;],
                    function[&#39;type&#39;],
                )
                g.add(f)

        # g.scaling(data[&#34;scaling&#34;])
        g.construct(simple)
        g.write_to_hdf5(output + &#39;.hdf5&#39;, lapl)
        g.write_to_vtk(output + &#39;.vtk&#39;)
    print(f&#39;--- {(time.time() - start_time)} seconds ---&#39;)
    if preview:
        g.preview()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nlisim.geometry.generator.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
<span>(</span><span>shape: Tuple[int, int, int], space: Tuple[float, float, float], scale: int, randomness: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry(object):
    def __init__(self, shape: ShapeType, space: SpacingType, scale: int, randomness: int):
        self.scale = scale
        self.randomness = randomness
        self.shape = (shape[0] * scale, shape[1] * scale, shape[2] * scale)
        self.space = space
        self.grid = RectangularGrid.construct_uniform(self.shape, self.space)

        self.geo = self.grid.allocate_variable(dtype=np.dtype(np.int8))
        self.geo.fill(2)
        self.fixed = np.zeros(self.shape)

        self.duct_f: List[Union[Sphere, Cylinder]] = []
        self.sac_f: List[Union[Sphere, Cylinder]] = []

    def add(self, function):
        &#34;&#34;&#34;Add functions to the generator.&#34;&#34;&#34;
        function.scale(self.scale)
        if function.type == SAC:
            self.sac_f.append(function)
        elif function.type == DUCT:
            self.duct_f.append(function)
        else:
            raise Exception(&#39;Unknown tissue type&#39;)

    def construct_sphere(self, lungtissue, center: Point, r: float):
        &#34;&#34;&#34;Construct sphere within simulation space.&#34;&#34;&#34;
        coords = np.ogrid[: lungtissue.shape[0], : lungtissue.shape[1], : lungtissue.shape[2]]
        distance = np.sqrt(
            (coords[0] - center.z) ** 2 + (coords[1] - center.y) ** 2 + (coords[2] - center.x) ** 2
        )
        return 1 * (distance &lt;= r)

    def construct_cylinder(
        self,
        lung_tissue: np.ndarray,
        center: Point,
        length: float,
        direction: np.ndarray,
        r: np.ndarray,
    ):
        &#34;&#34;&#34;Construct cylinder within simulation space.&#34;&#34;&#34;
        coords = np.indices(lung_tissue.shape, dtype=np.float64).T

        # normalize direction, just in case
        direction = direction / np.linalg.norm(direction)

        relative_coords: np.ndarray = coords - center
        distance_along_axis: np.ndarray = relative_coords @ direction
        distance_from_axis = np.linalg.norm(
            relative_coords - np.multiply.outer(relative_coords @ direction, direction), axis=3
        )
        mask = np.logical_and(distance_from_axis &lt;= r.T, distance_along_axis &lt;= (length / 2.0)).T
        return mask

    def construct_air_duct(self, random_mask):
        print(&#39;constructing air duct...&#39;)
        tissue = self.geo
        fixed = self.fixed
        # construct air duct
        for function in self.duct_f:
            if isinstance(function, Cylinder):
                air_mask = self.construct_cylinder(
                    tissue,
                    function.center,
                    function.length,
                    function.direction,
                    function.radius + random_mask,
                )
                tissue[np.logical_and(air_mask == 1, fixed == 0)] = AIR

        # blur the noise to maintain the continuousness of the air
        blur_mask = np.where(tissue == AIR, 1, 0)
        blur_air_mask = ndimage.filters.convolve(blur_mask, np.ones((3, 3, 3)))
        tissue[blur_air_mask &gt; 13] = AIR
        tissue[blur_air_mask &lt;= 13] = REGULAR_TISSUE
        fixed[tissue == AIR] = 1

        # construct epithelium layer
        air_mask = np.where(tissue == AIR, 1, 0)
        epithelium_mask = ndimage.filters.convolve(air_mask, np.ones((3, 3, 3)))
        tissue[np.logical_and(epithelium_mask &gt; 0, tissue == REGULAR_TISSUE)] = EPITHELIUM

    def construct_alveolus(self, random_mask):
        tissue = self.geo
        fixed = self.fixed
        print(&#39;constructing alveolus...&#39;)
        # construct sac
        for function in self.sac_f:
            if isinstance(function, Sphere):
                air_mask = self.construct_sphere(
                    tissue, function.center, function.radius + random_mask
                )
                blur_air_mask = ndimage.filters.convolve(air_mask, np.ones((3, 3, 3)))
                fixed_air_mask = np.logical_and(blur_air_mask &gt; 13, fixed == 0)
                tissue[fixed_air_mask] = AIR
                tissue[
                    np.logical_and(np.logical_and(blur_air_mask &lt;= 13, fixed == 0), tissue == AIR)
                ] = REGULAR_TISSUE
                fixed[fixed_air_mask] = 1

                # construct epithelium layer
                epithelium_mask = ndimage.filters.convolve(fixed_air_mask, np.ones((3, 3, 3)))
                fixed_epithelium_mask = np.logical_and(epithelium_mask &gt; 0, fixed == 0)
                tissue[fixed_epithelium_mask] = EPITHELIUM
                fixed[fixed_epithelium_mask] = 1

    def construct(self, simple):
        &#34;&#34;&#34;Construct the simulation space with math functions.&#34;&#34;&#34;
        tissue = self.geo
        # fixed = self.fixed

        random_mask = np.random.normal(0, self.randomness, self.shape)

        self.construct_air_duct(random_mask)
        self.construct_alveolus(random_mask)

        epi_mask = np.where(tissue == EPITHELIUM, 2, 0)
        surf_mask = ndimage.filters.convolve(epi_mask, np.ones((3, 3, 3)))
        print(&#39;constructing surfactant layer and capillary...&#39;)
        # construct surfactant and blood vessel
        if not simple:
            tissue[np.logical_and(tissue == AIR, surf_mask &gt; 0)] = SURF
        tissue[np.logical_and(tissue == REGULAR_TISSUE, surf_mask &gt; 0)] = BLOOD

    def write_to_vtk(self, filename):
        zbin, ybin, xbin = self.shape

        f = open(filename, &#39;w&#39;)
        f.write(&#39;# vtk DataFile Version 4.2\n&#39;)
        f.write(&#39;Aspergillus simulation: Geometry\n&#39;)
        f.write(&#39;BINARY\n&#39;)
        f.write(&#39;DATASET STRUCTURED_POINTS\n&#39;)
        f.write(&#39;DIMENSIONS &#39; + str(xbin) + &#39; &#39; + str(ybin) + &#39; &#39; + str(zbin) + &#39;\n&#39;)
        f.write(&#39;ASPECT_RATIO 1 1 1\n&#39;)
        f.write(&#39;ORIGIN 0 0 0\n&#39;)
        f.write(&#39;POINT_DATA &#39; + str(xbin * ybin * zbin) + &#39;\n&#39;)
        f.write(&#39;SCALARS TissueType unsigned_char 1\n&#39;)
        f.write(&#39;LOOKUP_TABLE default\n&#39;)
        f.close()

        f = open(filename, &#39;ab&#39;)
        array = self.geo.flatten()
        array = array.astype(int)

        b = struct.pack(len(array) * &#39;B&#39;, *array)
        f.write(b)
        f.close()

    def write_to_hdf5(self, filename, laplacian):
        # Write data to HDF5
        with h5py.File(filename, &#39;w&#39;) as data_file:
            data_file.create_dataset(&#39;geometry&#39;, data=self.geo)

            if laplacian:
                # embed laplacian matrix for all layers
                # surfactant layer laplacian
                surf_lapl = discrete_laplacian(self.grid, self.geo == SURF)
                # epithelium layer laplacian
                epi_lapl = discrete_laplacian(self.grid, self.geo == EPITHELIUM)
                # capillary layer laplacian
                blood_lapl = discrete_laplacian(self.grid, self.geo == BLOOD)

                d = {&#39;surf_lapl&#39;: surf_lapl, &#39;epi_lapl&#39;: epi_lapl, &#39;blood_lapl&#39;: blood_lapl}
                matrices = data_file.create_group(&#39;lapl_matrices&#39;)
                for name, lapl in d.items():
                    matrix = matrices.create_group(name)
                    matrix.create_dataset(&#39;data&#39;, data=lapl.data)
                    matrix.create_dataset(&#39;indptr&#39;, data=lapl.indptr)
                    matrix.create_dataset(&#39;indices&#39;, data=lapl.indices)
                    matrix.attrs[&#39;shape&#39;] = lapl.shape

    def preview(self):
        zbin, ybin, xbin = self.shape
        data_importer = vtk.vtkImageImport()

        g = self.geo.flatten()
        g = np.uint8(g)
        data_string = g.tostring()
        data_importer.CopyImportVoidPointer(data_string, len(data_string))
        data_importer.SetDataScalarTypeToUnsignedChar()
        data_importer.SetNumberOfScalarComponents(1)

        data_importer.SetDataExtent(0, xbin - 1, 0, ybin - 1, 0, zbin - 1)
        data_importer.SetWholeExtent(0, xbin - 1, 0, ybin - 1, 0, zbin - 1)

        # Create transfer mapping scalar value to opacity
        opacity_transfer_function = vtk.vtkPiecewiseFunction()
        opacity_transfer_function.AddPoint(0, 0.0)
        opacity_transfer_function.AddPoint(1, 0.2)
        opacity_transfer_function.AddPoint(2, 0.005)
        opacity_transfer_function.AddPoint(3, 1)

        # Create transfer mapping scalar value to color
        color_transfer_function = vtk.vtkColorTransferFunction()
        color_transfer_function.AddRGBPoint(0, 0.0, 0.0, 1.0)
        color_transfer_function.AddRGBPoint(1, 1.0, 0.0, 0.0)
        color_transfer_function.AddRGBPoint(2, 0.0, 0.0, 1.0)
        color_transfer_function.AddRGBPoint(3, 1.0, 1.0, 1.0)

        # The property describes how the data will look
        volume_property = vtk.vtkVolumeProperty()
        volume_property.SetColor(color_transfer_function)
        volume_property.SetScalarOpacity(opacity_transfer_function)
        volume_property.SetInterpolationTypeToLinear()

        # The mapper / ray cast function know how to render the data
        volume_mapper = vtk.vtkGPUVolumeRayCastMapper()
        volume_mapper.SetBlendModeToComposite()
        volume_mapper.SetInputConnection(data_importer.GetOutputPort())

        # The volume holds the mapper and the property and
        # can be used to position/orient the volume
        volume = vtk.vtkVolume()
        volume.SetMapper(volume_mapper)
        volume.SetProperty(volume_property)

        ren = vtk.vtkRenderer()
        ren_win = vtk.vtkRenderWindow()
        ren_win.AddRenderer(ren)
        iren = vtk.vtkRenderWindowInteractor()
        iren.SetRenderWindow(ren_win)

        ren.AddVolume(volume)
        ren.SetBackground(1, 1, 1)
        ren_win.SetSize(600, 600)
        ren_win.Render()

        def check_abort(obj, event):
            if obj.GetEventPending() != 0:
                obj.SetAbortRender(1)

        ren_win.AddObserver(&#39;AbortCheckEvent&#39;, check_abort)

        iren.Initialize()
        ren_win.Render()
        iren.Start()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nlisim.geometry.generator.Geometry.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Add functions to the generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, function):
    &#34;&#34;&#34;Add functions to the generator.&#34;&#34;&#34;
    function.scale(self.scale)
    if function.type == SAC:
        self.sac_f.append(function)
    elif function.type == DUCT:
        self.duct_f.append(function)
    else:
        raise Exception(&#39;Unknown tissue type&#39;)</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.construct"><code class="name flex">
<span>def <span class="ident">construct</span></span>(<span>self, simple)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the simulation space with math functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct(self, simple):
    &#34;&#34;&#34;Construct the simulation space with math functions.&#34;&#34;&#34;
    tissue = self.geo
    # fixed = self.fixed

    random_mask = np.random.normal(0, self.randomness, self.shape)

    self.construct_air_duct(random_mask)
    self.construct_alveolus(random_mask)

    epi_mask = np.where(tissue == EPITHELIUM, 2, 0)
    surf_mask = ndimage.filters.convolve(epi_mask, np.ones((3, 3, 3)))
    print(&#39;constructing surfactant layer and capillary...&#39;)
    # construct surfactant and blood vessel
    if not simple:
        tissue[np.logical_and(tissue == AIR, surf_mask &gt; 0)] = SURF
    tissue[np.logical_and(tissue == REGULAR_TISSUE, surf_mask &gt; 0)] = BLOOD</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.construct_air_duct"><code class="name flex">
<span>def <span class="ident">construct_air_duct</span></span>(<span>self, random_mask)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_air_duct(self, random_mask):
    print(&#39;constructing air duct...&#39;)
    tissue = self.geo
    fixed = self.fixed
    # construct air duct
    for function in self.duct_f:
        if isinstance(function, Cylinder):
            air_mask = self.construct_cylinder(
                tissue,
                function.center,
                function.length,
                function.direction,
                function.radius + random_mask,
            )
            tissue[np.logical_and(air_mask == 1, fixed == 0)] = AIR

    # blur the noise to maintain the continuousness of the air
    blur_mask = np.where(tissue == AIR, 1, 0)
    blur_air_mask = ndimage.filters.convolve(blur_mask, np.ones((3, 3, 3)))
    tissue[blur_air_mask &gt; 13] = AIR
    tissue[blur_air_mask &lt;= 13] = REGULAR_TISSUE
    fixed[tissue == AIR] = 1

    # construct epithelium layer
    air_mask = np.where(tissue == AIR, 1, 0)
    epithelium_mask = ndimage.filters.convolve(air_mask, np.ones((3, 3, 3)))
    tissue[np.logical_and(epithelium_mask &gt; 0, tissue == REGULAR_TISSUE)] = EPITHELIUM</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.construct_alveolus"><code class="name flex">
<span>def <span class="ident">construct_alveolus</span></span>(<span>self, random_mask)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_alveolus(self, random_mask):
    tissue = self.geo
    fixed = self.fixed
    print(&#39;constructing alveolus...&#39;)
    # construct sac
    for function in self.sac_f:
        if isinstance(function, Sphere):
            air_mask = self.construct_sphere(
                tissue, function.center, function.radius + random_mask
            )
            blur_air_mask = ndimage.filters.convolve(air_mask, np.ones((3, 3, 3)))
            fixed_air_mask = np.logical_and(blur_air_mask &gt; 13, fixed == 0)
            tissue[fixed_air_mask] = AIR
            tissue[
                np.logical_and(np.logical_and(blur_air_mask &lt;= 13, fixed == 0), tissue == AIR)
            ] = REGULAR_TISSUE
            fixed[fixed_air_mask] = 1

            # construct epithelium layer
            epithelium_mask = ndimage.filters.convolve(fixed_air_mask, np.ones((3, 3, 3)))
            fixed_epithelium_mask = np.logical_and(epithelium_mask &gt; 0, fixed == 0)
            tissue[fixed_epithelium_mask] = EPITHELIUM
            fixed[fixed_epithelium_mask] = 1</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.construct_cylinder"><code class="name flex">
<span>def <span class="ident">construct_cylinder</span></span>(<span>self, lung_tissue: numpy.ndarray, center: <a title="nlisim.coordinates.Point" href="../coordinates.html#nlisim.coordinates.Point">Point</a>, length: float, direction: numpy.ndarray, r: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct cylinder within simulation space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_cylinder(
    self,
    lung_tissue: np.ndarray,
    center: Point,
    length: float,
    direction: np.ndarray,
    r: np.ndarray,
):
    &#34;&#34;&#34;Construct cylinder within simulation space.&#34;&#34;&#34;
    coords = np.indices(lung_tissue.shape, dtype=np.float64).T

    # normalize direction, just in case
    direction = direction / np.linalg.norm(direction)

    relative_coords: np.ndarray = coords - center
    distance_along_axis: np.ndarray = relative_coords @ direction
    distance_from_axis = np.linalg.norm(
        relative_coords - np.multiply.outer(relative_coords @ direction, direction), axis=3
    )
    mask = np.logical_and(distance_from_axis &lt;= r.T, distance_along_axis &lt;= (length / 2.0)).T
    return mask</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.construct_sphere"><code class="name flex">
<span>def <span class="ident">construct_sphere</span></span>(<span>self, lungtissue, center: <a title="nlisim.coordinates.Point" href="../coordinates.html#nlisim.coordinates.Point">Point</a>, r: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct sphere within simulation space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_sphere(self, lungtissue, center: Point, r: float):
    &#34;&#34;&#34;Construct sphere within simulation space.&#34;&#34;&#34;
    coords = np.ogrid[: lungtissue.shape[0], : lungtissue.shape[1], : lungtissue.shape[2]]
    distance = np.sqrt(
        (coords[0] - center.z) ** 2 + (coords[1] - center.y) ** 2 + (coords[2] - center.x) ** 2
    )
    return 1 * (distance &lt;= r)</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.preview"><code class="name flex">
<span>def <span class="ident">preview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preview(self):
    zbin, ybin, xbin = self.shape
    data_importer = vtk.vtkImageImport()

    g = self.geo.flatten()
    g = np.uint8(g)
    data_string = g.tostring()
    data_importer.CopyImportVoidPointer(data_string, len(data_string))
    data_importer.SetDataScalarTypeToUnsignedChar()
    data_importer.SetNumberOfScalarComponents(1)

    data_importer.SetDataExtent(0, xbin - 1, 0, ybin - 1, 0, zbin - 1)
    data_importer.SetWholeExtent(0, xbin - 1, 0, ybin - 1, 0, zbin - 1)

    # Create transfer mapping scalar value to opacity
    opacity_transfer_function = vtk.vtkPiecewiseFunction()
    opacity_transfer_function.AddPoint(0, 0.0)
    opacity_transfer_function.AddPoint(1, 0.2)
    opacity_transfer_function.AddPoint(2, 0.005)
    opacity_transfer_function.AddPoint(3, 1)

    # Create transfer mapping scalar value to color
    color_transfer_function = vtk.vtkColorTransferFunction()
    color_transfer_function.AddRGBPoint(0, 0.0, 0.0, 1.0)
    color_transfer_function.AddRGBPoint(1, 1.0, 0.0, 0.0)
    color_transfer_function.AddRGBPoint(2, 0.0, 0.0, 1.0)
    color_transfer_function.AddRGBPoint(3, 1.0, 1.0, 1.0)

    # The property describes how the data will look
    volume_property = vtk.vtkVolumeProperty()
    volume_property.SetColor(color_transfer_function)
    volume_property.SetScalarOpacity(opacity_transfer_function)
    volume_property.SetInterpolationTypeToLinear()

    # The mapper / ray cast function know how to render the data
    volume_mapper = vtk.vtkGPUVolumeRayCastMapper()
    volume_mapper.SetBlendModeToComposite()
    volume_mapper.SetInputConnection(data_importer.GetOutputPort())

    # The volume holds the mapper and the property and
    # can be used to position/orient the volume
    volume = vtk.vtkVolume()
    volume.SetMapper(volume_mapper)
    volume.SetProperty(volume_property)

    ren = vtk.vtkRenderer()
    ren_win = vtk.vtkRenderWindow()
    ren_win.AddRenderer(ren)
    iren = vtk.vtkRenderWindowInteractor()
    iren.SetRenderWindow(ren_win)

    ren.AddVolume(volume)
    ren.SetBackground(1, 1, 1)
    ren_win.SetSize(600, 600)
    ren_win.Render()

    def check_abort(obj, event):
        if obj.GetEventPending() != 0:
            obj.SetAbortRender(1)

    ren_win.AddObserver(&#39;AbortCheckEvent&#39;, check_abort)

    iren.Initialize()
    ren_win.Render()
    iren.Start()</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.write_to_hdf5"><code class="name flex">
<span>def <span class="ident">write_to_hdf5</span></span>(<span>self, filename, laplacian)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_hdf5(self, filename, laplacian):
    # Write data to HDF5
    with h5py.File(filename, &#39;w&#39;) as data_file:
        data_file.create_dataset(&#39;geometry&#39;, data=self.geo)

        if laplacian:
            # embed laplacian matrix for all layers
            # surfactant layer laplacian
            surf_lapl = discrete_laplacian(self.grid, self.geo == SURF)
            # epithelium layer laplacian
            epi_lapl = discrete_laplacian(self.grid, self.geo == EPITHELIUM)
            # capillary layer laplacian
            blood_lapl = discrete_laplacian(self.grid, self.geo == BLOOD)

            d = {&#39;surf_lapl&#39;: surf_lapl, &#39;epi_lapl&#39;: epi_lapl, &#39;blood_lapl&#39;: blood_lapl}
            matrices = data_file.create_group(&#39;lapl_matrices&#39;)
            for name, lapl in d.items():
                matrix = matrices.create_group(name)
                matrix.create_dataset(&#39;data&#39;, data=lapl.data)
                matrix.create_dataset(&#39;indptr&#39;, data=lapl.indptr)
                matrix.create_dataset(&#39;indices&#39;, data=lapl.indices)
                matrix.attrs[&#39;shape&#39;] = lapl.shape</code></pre>
</details>
</dd>
<dt id="nlisim.geometry.generator.Geometry.write_to_vtk"><code class="name flex">
<span>def <span class="ident">write_to_vtk</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_vtk(self, filename):
    zbin, ybin, xbin = self.shape

    f = open(filename, &#39;w&#39;)
    f.write(&#39;# vtk DataFile Version 4.2\n&#39;)
    f.write(&#39;Aspergillus simulation: Geometry\n&#39;)
    f.write(&#39;BINARY\n&#39;)
    f.write(&#39;DATASET STRUCTURED_POINTS\n&#39;)
    f.write(&#39;DIMENSIONS &#39; + str(xbin) + &#39; &#39; + str(ybin) + &#39; &#39; + str(zbin) + &#39;\n&#39;)
    f.write(&#39;ASPECT_RATIO 1 1 1\n&#39;)
    f.write(&#39;ORIGIN 0 0 0\n&#39;)
    f.write(&#39;POINT_DATA &#39; + str(xbin * ybin * zbin) + &#39;\n&#39;)
    f.write(&#39;SCALARS TissueType unsigned_char 1\n&#39;)
    f.write(&#39;LOOKUP_TABLE default\n&#39;)
    f.close()

    f = open(filename, &#39;ab&#39;)
    array = self.geo.flatten()
    array = array.astype(int)

    b = struct.pack(len(array) * &#39;B&#39;, *array)
    f.write(b)
    f.close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nlisim.geometry" href="index.html">nlisim.geometry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nlisim.geometry.generator.generate_geometry" href="#nlisim.geometry.generator.generate_geometry">generate_geometry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nlisim.geometry.generator.Geometry" href="#nlisim.geometry.generator.Geometry">Geometry</a></code></h4>
<ul class="two-column">
<li><code><a title="nlisim.geometry.generator.Geometry.add" href="#nlisim.geometry.generator.Geometry.add">add</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.construct" href="#nlisim.geometry.generator.Geometry.construct">construct</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.construct_air_duct" href="#nlisim.geometry.generator.Geometry.construct_air_duct">construct_air_duct</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.construct_alveolus" href="#nlisim.geometry.generator.Geometry.construct_alveolus">construct_alveolus</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.construct_cylinder" href="#nlisim.geometry.generator.Geometry.construct_cylinder">construct_cylinder</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.construct_sphere" href="#nlisim.geometry.generator.Geometry.construct_sphere">construct_sphere</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.preview" href="#nlisim.geometry.generator.Geometry.preview">preview</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.write_to_hdf5" href="#nlisim.geometry.generator.Geometry.write_to_hdf5">write_to_hdf5</a></code></li>
<li><code><a title="nlisim.geometry.generator.Geometry.write_to_vtk" href="#nlisim.geometry.generator.Geometry.write_to_vtk">write_to_vtk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>