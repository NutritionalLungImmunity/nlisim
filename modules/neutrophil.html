<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nlisim.modules.neutrophil API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nlisim.modules.neutrophil</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import random
from typing import Any, Dict, Tuple

import attr
from attr import attrib, attrs
import numpy as np

from nlisim.cell import CellData, CellFields, CellList
from nlisim.coordinates import Point, Voxel
from nlisim.grid import RectangularGrid
from nlisim.modules.mip2 import MIP2State
from nlisim.modules.phagocyte import (
    PhagocyteCellData,
    PhagocyteModel,
    PhagocyteModuleState,
    PhagocyteState,
    PhagocyteStatus,
    interact_with_aspergillus,
)
from nlisim.random import rg
from nlisim.state import State
from nlisim.util import TissueType, activation_function, choose_voxel_by_prob

MAX_CONIDIA = (
    50  # note: this the max that we can set the max to. i.e. not an actual model parameter
)


class NeutrophilCellData(PhagocyteCellData):
    NEUTROPHIL_FIELDS: CellFields = [
        (&#39;status&#39;, np.uint8),
        (&#39;state&#39;, np.uint8),
        (&#39;iron_pool&#39;, np.float64),  # units: atto-mol
        (&#39;tnfa&#39;, bool),
        (&#39;status_iteration&#39;, np.uint),
    ]

    dtype = np.dtype(
        CellData.FIELDS + PhagocyteCellData.PHAGOCYTE_FIELDS + NEUTROPHIL_FIELDS, align=True
    )  # type: ignore

    @classmethod
    def create_cell_tuple(
        cls,
        **kwargs,
    ) -&gt; Tuple:
        initializer = {
            &#39;status&#39;: kwargs.get(&#39;status&#39;, PhagocyteStatus.RESTING),
            &#39;state&#39;: kwargs.get(&#39;state&#39;, PhagocyteState.FREE),
            &#39;iron_pool&#39;: kwargs.get(&#39;iron_pool&#39;, 0.0),
            &#39;tnfa&#39;: kwargs.get(&#39;tnfa&#39;, False),
            &#39;status_iteration&#39;: kwargs.get(&#39;status_iteration&#39;, 0),
        }

        # ensure that these come in the correct order
        return PhagocyteCellData.create_cell_tuple(**kwargs) + tuple(
            [initializer[key] for key, *_ in NeutrophilCellData.NEUTROPHIL_FIELDS]
        )


@attrs(kw_only=True, frozen=True, repr=False)
class NeutrophilCellList(CellList):
    CellDataClass = NeutrophilCellData


def cell_list_factory(self: &#39;NeutrophilState&#39;) -&gt; NeutrophilCellList:
    return NeutrophilCellList(grid=self.global_state.grid)


@attrs(kw_only=True)
class NeutrophilState(PhagocyteModuleState):
    cells: NeutrophilCellList = attrib(default=attr.Factory(cell_list_factory, takes_self=True))
    half_life: float  # units: hours
    apoptosis_probability: float  # units: probability
    time_to_change_state: float  # units: hours
    iter_to_change_state: int  # units: steps
    pr_n_hyphae: float  # units: probability
    pr_n_hyphae_param: float
    pr_n_phagocyte: float  # units: probability
    pr_n_phagocyte_param: float
    recruitment_rate: float
    rec_bias: float
    max_neutrophils: float  # TODO: 0.5?
    n_frac: float
    drift_bias: float
    n_move_rate_act: float  # units: µm
    n_move_rate_rest: float  # units: µm
    init_num_neutrophils: int  # units: count


class Neutrophil(PhagocyteModel):
    name = &#39;neutrophil&#39;
    StateClass = NeutrophilState

    def initialize(self, state: State):
        neutrophil: NeutrophilState = state.neutrophil
        voxel_volume = state.voxel_volume
        lung_tissue = state.lung_tissue

        neutrophil.init_num_neutrophils = self.config.getint(&#39;init_num_neutrophils&#39;)  # units: count

        neutrophil.time_to_change_state = self.config.getfloat(
            &#39;time_to_change_state&#39;
        )  # units: hours
        neutrophil.max_conidia = self.config.getint(
            &#39;max_conidia&#39;
        )  # (from phagocyte model) units: count

        neutrophil.recruitment_rate = self.config.getfloat(&#39;recruitment_rate&#39;)
        neutrophil.rec_bias = self.config.getfloat(&#39;rec_bias&#39;)
        neutrophil.max_neutrophils = self.config.getfloat(&#39;max_neutrophils&#39;)  # units: count
        neutrophil.n_frac = self.config.getfloat(&#39;n_frac&#39;)

        neutrophil.drift_bias = self.config.getfloat(&#39;drift_bias&#39;)
        neutrophil.n_move_rate_act = self.config.getfloat(&#39;n_move_rate_act&#39;)
        neutrophil.n_move_rate_rest = self.config.getfloat(&#39;n_move_rate_rest&#39;)

        neutrophil.pr_n_hyphae_param = self.config.getfloat(&#39;pr_n_hyphae_param&#39;)
        neutrophil.pr_n_phagocyte_param = self.config.getfloat(&#39;pr_n_phagocyte_param&#39;)

        neutrophil.half_life = self.config.getfloat(&#39;half_life&#39;)  # units: hours

        # computed values
        neutrophil.apoptosis_probability = -math.log(0.5) / (
            neutrophil.half_life * (60 / self.time_step)  # units: hours*(min/hour)/(min/step)=steps
        )  # units: probability
        neutrophil.iter_to_change_state = int(
            neutrophil.time_to_change_state * 60 / self.time_step
        )  # units: hours * (min/hour) / (min/step) = steps
        neutrophil.pr_n_hyphae = -math.expm1(
            -self.time_step / 60 / (voxel_volume * neutrophil.pr_n_hyphae_param)
        )  # units: probability
        neutrophil.pr_n_phagocyte = -math.expm1(
            -self.time_step / 60 / (voxel_volume * neutrophil.pr_n_phagocyte_param)
        )  # units: probability

        # place initial neutrophils
        locations = list(zip(*np.where(lung_tissue != TissueType.AIR)))
        dz_field: np.ndarray = state.grid.delta(axis=0)
        dy_field: np.ndarray = state.grid.delta(axis=1)
        dx_field: np.ndarray = state.grid.delta(axis=2)
        for vox_z, vox_y, vox_x in random.choices(locations, k=neutrophil.init_num_neutrophils):
            # the x,y,z coordinates are in the centers of the grids
            z = state.grid.z[vox_z]
            y = state.grid.y[vox_y]
            x = state.grid.x[vox_x]
            dz = dz_field[vox_z, vox_y, vox_x]
            dy = dy_field[vox_z, vox_y, vox_x]
            dx = dx_field[vox_z, vox_y, vox_x]

            self.create_neutrophil(
                state=state,
                x=x + rg.uniform(-dx / 2, dx / 2),
                y=y + rg.uniform(-dy / 2, dy / 2),
                z=z + rg.uniform(-dz / 2, dz / 2),
            )

        return state

    def advance(self, state: State, previous_time: float):
        &#34;&#34;&#34;Advance the state by a single time step.&#34;&#34;&#34;
        from nlisim.modules.afumigatus import (
            Afumigatus,
            AfumigatusCellData,
            AfumigatusCellStatus,
            AfumigatusState,
        )
        from nlisim.modules.iron import IronState
        from nlisim.modules.macrophage import MacrophageCellData, MacrophageState

        neutrophil: NeutrophilState = state.neutrophil
        macrophage: MacrophageState = state.macrophage
        afumigatus: AfumigatusState = state.afumigatus
        iron: IronState = state.iron
        grid: RectangularGrid = state.grid
        voxel_volume: float = state.voxel_volume
        space_volume: float = state.space_volume

        for neutrophil_cell_index in neutrophil.cells.alive():
            neutrophil_cell = neutrophil.cells[neutrophil_cell_index]
            neutrophil_cell_voxel: Voxel = grid.get_voxel(neutrophil_cell[&#39;point&#39;])

            self.update_status(state, neutrophil_cell)

            # ---------- interactions

            # dead and dying cells release iron
            if neutrophil_cell[&#39;status&#39;] in {
                PhagocyteStatus.NECROTIC,
                PhagocyteStatus.APOPTOTIC,
                PhagocyteStatus.DEAD,
            }:
                iron.grid[tuple(neutrophil_cell_voxel)] += neutrophil_cell[&#39;iron_pool&#39;]
                neutrophil_cell[&#39;iron_pool&#39;] = 0
                neutrophil_cell[&#39;dead&#39;] = True

            # interact with fungus
            if neutrophil_cell[&#39;state&#39;] == PhagocyteState.FREE and neutrophil_cell[
                &#39;status&#39;
            ] not in {
                PhagocyteStatus.APOPTOTIC,
                PhagocyteStatus.NECROTIC,
                PhagocyteStatus.DEAD,
            }:
                # get fungal cells in this voxel
                local_aspergillus = afumigatus.cells.get_cells_in_voxel(neutrophil_cell_voxel)
                for aspergillus_cell_index in local_aspergillus:
                    aspergillus_cell: AfumigatusCellData = afumigatus.cells[aspergillus_cell_index]
                    if aspergillus_cell[&#39;dead&#39;]:
                        continue

                    if aspergillus_cell[&#39;status&#39;] in {
                        AfumigatusCellStatus.HYPHAE,
                        AfumigatusCellStatus.GERM_TUBE,
                    }:
                        # possibly kill the fungal cell, extracellularly
                        if rg.uniform() &lt; neutrophil.pr_n_hyphae:
                            interact_with_aspergillus(
                                phagocyte_cell=neutrophil_cell,
                                aspergillus_cell=aspergillus_cell,
                                aspergillus_cell_index=aspergillus_cell_index,
                                phagocyte=neutrophil,
                            )
                            Afumigatus.kill_fungal_cell(
                                afumigatus=afumigatus,
                                afumigatus_cell=aspergillus_cell,
                                afumigatus_cell_index=aspergillus_cell_index,
                                iron=iron,
                                grid=grid,
                            )
                        else:
                            neutrophil_cell[&#39;state&#39;] = PhagocyteState.INTERACTING

                    elif aspergillus_cell[&#39;status&#39;] == AfumigatusCellStatus.SWELLING_CONIDIA:
                        if rg.uniform() &lt; neutrophil.pr_n_phagocyte:
                            interact_with_aspergillus(
                                phagocyte_cell=neutrophil_cell,
                                aspergillus_cell=aspergillus_cell,
                                aspergillus_cell_index=aspergillus_cell_index,
                                phagocyte=neutrophil,
                            )

            # interact with macrophages:
            # if we are apoptotic, give our iron and phagosome to a nearby
            # present macrophage (if empty)
            if neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.APOPTOTIC:
                local_macrophages = macrophage.cells.get_cells_in_voxel(neutrophil_cell_voxel)
                for macrophage_index in local_macrophages:
                    macrophage_cell: MacrophageCellData = macrophage.cells[macrophage_index]
                    macrophage_num_cells_in_phagosome = np.sum(macrophage_cell[&#39;phagosome&#39;] &gt;= 0)
                    # TODO: Henrique, why only if empty?
                    if macrophage_num_cells_in_phagosome == 0:
                        macrophage_cell[&#39;phagosome&#39;] = neutrophil_cell[&#39;phagosome&#39;]
                        macrophage_cell[&#39;iron_pool&#39;] += neutrophil_cell[&#39;iron_pool&#39;]
                        neutrophil_cell[&#39;iron_pool&#39;] = 0.0
                        neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.DEAD
                        macrophage_cell[&#39;status&#39;] = PhagocyteStatus.INACTIVE

            # Movement
            if neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE:
                max_move_step = neutrophil.n_move_rate_act * self.time_step
            else:
                max_move_step = neutrophil.n_move_rate_rest * self.time_step
            move_step: int = rg.poisson(max_move_step)
            # move the cell 1 µm, move_step number of times
            for _ in range(move_step):
                self.single_step_move(
                    state, neutrophil_cell, neutrophil_cell_index, neutrophil.cells
                )
            # TODO: understand the meaning of the parameter here: moving randomly n steps is
            #  different than moving n steps in a random direction. Which is it?

        # Recruitment
        self.recruit_neutrophils(state, space_volume, voxel_volume)

        return state

    def summary_stats(self, state: State) -&gt; Dict[str, Any]:
        neutrophil: NeutrophilState = state.neutrophil
        live_neutrophils = neutrophil.cells.alive()

        max_index = max(map(int, PhagocyteStatus))
        status_counts = np.bincount(
            np.fromiter(
                (
                    neutrophil.cells[neutrophil_cell_index][&#39;status&#39;]
                    for neutrophil_cell_index in live_neutrophils
                ),
                dtype=np.uint8,
            ),
            minlength=max_index + 1,
        )

        tnfa_active = int(
            np.sum(
                np.fromiter(
                    (
                        neutrophil.cells[neutrophil_cell_index][&#39;tnfa&#39;]
                        for neutrophil_cell_index in live_neutrophils
                    ),
                    dtype=bool,
                )
            )
        )

        return {
            &#39;count&#39;: len(neutrophil.cells.alive()),
            &#39;inactive&#39;: int(status_counts[PhagocyteStatus.INACTIVE]),
            &#39;inactivating&#39;: int(status_counts[PhagocyteStatus.INACTIVATING]),
            &#39;resting&#39;: int(status_counts[PhagocyteStatus.RESTING]),
            &#39;activating&#39;: int(status_counts[PhagocyteStatus.ACTIVATING]),
            &#39;active&#39;: int(status_counts[PhagocyteStatus.ACTIVE]),
            &#39;apoptotic&#39;: int(status_counts[PhagocyteStatus.APOPTOTIC]),
            &#39;necrotic&#39;: int(status_counts[PhagocyteStatus.NECROTIC]),
            &#39;interacting&#39;: int(status_counts[PhagocyteStatus.INTERACTING]),
            &#39;TNFa active&#39;: tnfa_active,
        }

    def visualization_data(self, state: State):
        return &#39;cells&#39;, state.neutrophil.cells

    def single_step_probabilistic_drift(
        self, state: State, cell: PhagocyteCellData, voxel: Voxel
    ) -&gt; Point:
        &#34;&#34;&#34;
        Calculate a 1µm movement of a neutrophil

        Parameters
        ----------
        state : State
            global simulation state
        cell : NeutrophilCellData
            a neutrophil cell
        voxel : Voxel
            current voxel position of the neutrophil

        Returns
        -------
        Point
            the new position of the neutrophil
        &#34;&#34;&#34;
        # neutrophils are attracted by MIP2

        neutrophil: NeutrophilState = state.neutrophil
        mip2: MIP2State = state.mip2
        grid: RectangularGrid = state.grid
        lung_tissue: np.ndarray = state.lung_tissue
        voxel_volume: float = state.voxel_volume

        # neutrophil has a non-zero probability of moving into non-air voxels
        nearby_voxels: Tuple[Voxel, ...] = tuple(grid.get_adjacent_voxels(voxel))
        weights = np.array(
            [
                0.0
                if lung_tissue[tuple(vxl)] == TissueType.AIR
                else activation_function(
                    x=mip2.grid[tuple(vxl)],
                    k_d=mip2.k_d,
                    h=self.time_step / 60,  # units: (min/step) / (min/hour)
                    volume=voxel_volume,
                    b=1,
                )
                + neutrophil.drift_bias
                for vxl in nearby_voxels
            ],
            dtype=np.float64,
        )

        voxel_movement_direction: Voxel = choose_voxel_by_prob(
            voxels=nearby_voxels, default_value=voxel, weights=weights
        )

        # get normalized direction vector
        dp_dt: np.ndarray = grid.get_voxel_center(voxel_movement_direction) - grid.get_voxel_center(
            voxel
        )
        norm = np.linalg.norm(dp_dt)
        if norm &gt; 0.0:
            dp_dt /= norm

        return cell[&#39;point&#39;] + dp_dt

    def update_status(self, state: State, neutrophil_cell: NeutrophilCellData) -&gt; None:
        &#34;&#34;&#34;
        Update the status of the cell, progressing between states after a certain number of ticks.

        Parameters
        ----------
        state : State
            global simulation state
        neutrophil_cell : NeutrophilCellData

        Returns
        -------
        nothing
        &#34;&#34;&#34;
        neutrophil: NeutrophilState = state.neutrophil

        if neutrophil_cell[&#39;status&#39;] in {PhagocyteStatus.NECROTIC, PhagocyteStatus.APOPTOTIC}:
            self.release_phagosome(state, neutrophil_cell)
            # releases iron &amp; dies later

        elif rg.uniform() &lt; neutrophil.apoptosis_probability:
            neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.APOPTOTIC

        elif neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE:
            if neutrophil_cell[&#39;status_iteration&#39;] &gt;= neutrophil.iter_to_change_state:
                neutrophil_cell[&#39;status_iteration&#39;] = 0
                neutrophil_cell[&#39;tnfa&#39;] = False
                neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.RESTING
                neutrophil_cell[&#39;state&#39;] = PhagocyteState.FREE
            else:
                neutrophil_cell[&#39;status_iteration&#39;] += 1

        elif neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVATING:
            if neutrophil_cell[&#39;status_iteration&#39;] &gt;= neutrophil.iter_to_change_state:
                neutrophil_cell[&#39;status_iteration&#39;] = 0
                neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.ACTIVE
            else:
                neutrophil_cell[&#39;status_iteration&#39;] += 1

    def recruit_neutrophils(self, state: State, space_volume: float, voxel_volume: float) -&gt; None:
        &#34;&#34;&#34;
        Recruit neutrophils based on MIP2 activation

        Parameters
        ----------
        state : State
            global simulation state
        space_volume : float
        voxel_volume : float

        Returns
        -------
        nothing
        &#34;&#34;&#34;
        from nlisim.modules.mip2 import MIP2State
        from nlisim.util import TissueType, activation_function

        neutrophil: NeutrophilState = state.neutrophil
        mip2: MIP2State = state.mip2
        lung_tissue = state.lung_tissue

        # 1. compute number of neutrophils to recruit
        num_live_neutrophils = len(neutrophil.cells.alive())
        avg = (
            neutrophil.recruitment_rate
            * neutrophil.n_frac
            * np.sum(mip2.grid)
            * (1 - num_live_neutrophils / neutrophil.max_neutrophils)
            / (mip2.k_d * space_volume)
        )
        number_to_recruit = np.random.poisson(avg) if avg &gt; 0 else 0
        if number_to_recruit &lt;= 0:
            return
        # 2. get voxels for new macrophages, based on activation
        activation_voxels = tuple(
            zip(
                *np.where(
                    np.logical_and(
                        activation_function(
                            x=mip2.grid,
                            k_d=mip2.k_d,
                            h=self.time_step / 60,  # units: (min/step) / (min/hour)
                            volume=voxel_volume,
                            b=neutrophil.rec_bias,
                        )
                        &lt; rg.uniform(size=mip2.grid.shape),
                        lung_tissue != TissueType.AIR,
                    )
                )
            )
        )

        dz_field: np.ndarray = state.grid.delta(axis=0)
        dy_field: np.ndarray = state.grid.delta(axis=1)
        dx_field: np.ndarray = state.grid.delta(axis=2)
        for coordinates in rg.choice(activation_voxels, size=number_to_recruit, replace=True):
            vox_z, vox_y, vox_x = coordinates
            # the x,y,z coordinates are in the centers of the grids
            z = state.grid.z[vox_z]
            y = state.grid.y[vox_y]
            x = state.grid.x[vox_x]
            dz = dz_field[vox_z, vox_y, vox_x]
            dy = dy_field[vox_z, vox_y, vox_x]
            dx = dx_field[vox_z, vox_y, vox_x]
            self.create_neutrophil(
                state=state,
                x=x + rg.uniform(-dx / 2, dx / 2),
                y=y + rg.uniform(-dy / 2, dy / 2),
                z=z + rg.uniform(-dz / 2, dz / 2),
            )

    @staticmethod
    def create_neutrophil(state: State, x: float, y: float, z: float, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Create a new neutrophil cell

        Parameters
        ----------
        state : State
            global simulation state
        x : float
        y : float
        z : float
            coordinates of created neutrophil
        kwargs
            parameters for neutrophil, will give

        Returns
        -------
        nothing
        &#34;&#34;&#34;
        neutrophil: NeutrophilState = state.neutrophil

        # use default value of iron pool if not present
        iron_pool = kwargs.get(&#39;iron_pool&#39;, 0.0)
        kwargs.pop(&#39;iron_pool&#39;, None)

        neutrophil.cells.append(
            NeutrophilCellData.create_cell(
                point=Point(x=x, y=y, z=z), iron_pool=iron_pool, **kwargs
            )
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nlisim.modules.neutrophil.cell_list_factory"><code class="name flex">
<span>def <span class="ident">cell_list_factory</span></span>(<span>self: <a title="nlisim.modules.neutrophil.NeutrophilState" href="#nlisim.modules.neutrophil.NeutrophilState">NeutrophilState</a>) ‑> <a title="nlisim.modules.neutrophil.NeutrophilCellList" href="#nlisim.modules.neutrophil.NeutrophilCellList">NeutrophilCellList</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_list_factory(self: &#39;NeutrophilState&#39;) -&gt; NeutrophilCellList:
    return NeutrophilCellList(grid=self.global_state.grid)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nlisim.modules.neutrophil.Neutrophil"><code class="flex name class">
<span>class <span class="ident">Neutrophil</span></span>
<span>(</span><span>config: <a title="nlisim.config.SimulationConfig" href="../config.html#nlisim.config.SimulationConfig">SimulationConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Neutrophil(PhagocyteModel):
    name = &#39;neutrophil&#39;
    StateClass = NeutrophilState

    def initialize(self, state: State):
        neutrophil: NeutrophilState = state.neutrophil
        voxel_volume = state.voxel_volume
        lung_tissue = state.lung_tissue

        neutrophil.init_num_neutrophils = self.config.getint(&#39;init_num_neutrophils&#39;)  # units: count

        neutrophil.time_to_change_state = self.config.getfloat(
            &#39;time_to_change_state&#39;
        )  # units: hours
        neutrophil.max_conidia = self.config.getint(
            &#39;max_conidia&#39;
        )  # (from phagocyte model) units: count

        neutrophil.recruitment_rate = self.config.getfloat(&#39;recruitment_rate&#39;)
        neutrophil.rec_bias = self.config.getfloat(&#39;rec_bias&#39;)
        neutrophil.max_neutrophils = self.config.getfloat(&#39;max_neutrophils&#39;)  # units: count
        neutrophil.n_frac = self.config.getfloat(&#39;n_frac&#39;)

        neutrophil.drift_bias = self.config.getfloat(&#39;drift_bias&#39;)
        neutrophil.n_move_rate_act = self.config.getfloat(&#39;n_move_rate_act&#39;)
        neutrophil.n_move_rate_rest = self.config.getfloat(&#39;n_move_rate_rest&#39;)

        neutrophil.pr_n_hyphae_param = self.config.getfloat(&#39;pr_n_hyphae_param&#39;)
        neutrophil.pr_n_phagocyte_param = self.config.getfloat(&#39;pr_n_phagocyte_param&#39;)

        neutrophil.half_life = self.config.getfloat(&#39;half_life&#39;)  # units: hours

        # computed values
        neutrophil.apoptosis_probability = -math.log(0.5) / (
            neutrophil.half_life * (60 / self.time_step)  # units: hours*(min/hour)/(min/step)=steps
        )  # units: probability
        neutrophil.iter_to_change_state = int(
            neutrophil.time_to_change_state * 60 / self.time_step
        )  # units: hours * (min/hour) / (min/step) = steps
        neutrophil.pr_n_hyphae = -math.expm1(
            -self.time_step / 60 / (voxel_volume * neutrophil.pr_n_hyphae_param)
        )  # units: probability
        neutrophil.pr_n_phagocyte = -math.expm1(
            -self.time_step / 60 / (voxel_volume * neutrophil.pr_n_phagocyte_param)
        )  # units: probability

        # place initial neutrophils
        locations = list(zip(*np.where(lung_tissue != TissueType.AIR)))
        dz_field: np.ndarray = state.grid.delta(axis=0)
        dy_field: np.ndarray = state.grid.delta(axis=1)
        dx_field: np.ndarray = state.grid.delta(axis=2)
        for vox_z, vox_y, vox_x in random.choices(locations, k=neutrophil.init_num_neutrophils):
            # the x,y,z coordinates are in the centers of the grids
            z = state.grid.z[vox_z]
            y = state.grid.y[vox_y]
            x = state.grid.x[vox_x]
            dz = dz_field[vox_z, vox_y, vox_x]
            dy = dy_field[vox_z, vox_y, vox_x]
            dx = dx_field[vox_z, vox_y, vox_x]

            self.create_neutrophil(
                state=state,
                x=x + rg.uniform(-dx / 2, dx / 2),
                y=y + rg.uniform(-dy / 2, dy / 2),
                z=z + rg.uniform(-dz / 2, dz / 2),
            )

        return state

    def advance(self, state: State, previous_time: float):
        &#34;&#34;&#34;Advance the state by a single time step.&#34;&#34;&#34;
        from nlisim.modules.afumigatus import (
            Afumigatus,
            AfumigatusCellData,
            AfumigatusCellStatus,
            AfumigatusState,
        )
        from nlisim.modules.iron import IronState
        from nlisim.modules.macrophage import MacrophageCellData, MacrophageState

        neutrophil: NeutrophilState = state.neutrophil
        macrophage: MacrophageState = state.macrophage
        afumigatus: AfumigatusState = state.afumigatus
        iron: IronState = state.iron
        grid: RectangularGrid = state.grid
        voxel_volume: float = state.voxel_volume
        space_volume: float = state.space_volume

        for neutrophil_cell_index in neutrophil.cells.alive():
            neutrophil_cell = neutrophil.cells[neutrophil_cell_index]
            neutrophil_cell_voxel: Voxel = grid.get_voxel(neutrophil_cell[&#39;point&#39;])

            self.update_status(state, neutrophil_cell)

            # ---------- interactions

            # dead and dying cells release iron
            if neutrophil_cell[&#39;status&#39;] in {
                PhagocyteStatus.NECROTIC,
                PhagocyteStatus.APOPTOTIC,
                PhagocyteStatus.DEAD,
            }:
                iron.grid[tuple(neutrophil_cell_voxel)] += neutrophil_cell[&#39;iron_pool&#39;]
                neutrophil_cell[&#39;iron_pool&#39;] = 0
                neutrophil_cell[&#39;dead&#39;] = True

            # interact with fungus
            if neutrophil_cell[&#39;state&#39;] == PhagocyteState.FREE and neutrophil_cell[
                &#39;status&#39;
            ] not in {
                PhagocyteStatus.APOPTOTIC,
                PhagocyteStatus.NECROTIC,
                PhagocyteStatus.DEAD,
            }:
                # get fungal cells in this voxel
                local_aspergillus = afumigatus.cells.get_cells_in_voxel(neutrophil_cell_voxel)
                for aspergillus_cell_index in local_aspergillus:
                    aspergillus_cell: AfumigatusCellData = afumigatus.cells[aspergillus_cell_index]
                    if aspergillus_cell[&#39;dead&#39;]:
                        continue

                    if aspergillus_cell[&#39;status&#39;] in {
                        AfumigatusCellStatus.HYPHAE,
                        AfumigatusCellStatus.GERM_TUBE,
                    }:
                        # possibly kill the fungal cell, extracellularly
                        if rg.uniform() &lt; neutrophil.pr_n_hyphae:
                            interact_with_aspergillus(
                                phagocyte_cell=neutrophil_cell,
                                aspergillus_cell=aspergillus_cell,
                                aspergillus_cell_index=aspergillus_cell_index,
                                phagocyte=neutrophil,
                            )
                            Afumigatus.kill_fungal_cell(
                                afumigatus=afumigatus,
                                afumigatus_cell=aspergillus_cell,
                                afumigatus_cell_index=aspergillus_cell_index,
                                iron=iron,
                                grid=grid,
                            )
                        else:
                            neutrophil_cell[&#39;state&#39;] = PhagocyteState.INTERACTING

                    elif aspergillus_cell[&#39;status&#39;] == AfumigatusCellStatus.SWELLING_CONIDIA:
                        if rg.uniform() &lt; neutrophil.pr_n_phagocyte:
                            interact_with_aspergillus(
                                phagocyte_cell=neutrophil_cell,
                                aspergillus_cell=aspergillus_cell,
                                aspergillus_cell_index=aspergillus_cell_index,
                                phagocyte=neutrophil,
                            )

            # interact with macrophages:
            # if we are apoptotic, give our iron and phagosome to a nearby
            # present macrophage (if empty)
            if neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.APOPTOTIC:
                local_macrophages = macrophage.cells.get_cells_in_voxel(neutrophil_cell_voxel)
                for macrophage_index in local_macrophages:
                    macrophage_cell: MacrophageCellData = macrophage.cells[macrophage_index]
                    macrophage_num_cells_in_phagosome = np.sum(macrophage_cell[&#39;phagosome&#39;] &gt;= 0)
                    # TODO: Henrique, why only if empty?
                    if macrophage_num_cells_in_phagosome == 0:
                        macrophage_cell[&#39;phagosome&#39;] = neutrophil_cell[&#39;phagosome&#39;]
                        macrophage_cell[&#39;iron_pool&#39;] += neutrophil_cell[&#39;iron_pool&#39;]
                        neutrophil_cell[&#39;iron_pool&#39;] = 0.0
                        neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.DEAD
                        macrophage_cell[&#39;status&#39;] = PhagocyteStatus.INACTIVE

            # Movement
            if neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE:
                max_move_step = neutrophil.n_move_rate_act * self.time_step
            else:
                max_move_step = neutrophil.n_move_rate_rest * self.time_step
            move_step: int = rg.poisson(max_move_step)
            # move the cell 1 µm, move_step number of times
            for _ in range(move_step):
                self.single_step_move(
                    state, neutrophil_cell, neutrophil_cell_index, neutrophil.cells
                )
            # TODO: understand the meaning of the parameter here: moving randomly n steps is
            #  different than moving n steps in a random direction. Which is it?

        # Recruitment
        self.recruit_neutrophils(state, space_volume, voxel_volume)

        return state

    def summary_stats(self, state: State) -&gt; Dict[str, Any]:
        neutrophil: NeutrophilState = state.neutrophil
        live_neutrophils = neutrophil.cells.alive()

        max_index = max(map(int, PhagocyteStatus))
        status_counts = np.bincount(
            np.fromiter(
                (
                    neutrophil.cells[neutrophil_cell_index][&#39;status&#39;]
                    for neutrophil_cell_index in live_neutrophils
                ),
                dtype=np.uint8,
            ),
            minlength=max_index + 1,
        )

        tnfa_active = int(
            np.sum(
                np.fromiter(
                    (
                        neutrophil.cells[neutrophil_cell_index][&#39;tnfa&#39;]
                        for neutrophil_cell_index in live_neutrophils
                    ),
                    dtype=bool,
                )
            )
        )

        return {
            &#39;count&#39;: len(neutrophil.cells.alive()),
            &#39;inactive&#39;: int(status_counts[PhagocyteStatus.INACTIVE]),
            &#39;inactivating&#39;: int(status_counts[PhagocyteStatus.INACTIVATING]),
            &#39;resting&#39;: int(status_counts[PhagocyteStatus.RESTING]),
            &#39;activating&#39;: int(status_counts[PhagocyteStatus.ACTIVATING]),
            &#39;active&#39;: int(status_counts[PhagocyteStatus.ACTIVE]),
            &#39;apoptotic&#39;: int(status_counts[PhagocyteStatus.APOPTOTIC]),
            &#39;necrotic&#39;: int(status_counts[PhagocyteStatus.NECROTIC]),
            &#39;interacting&#39;: int(status_counts[PhagocyteStatus.INTERACTING]),
            &#39;TNFa active&#39;: tnfa_active,
        }

    def visualization_data(self, state: State):
        return &#39;cells&#39;, state.neutrophil.cells

    def single_step_probabilistic_drift(
        self, state: State, cell: PhagocyteCellData, voxel: Voxel
    ) -&gt; Point:
        &#34;&#34;&#34;
        Calculate a 1µm movement of a neutrophil

        Parameters
        ----------
        state : State
            global simulation state
        cell : NeutrophilCellData
            a neutrophil cell
        voxel : Voxel
            current voxel position of the neutrophil

        Returns
        -------
        Point
            the new position of the neutrophil
        &#34;&#34;&#34;
        # neutrophils are attracted by MIP2

        neutrophil: NeutrophilState = state.neutrophil
        mip2: MIP2State = state.mip2
        grid: RectangularGrid = state.grid
        lung_tissue: np.ndarray = state.lung_tissue
        voxel_volume: float = state.voxel_volume

        # neutrophil has a non-zero probability of moving into non-air voxels
        nearby_voxels: Tuple[Voxel, ...] = tuple(grid.get_adjacent_voxels(voxel))
        weights = np.array(
            [
                0.0
                if lung_tissue[tuple(vxl)] == TissueType.AIR
                else activation_function(
                    x=mip2.grid[tuple(vxl)],
                    k_d=mip2.k_d,
                    h=self.time_step / 60,  # units: (min/step) / (min/hour)
                    volume=voxel_volume,
                    b=1,
                )
                + neutrophil.drift_bias
                for vxl in nearby_voxels
            ],
            dtype=np.float64,
        )

        voxel_movement_direction: Voxel = choose_voxel_by_prob(
            voxels=nearby_voxels, default_value=voxel, weights=weights
        )

        # get normalized direction vector
        dp_dt: np.ndarray = grid.get_voxel_center(voxel_movement_direction) - grid.get_voxel_center(
            voxel
        )
        norm = np.linalg.norm(dp_dt)
        if norm &gt; 0.0:
            dp_dt /= norm

        return cell[&#39;point&#39;] + dp_dt

    def update_status(self, state: State, neutrophil_cell: NeutrophilCellData) -&gt; None:
        &#34;&#34;&#34;
        Update the status of the cell, progressing between states after a certain number of ticks.

        Parameters
        ----------
        state : State
            global simulation state
        neutrophil_cell : NeutrophilCellData

        Returns
        -------
        nothing
        &#34;&#34;&#34;
        neutrophil: NeutrophilState = state.neutrophil

        if neutrophil_cell[&#39;status&#39;] in {PhagocyteStatus.NECROTIC, PhagocyteStatus.APOPTOTIC}:
            self.release_phagosome(state, neutrophil_cell)
            # releases iron &amp; dies later

        elif rg.uniform() &lt; neutrophil.apoptosis_probability:
            neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.APOPTOTIC

        elif neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE:
            if neutrophil_cell[&#39;status_iteration&#39;] &gt;= neutrophil.iter_to_change_state:
                neutrophil_cell[&#39;status_iteration&#39;] = 0
                neutrophil_cell[&#39;tnfa&#39;] = False
                neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.RESTING
                neutrophil_cell[&#39;state&#39;] = PhagocyteState.FREE
            else:
                neutrophil_cell[&#39;status_iteration&#39;] += 1

        elif neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVATING:
            if neutrophil_cell[&#39;status_iteration&#39;] &gt;= neutrophil.iter_to_change_state:
                neutrophil_cell[&#39;status_iteration&#39;] = 0
                neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.ACTIVE
            else:
                neutrophil_cell[&#39;status_iteration&#39;] += 1

    def recruit_neutrophils(self, state: State, space_volume: float, voxel_volume: float) -&gt; None:
        &#34;&#34;&#34;
        Recruit neutrophils based on MIP2 activation

        Parameters
        ----------
        state : State
            global simulation state
        space_volume : float
        voxel_volume : float

        Returns
        -------
        nothing
        &#34;&#34;&#34;
        from nlisim.modules.mip2 import MIP2State
        from nlisim.util import TissueType, activation_function

        neutrophil: NeutrophilState = state.neutrophil
        mip2: MIP2State = state.mip2
        lung_tissue = state.lung_tissue

        # 1. compute number of neutrophils to recruit
        num_live_neutrophils = len(neutrophil.cells.alive())
        avg = (
            neutrophil.recruitment_rate
            * neutrophil.n_frac
            * np.sum(mip2.grid)
            * (1 - num_live_neutrophils / neutrophil.max_neutrophils)
            / (mip2.k_d * space_volume)
        )
        number_to_recruit = np.random.poisson(avg) if avg &gt; 0 else 0
        if number_to_recruit &lt;= 0:
            return
        # 2. get voxels for new macrophages, based on activation
        activation_voxels = tuple(
            zip(
                *np.where(
                    np.logical_and(
                        activation_function(
                            x=mip2.grid,
                            k_d=mip2.k_d,
                            h=self.time_step / 60,  # units: (min/step) / (min/hour)
                            volume=voxel_volume,
                            b=neutrophil.rec_bias,
                        )
                        &lt; rg.uniform(size=mip2.grid.shape),
                        lung_tissue != TissueType.AIR,
                    )
                )
            )
        )

        dz_field: np.ndarray = state.grid.delta(axis=0)
        dy_field: np.ndarray = state.grid.delta(axis=1)
        dx_field: np.ndarray = state.grid.delta(axis=2)
        for coordinates in rg.choice(activation_voxels, size=number_to_recruit, replace=True):
            vox_z, vox_y, vox_x = coordinates
            # the x,y,z coordinates are in the centers of the grids
            z = state.grid.z[vox_z]
            y = state.grid.y[vox_y]
            x = state.grid.x[vox_x]
            dz = dz_field[vox_z, vox_y, vox_x]
            dy = dy_field[vox_z, vox_y, vox_x]
            dx = dx_field[vox_z, vox_y, vox_x]
            self.create_neutrophil(
                state=state,
                x=x + rg.uniform(-dx / 2, dx / 2),
                y=y + rg.uniform(-dy / 2, dy / 2),
                z=z + rg.uniform(-dz / 2, dz / 2),
            )

    @staticmethod
    def create_neutrophil(state: State, x: float, y: float, z: float, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Create a new neutrophil cell

        Parameters
        ----------
        state : State
            global simulation state
        x : float
        y : float
        z : float
            coordinates of created neutrophil
        kwargs
            parameters for neutrophil, will give

        Returns
        -------
        nothing
        &#34;&#34;&#34;
        neutrophil: NeutrophilState = state.neutrophil

        # use default value of iron pool if not present
        iron_pool = kwargs.get(&#39;iron_pool&#39;, 0.0)
        kwargs.pop(&#39;iron_pool&#39;, None)

        neutrophil.cells.append(
            NeutrophilCellData.create_cell(
                point=Point(x=x, y=y, z=z), iron_pool=iron_pool, **kwargs
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.modules.phagocyte.PhagocyteModel" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteModel">PhagocyteModel</a></li>
<li><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="nlisim.modules.neutrophil.Neutrophil.create_neutrophil"><code class="name flex">
<span>def <span class="ident">create_neutrophil</span></span>(<span>state: <a title="nlisim.state.State" href="../state.html#nlisim.state.State">State</a>, x: float, y: float, z: float, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new neutrophil cell</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>State</code></dt>
<dd>global simulation state</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>coordinates of created neutrophil</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>parameters for neutrophil, will give</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_neutrophil(state: State, x: float, y: float, z: float, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Create a new neutrophil cell

    Parameters
    ----------
    state : State
        global simulation state
    x : float
    y : float
    z : float
        coordinates of created neutrophil
    kwargs
        parameters for neutrophil, will give

    Returns
    -------
    nothing
    &#34;&#34;&#34;
    neutrophil: NeutrophilState = state.neutrophil

    # use default value of iron pool if not present
    iron_pool = kwargs.get(&#39;iron_pool&#39;, 0.0)
    kwargs.pop(&#39;iron_pool&#39;, None)

    neutrophil.cells.append(
        NeutrophilCellData.create_cell(
            point=Point(x=x, y=y, z=z), iron_pool=iron_pool, **kwargs
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nlisim.modules.neutrophil.Neutrophil.advance"><code class="name flex">
<span>def <span class="ident">advance</span></span>(<span>self, state: <a title="nlisim.state.State" href="../state.html#nlisim.state.State">State</a>, previous_time: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Advance the state by a single time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advance(self, state: State, previous_time: float):
    &#34;&#34;&#34;Advance the state by a single time step.&#34;&#34;&#34;
    from nlisim.modules.afumigatus import (
        Afumigatus,
        AfumigatusCellData,
        AfumigatusCellStatus,
        AfumigatusState,
    )
    from nlisim.modules.iron import IronState
    from nlisim.modules.macrophage import MacrophageCellData, MacrophageState

    neutrophil: NeutrophilState = state.neutrophil
    macrophage: MacrophageState = state.macrophage
    afumigatus: AfumigatusState = state.afumigatus
    iron: IronState = state.iron
    grid: RectangularGrid = state.grid
    voxel_volume: float = state.voxel_volume
    space_volume: float = state.space_volume

    for neutrophil_cell_index in neutrophil.cells.alive():
        neutrophil_cell = neutrophil.cells[neutrophil_cell_index]
        neutrophil_cell_voxel: Voxel = grid.get_voxel(neutrophil_cell[&#39;point&#39;])

        self.update_status(state, neutrophil_cell)

        # ---------- interactions

        # dead and dying cells release iron
        if neutrophil_cell[&#39;status&#39;] in {
            PhagocyteStatus.NECROTIC,
            PhagocyteStatus.APOPTOTIC,
            PhagocyteStatus.DEAD,
        }:
            iron.grid[tuple(neutrophil_cell_voxel)] += neutrophil_cell[&#39;iron_pool&#39;]
            neutrophil_cell[&#39;iron_pool&#39;] = 0
            neutrophil_cell[&#39;dead&#39;] = True

        # interact with fungus
        if neutrophil_cell[&#39;state&#39;] == PhagocyteState.FREE and neutrophil_cell[
            &#39;status&#39;
        ] not in {
            PhagocyteStatus.APOPTOTIC,
            PhagocyteStatus.NECROTIC,
            PhagocyteStatus.DEAD,
        }:
            # get fungal cells in this voxel
            local_aspergillus = afumigatus.cells.get_cells_in_voxel(neutrophil_cell_voxel)
            for aspergillus_cell_index in local_aspergillus:
                aspergillus_cell: AfumigatusCellData = afumigatus.cells[aspergillus_cell_index]
                if aspergillus_cell[&#39;dead&#39;]:
                    continue

                if aspergillus_cell[&#39;status&#39;] in {
                    AfumigatusCellStatus.HYPHAE,
                    AfumigatusCellStatus.GERM_TUBE,
                }:
                    # possibly kill the fungal cell, extracellularly
                    if rg.uniform() &lt; neutrophil.pr_n_hyphae:
                        interact_with_aspergillus(
                            phagocyte_cell=neutrophil_cell,
                            aspergillus_cell=aspergillus_cell,
                            aspergillus_cell_index=aspergillus_cell_index,
                            phagocyte=neutrophil,
                        )
                        Afumigatus.kill_fungal_cell(
                            afumigatus=afumigatus,
                            afumigatus_cell=aspergillus_cell,
                            afumigatus_cell_index=aspergillus_cell_index,
                            iron=iron,
                            grid=grid,
                        )
                    else:
                        neutrophil_cell[&#39;state&#39;] = PhagocyteState.INTERACTING

                elif aspergillus_cell[&#39;status&#39;] == AfumigatusCellStatus.SWELLING_CONIDIA:
                    if rg.uniform() &lt; neutrophil.pr_n_phagocyte:
                        interact_with_aspergillus(
                            phagocyte_cell=neutrophil_cell,
                            aspergillus_cell=aspergillus_cell,
                            aspergillus_cell_index=aspergillus_cell_index,
                            phagocyte=neutrophil,
                        )

        # interact with macrophages:
        # if we are apoptotic, give our iron and phagosome to a nearby
        # present macrophage (if empty)
        if neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.APOPTOTIC:
            local_macrophages = macrophage.cells.get_cells_in_voxel(neutrophil_cell_voxel)
            for macrophage_index in local_macrophages:
                macrophage_cell: MacrophageCellData = macrophage.cells[macrophage_index]
                macrophage_num_cells_in_phagosome = np.sum(macrophage_cell[&#39;phagosome&#39;] &gt;= 0)
                # TODO: Henrique, why only if empty?
                if macrophage_num_cells_in_phagosome == 0:
                    macrophage_cell[&#39;phagosome&#39;] = neutrophil_cell[&#39;phagosome&#39;]
                    macrophage_cell[&#39;iron_pool&#39;] += neutrophil_cell[&#39;iron_pool&#39;]
                    neutrophil_cell[&#39;iron_pool&#39;] = 0.0
                    neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.DEAD
                    macrophage_cell[&#39;status&#39;] = PhagocyteStatus.INACTIVE

        # Movement
        if neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE:
            max_move_step = neutrophil.n_move_rate_act * self.time_step
        else:
            max_move_step = neutrophil.n_move_rate_rest * self.time_step
        move_step: int = rg.poisson(max_move_step)
        # move the cell 1 µm, move_step number of times
        for _ in range(move_step):
            self.single_step_move(
                state, neutrophil_cell, neutrophil_cell_index, neutrophil.cells
            )
        # TODO: understand the meaning of the parameter here: moving randomly n steps is
        #  different than moving n steps in a random direction. Which is it?

    # Recruitment
    self.recruit_neutrophils(state, space_volume, voxel_volume)

    return state</code></pre>
</details>
</dd>
<dt id="nlisim.modules.neutrophil.Neutrophil.recruit_neutrophils"><code class="name flex">
<span>def <span class="ident">recruit_neutrophils</span></span>(<span>self, state: <a title="nlisim.state.State" href="../state.html#nlisim.state.State">State</a>, space_volume: float, voxel_volume: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Recruit neutrophils based on MIP2 activation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>State</code></dt>
<dd>global simulation state</dd>
<dt><strong><code>space_volume</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>voxel_volume</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recruit_neutrophils(self, state: State, space_volume: float, voxel_volume: float) -&gt; None:
    &#34;&#34;&#34;
    Recruit neutrophils based on MIP2 activation

    Parameters
    ----------
    state : State
        global simulation state
    space_volume : float
    voxel_volume : float

    Returns
    -------
    nothing
    &#34;&#34;&#34;
    from nlisim.modules.mip2 import MIP2State
    from nlisim.util import TissueType, activation_function

    neutrophil: NeutrophilState = state.neutrophil
    mip2: MIP2State = state.mip2
    lung_tissue = state.lung_tissue

    # 1. compute number of neutrophils to recruit
    num_live_neutrophils = len(neutrophil.cells.alive())
    avg = (
        neutrophil.recruitment_rate
        * neutrophil.n_frac
        * np.sum(mip2.grid)
        * (1 - num_live_neutrophils / neutrophil.max_neutrophils)
        / (mip2.k_d * space_volume)
    )
    number_to_recruit = np.random.poisson(avg) if avg &gt; 0 else 0
    if number_to_recruit &lt;= 0:
        return
    # 2. get voxels for new macrophages, based on activation
    activation_voxels = tuple(
        zip(
            *np.where(
                np.logical_and(
                    activation_function(
                        x=mip2.grid,
                        k_d=mip2.k_d,
                        h=self.time_step / 60,  # units: (min/step) / (min/hour)
                        volume=voxel_volume,
                        b=neutrophil.rec_bias,
                    )
                    &lt; rg.uniform(size=mip2.grid.shape),
                    lung_tissue != TissueType.AIR,
                )
            )
        )
    )

    dz_field: np.ndarray = state.grid.delta(axis=0)
    dy_field: np.ndarray = state.grid.delta(axis=1)
    dx_field: np.ndarray = state.grid.delta(axis=2)
    for coordinates in rg.choice(activation_voxels, size=number_to_recruit, replace=True):
        vox_z, vox_y, vox_x = coordinates
        # the x,y,z coordinates are in the centers of the grids
        z = state.grid.z[vox_z]
        y = state.grid.y[vox_y]
        x = state.grid.x[vox_x]
        dz = dz_field[vox_z, vox_y, vox_x]
        dy = dy_field[vox_z, vox_y, vox_x]
        dx = dx_field[vox_z, vox_y, vox_x]
        self.create_neutrophil(
            state=state,
            x=x + rg.uniform(-dx / 2, dx / 2),
            y=y + rg.uniform(-dy / 2, dy / 2),
            z=z + rg.uniform(-dz / 2, dz / 2),
        )</code></pre>
</details>
</dd>
<dt id="nlisim.modules.neutrophil.Neutrophil.single_step_probabilistic_drift"><code class="name flex">
<span>def <span class="ident">single_step_probabilistic_drift</span></span>(<span>self, state: <a title="nlisim.state.State" href="../state.html#nlisim.state.State">State</a>, cell: <a title="nlisim.modules.phagocyte.PhagocyteCellData" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteCellData">PhagocyteCellData</a>, voxel: <a title="nlisim.coordinates.Voxel" href="../coordinates.html#nlisim.coordinates.Voxel">Voxel</a>) ‑> <a title="nlisim.coordinates.Point" href="../coordinates.html#nlisim.coordinates.Point">Point</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a 1µm movement of a neutrophil</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>State</code></dt>
<dd>global simulation state</dd>
<dt><strong><code>cell</code></strong> :&ensp;<code><a title="nlisim.modules.neutrophil.NeutrophilCellData" href="#nlisim.modules.neutrophil.NeutrophilCellData">NeutrophilCellData</a></code></dt>
<dd>a neutrophil cell</dd>
<dt><strong><code>voxel</code></strong> :&ensp;<code>Voxel</code></dt>
<dd>current voxel position of the neutrophil</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Point</code></dt>
<dd>the new position of the neutrophil</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_step_probabilistic_drift(
    self, state: State, cell: PhagocyteCellData, voxel: Voxel
) -&gt; Point:
    &#34;&#34;&#34;
    Calculate a 1µm movement of a neutrophil

    Parameters
    ----------
    state : State
        global simulation state
    cell : NeutrophilCellData
        a neutrophil cell
    voxel : Voxel
        current voxel position of the neutrophil

    Returns
    -------
    Point
        the new position of the neutrophil
    &#34;&#34;&#34;
    # neutrophils are attracted by MIP2

    neutrophil: NeutrophilState = state.neutrophil
    mip2: MIP2State = state.mip2
    grid: RectangularGrid = state.grid
    lung_tissue: np.ndarray = state.lung_tissue
    voxel_volume: float = state.voxel_volume

    # neutrophil has a non-zero probability of moving into non-air voxels
    nearby_voxels: Tuple[Voxel, ...] = tuple(grid.get_adjacent_voxels(voxel))
    weights = np.array(
        [
            0.0
            if lung_tissue[tuple(vxl)] == TissueType.AIR
            else activation_function(
                x=mip2.grid[tuple(vxl)],
                k_d=mip2.k_d,
                h=self.time_step / 60,  # units: (min/step) / (min/hour)
                volume=voxel_volume,
                b=1,
            )
            + neutrophil.drift_bias
            for vxl in nearby_voxels
        ],
        dtype=np.float64,
    )

    voxel_movement_direction: Voxel = choose_voxel_by_prob(
        voxels=nearby_voxels, default_value=voxel, weights=weights
    )

    # get normalized direction vector
    dp_dt: np.ndarray = grid.get_voxel_center(voxel_movement_direction) - grid.get_voxel_center(
        voxel
    )
    norm = np.linalg.norm(dp_dt)
    if norm &gt; 0.0:
        dp_dt /= norm

    return cell[&#39;point&#39;] + dp_dt</code></pre>
</details>
</dd>
<dt id="nlisim.modules.neutrophil.Neutrophil.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, state: <a title="nlisim.state.State" href="../state.html#nlisim.state.State">State</a>, neutrophil_cell: <a title="nlisim.modules.neutrophil.NeutrophilCellData" href="#nlisim.modules.neutrophil.NeutrophilCellData">NeutrophilCellData</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of the cell, progressing between states after a certain number of ticks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>State</code></dt>
<dd>global simulation state</dd>
<dt><strong><code>neutrophil_cell</code></strong> :&ensp;<code><a title="nlisim.modules.neutrophil.NeutrophilCellData" href="#nlisim.modules.neutrophil.NeutrophilCellData">NeutrophilCellData</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, state: State, neutrophil_cell: NeutrophilCellData) -&gt; None:
    &#34;&#34;&#34;
    Update the status of the cell, progressing between states after a certain number of ticks.

    Parameters
    ----------
    state : State
        global simulation state
    neutrophil_cell : NeutrophilCellData

    Returns
    -------
    nothing
    &#34;&#34;&#34;
    neutrophil: NeutrophilState = state.neutrophil

    if neutrophil_cell[&#39;status&#39;] in {PhagocyteStatus.NECROTIC, PhagocyteStatus.APOPTOTIC}:
        self.release_phagosome(state, neutrophil_cell)
        # releases iron &amp; dies later

    elif rg.uniform() &lt; neutrophil.apoptosis_probability:
        neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.APOPTOTIC

    elif neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE:
        if neutrophil_cell[&#39;status_iteration&#39;] &gt;= neutrophil.iter_to_change_state:
            neutrophil_cell[&#39;status_iteration&#39;] = 0
            neutrophil_cell[&#39;tnfa&#39;] = False
            neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.RESTING
            neutrophil_cell[&#39;state&#39;] = PhagocyteState.FREE
        else:
            neutrophil_cell[&#39;status_iteration&#39;] += 1

    elif neutrophil_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVATING:
        if neutrophil_cell[&#39;status_iteration&#39;] &gt;= neutrophil.iter_to_change_state:
            neutrophil_cell[&#39;status_iteration&#39;] = 0
            neutrophil_cell[&#39;status&#39;] = PhagocyteStatus.ACTIVE
        else:
            neutrophil_cell[&#39;status_iteration&#39;] += 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.modules.phagocyte.PhagocyteModel" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteModel">PhagocyteModel</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.StateClass" href="../module.html#nlisim.module.ModuleModel.StateClass">StateClass</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.construct" href="../module.html#nlisim.module.ModuleModel.construct">construct</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.finalize" href="../module.html#nlisim.module.ModuleModel.finalize">finalize</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.initialize" href="../module.html#nlisim.module.ModuleModel.initialize">initialize</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.release_phagosome" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteModel.release_phagosome">release_phagosome</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.section" href="../module.html#nlisim.module.ModuleModel.section">section</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.single_step_move" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteModel.single_step_move">single_step_move</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.summary_stats" href="../module.html#nlisim.module.ModuleModel.summary_stats">summary_stats</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.time_step" href="../module.html#nlisim.module.ModuleModel.time_step">time_step</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModel.visualization_data" href="../module.html#nlisim.module.ModuleModel.visualization_data">visualization_data</a></code></li>
</ul>
</li>
<li><code><b><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleModel.name" href="../module.html#nlisim.module.ModuleModel.name">name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilCellData"><code class="flex name class">
<span>class <span class="ident">NeutrophilCellData</span></span>
<span>(</span><span>arg: Union[int, Iterable[ForwardRef('CellData')]], initialize: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A low-level data contain for an array cells.</p>
<p>This class is a subtype of
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html">numpy.recarray</a>
containing the lowest level representation of a list of "cells" in a
simulation.
The underlying data format of this type are identical to a
simple array of C structures with the fields given in the static "dtype"
variable.</p>
<p>The base class contains only a single coordinate representing the location
of the center of the cell.
Most implementations will want to override this
class to append more fields.
Subclasses must also override the base
implementation of <code>create_cell</code> to construct a single record containing
the additional fields.</p>
<p>For example, the following derived class adds an addition floating point value
associated with each cell.</p>
<pre><code class="language-python">class DerivedCell(CellData):
    FIELDS = CellData.FIELDS + [
        ('iron_content', 'f8')
    ]

    dtype = np.dtype(CellData.FIELDS, align=True)

    @classmethod
    def create_cell_tuple(cls, iron_content=0, **kwargs) -&gt; Tuple:
        return CellData.create_cell_tuple(**kwargs) + (iron_content,)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NeutrophilCellData(PhagocyteCellData):
    NEUTROPHIL_FIELDS: CellFields = [
        (&#39;status&#39;, np.uint8),
        (&#39;state&#39;, np.uint8),
        (&#39;iron_pool&#39;, np.float64),  # units: atto-mol
        (&#39;tnfa&#39;, bool),
        (&#39;status_iteration&#39;, np.uint),
    ]

    dtype = np.dtype(
        CellData.FIELDS + PhagocyteCellData.PHAGOCYTE_FIELDS + NEUTROPHIL_FIELDS, align=True
    )  # type: ignore

    @classmethod
    def create_cell_tuple(
        cls,
        **kwargs,
    ) -&gt; Tuple:
        initializer = {
            &#39;status&#39;: kwargs.get(&#39;status&#39;, PhagocyteStatus.RESTING),
            &#39;state&#39;: kwargs.get(&#39;state&#39;, PhagocyteState.FREE),
            &#39;iron_pool&#39;: kwargs.get(&#39;iron_pool&#39;, 0.0),
            &#39;tnfa&#39;: kwargs.get(&#39;tnfa&#39;, False),
            &#39;status_iteration&#39;: kwargs.get(&#39;status_iteration&#39;, 0),
        }

        # ensure that these come in the correct order
        return PhagocyteCellData.create_cell_tuple(**kwargs) + tuple(
            [initializer[key] for key, *_ in NeutrophilCellData.NEUTROPHIL_FIELDS]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.modules.phagocyte.PhagocyteCellData" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteCellData">PhagocyteCellData</a></li>
<li><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></li>
<li>numpy.ndarray</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.neutrophil.NeutrophilCellData.NEUTROPHIL_FIELDS"><code class="name">var <span class="ident">NEUTROPHIL_FIELDS</span> : List[Union[Tuple[str, numpy.dtype], Tuple[str, Type[Any]], Tuple[str, Type[Any], int], Tuple[str, str], Tuple[str, str, int]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.modules.phagocyte.PhagocyteCellData" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteCellData">PhagocyteCellData</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.modules.phagocyte.PhagocyteCellData.FIELDS" href="../cell.html#nlisim.cell.CellData.FIELDS">FIELDS</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteCellData.create_cell" href="../cell.html#nlisim.cell.CellData.create_cell">create_cell</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteCellData.create_cell_tuple" href="../cell.html#nlisim.cell.CellData.create_cell_tuple">create_cell_tuple</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteCellData.point_mask" href="../cell.html#nlisim.cell.CellData.point_mask">point_mask</a></code></li>
</ul>
</li>
<li><code><b><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellData.dtype" href="../cell.html#nlisim.cell.CellData.dtype">dtype</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilCellList"><code class="flex name class">
<span>class <span class="ident">NeutrophilCellList</span></span>
<span>(</span><span>*, grid: <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a>, max_cells: int = 1000000, cell_data: <a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>A python view on top of a CellData array.</p>
<p>This class represents a pythonic interface to the data contained in a
CellData array.
Because the CellData class is a low-level object, it does
not allow dynamically appending new elements.
Objects of this class get
around this limitation by pre-allocating a large block of memory that is
transparently available.
User-facing properties are sliced to make it
appear as if the extra data is not there.</p>
<p>Subclassed types are expected to set the <code>CellDataClass</code> attribute to
a subclass of <code>CellData</code>.
This provides information about the underlying
low-level array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>simulation.grid.RectangularGrid</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_cells</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>cells</code></strong> :&ensp;<code>simulation.cell.CellData</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Method generated by attrs for class NeutrophilCellList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NeutrophilCellList(CellList):
    CellDataClass = NeutrophilCellData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.neutrophil.NeutrophilCellList.grid"><code class="name">var <span class="ident">grid</span> : <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilCellList.max_cells"><code class="name">var <span class="ident">max_cells</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellList.CellDataClass" href="../cell.html#nlisim.cell.CellList.CellDataClass">CellDataClass</a></code></li>
<li><code><a title="nlisim.cell.CellList.alive" href="../cell.html#nlisim.cell.CellList.alive">alive</a></code></li>
<li><code><a title="nlisim.cell.CellList.append" href="../cell.html#nlisim.cell.CellList.append">append</a></code></li>
<li><code><a title="nlisim.cell.CellList.cell_data" href="../cell.html#nlisim.cell.CellList.cell_data">cell_data</a></code></li>
<li><code><a title="nlisim.cell.CellList.create_from_seed" href="../cell.html#nlisim.cell.CellList.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="nlisim.cell.CellList.extend" href="../cell.html#nlisim.cell.CellList.extend">extend</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_cells_in_voxel" href="../cell.html#nlisim.cell.CellList.get_cells_in_voxel">get_cells_in_voxel</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_neighboring_cells" href="../cell.html#nlisim.cell.CellList.get_neighboring_cells">get_neighboring_cells</a></code></li>
<li><code><a title="nlisim.cell.CellList.load" href="../cell.html#nlisim.cell.CellList.load">load</a></code></li>
<li><code><a title="nlisim.cell.CellList.save" href="../cell.html#nlisim.cell.CellList.save">save</a></code></li>
<li><code><a title="nlisim.cell.CellList.update_voxel_index" href="../cell.html#nlisim.cell.CellList.update_voxel_index">update_voxel_index</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState"><code class="flex name class">
<span>class <span class="ident">NeutrophilState</span></span>
<span>(</span><span>*, global_state: State, cells: <a title="nlisim.modules.neutrophil.NeutrophilCellList" href="#nlisim.modules.neutrophil.NeutrophilCellList">NeutrophilCellList</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>Base type intended to store the state for simulation modules.</p>
<p>This class contains serialization support for basic types (float, int, str,
bool) and numpy arrays of those types.
Modules containing more complicated
state must override the serialization mechanism with custom behavior.</p>
<p>Method generated by attrs for class NeutrophilState.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NeutrophilState(PhagocyteModuleState):
    cells: NeutrophilCellList = attrib(default=attr.Factory(cell_list_factory, takes_self=True))
    half_life: float  # units: hours
    apoptosis_probability: float  # units: probability
    time_to_change_state: float  # units: hours
    iter_to_change_state: int  # units: steps
    pr_n_hyphae: float  # units: probability
    pr_n_hyphae_param: float
    pr_n_phagocyte: float  # units: probability
    pr_n_phagocyte_param: float
    recruitment_rate: float
    rec_bias: float
    max_neutrophils: float  # TODO: 0.5?
    n_frac: float
    drift_bias: float
    n_move_rate_act: float  # units: µm
    n_move_rate_rest: float  # units: µm
    init_num_neutrophils: int  # units: count</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.modules.phagocyte.PhagocyteModuleState" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteModuleState">PhagocyteModuleState</a></li>
<li><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.neutrophil.NeutrophilState.apoptosis_probability"><code class="name">var <span class="ident">apoptosis_probability</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.cells"><code class="name">var <span class="ident">cells</span> : <a title="nlisim.modules.neutrophil.NeutrophilCellList" href="#nlisim.modules.neutrophil.NeutrophilCellList">NeutrophilCellList</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.drift_bias"><code class="name">var <span class="ident">drift_bias</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.half_life"><code class="name">var <span class="ident">half_life</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.init_num_neutrophils"><code class="name">var <span class="ident">init_num_neutrophils</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.iter_to_change_state"><code class="name">var <span class="ident">iter_to_change_state</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.max_neutrophils"><code class="name">var <span class="ident">max_neutrophils</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.n_frac"><code class="name">var <span class="ident">n_frac</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.n_move_rate_act"><code class="name">var <span class="ident">n_move_rate_act</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.n_move_rate_rest"><code class="name">var <span class="ident">n_move_rate_rest</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.pr_n_hyphae"><code class="name">var <span class="ident">pr_n_hyphae</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.pr_n_hyphae_param"><code class="name">var <span class="ident">pr_n_hyphae_param</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.pr_n_phagocyte"><code class="name">var <span class="ident">pr_n_phagocyte</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.pr_n_phagocyte_param"><code class="name">var <span class="ident">pr_n_phagocyte_param</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.rec_bias"><code class="name">var <span class="ident">rec_bias</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.recruitment_rate"><code class="name">var <span class="ident">recruitment_rate</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.neutrophil.NeutrophilState.time_to_change_state"><code class="name">var <span class="ident">time_to_change_state</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.modules.phagocyte.PhagocyteModuleState" href="phagocyte.html#nlisim.modules.phagocyte.PhagocyteModuleState">PhagocyteModuleState</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModuleState.load_attribute" href="../module.html#nlisim.module.ModuleState.load_attribute">load_attribute</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModuleState.load_state" href="../module.html#nlisim.module.ModuleState.load_state">load_state</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModuleState.save_attribute" href="../module.html#nlisim.module.ModuleState.save_attribute">save_attribute</a></code></li>
<li><code><a title="nlisim.modules.phagocyte.PhagocyteModuleState.save_state" href="../module.html#nlisim.module.ModuleState.save_state">save_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nlisim.modules" href="index.html">nlisim.modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nlisim.modules.neutrophil.cell_list_factory" href="#nlisim.modules.neutrophil.cell_list_factory">cell_list_factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nlisim.modules.neutrophil.Neutrophil" href="#nlisim.modules.neutrophil.Neutrophil">Neutrophil</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.neutrophil.Neutrophil.advance" href="#nlisim.modules.neutrophil.Neutrophil.advance">advance</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.Neutrophil.create_neutrophil" href="#nlisim.modules.neutrophil.Neutrophil.create_neutrophil">create_neutrophil</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.Neutrophil.recruit_neutrophils" href="#nlisim.modules.neutrophil.Neutrophil.recruit_neutrophils">recruit_neutrophils</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.Neutrophil.single_step_probabilistic_drift" href="#nlisim.modules.neutrophil.Neutrophil.single_step_probabilistic_drift">single_step_probabilistic_drift</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.Neutrophil.update_status" href="#nlisim.modules.neutrophil.Neutrophil.update_status">update_status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.neutrophil.NeutrophilCellData" href="#nlisim.modules.neutrophil.NeutrophilCellData">NeutrophilCellData</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.neutrophil.NeutrophilCellData.NEUTROPHIL_FIELDS" href="#nlisim.modules.neutrophil.NeutrophilCellData.NEUTROPHIL_FIELDS">NEUTROPHIL_FIELDS</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.neutrophil.NeutrophilCellList" href="#nlisim.modules.neutrophil.NeutrophilCellList">NeutrophilCellList</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.neutrophil.NeutrophilCellList.grid" href="#nlisim.modules.neutrophil.NeutrophilCellList.grid">grid</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilCellList.max_cells" href="#nlisim.modules.neutrophil.NeutrophilCellList.max_cells">max_cells</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.neutrophil.NeutrophilState" href="#nlisim.modules.neutrophil.NeutrophilState">NeutrophilState</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.apoptosis_probability" href="#nlisim.modules.neutrophil.NeutrophilState.apoptosis_probability">apoptosis_probability</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.cells" href="#nlisim.modules.neutrophil.NeutrophilState.cells">cells</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.drift_bias" href="#nlisim.modules.neutrophil.NeutrophilState.drift_bias">drift_bias</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.half_life" href="#nlisim.modules.neutrophil.NeutrophilState.half_life">half_life</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.init_num_neutrophils" href="#nlisim.modules.neutrophil.NeutrophilState.init_num_neutrophils">init_num_neutrophils</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.iter_to_change_state" href="#nlisim.modules.neutrophil.NeutrophilState.iter_to_change_state">iter_to_change_state</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.max_neutrophils" href="#nlisim.modules.neutrophil.NeutrophilState.max_neutrophils">max_neutrophils</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.n_frac" href="#nlisim.modules.neutrophil.NeutrophilState.n_frac">n_frac</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.n_move_rate_act" href="#nlisim.modules.neutrophil.NeutrophilState.n_move_rate_act">n_move_rate_act</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.n_move_rate_rest" href="#nlisim.modules.neutrophil.NeutrophilState.n_move_rate_rest">n_move_rate_rest</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.pr_n_hyphae" href="#nlisim.modules.neutrophil.NeutrophilState.pr_n_hyphae">pr_n_hyphae</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.pr_n_hyphae_param" href="#nlisim.modules.neutrophil.NeutrophilState.pr_n_hyphae_param">pr_n_hyphae_param</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.pr_n_phagocyte" href="#nlisim.modules.neutrophil.NeutrophilState.pr_n_phagocyte">pr_n_phagocyte</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.pr_n_phagocyte_param" href="#nlisim.modules.neutrophil.NeutrophilState.pr_n_phagocyte_param">pr_n_phagocyte_param</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.rec_bias" href="#nlisim.modules.neutrophil.NeutrophilState.rec_bias">rec_bias</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.recruitment_rate" href="#nlisim.modules.neutrophil.NeutrophilState.recruitment_rate">recruitment_rate</a></code></li>
<li><code><a title="nlisim.modules.neutrophil.NeutrophilState.time_to_change_state" href="#nlisim.modules.neutrophil.NeutrophilState.time_to_change_state">time_to_change_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>