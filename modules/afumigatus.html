<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>nlisim.modules.afumigatus API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nlisim.modules.afumigatus</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections.abc import MutableMapping
from enum import IntEnum
from typing import Iterable, Iterator, List, Optional, Union

import attr
from h5py import Group
import numpy as np
from scipy.sparse import coo_matrix, dok_matrix as sparse_matrix
from scipy.spatial.transform import Rotation

from nlisim.cell import CellData, CellList, CellType
from nlisim.coordinates import Point
from nlisim.grid import RectangularGrid
from nlisim.module import ModuleModel, ModuleState
from nlisim.random import rg
from nlisim.state import State, get_class_path


class AfumigatusCellData(CellData):
    GROWTH_SCALE_FACTOR = 0.02  # from original code
    BOOLEAN_NETWORK_LENGTH = 23

    class Status(IntEnum):
        RESTING_CONIDIA = 0
        SWELLING_CONIDIA = 1
        GERMTUBE = 5
        HYPHAE = 2
        DYING = 3
        DEAD = 4
        INTERNALIZED = 6

    class State(IntEnum):
        FREE = 0
        INTERNALIZING = 1
        RELEASING = 2

    AFUMIGATUS_FIELDS = [
        (&#39;boolean_network&#39;, &#39;b1&#39;, BOOLEAN_NETWORK_LENGTH),
        (&#39;growth&#39;, Point.dtype),
        (&#39;growable&#39;, &#39;b1&#39;),
        (&#39;switched&#39;, &#39;b1&#39;),
        (&#39;branchable&#39;, &#39;b1&#39;),
        (&#39;state&#39;, &#39;u1&#39;),
        (&#39;status&#39;, &#39;u1&#39;),
        (&#39;iron_pool&#39;, &#39;f8&#39;),
        (&#39;iron&#39;, &#39;b1&#39;),
        (&#39;iteration&#39;, &#39;i4&#39;),
        (&#39;health&#39;, &#39;f8&#39;),
        (&#39;mobile&#39;, &#39;b1&#39;),
    ]

    FIELDS = CellData.FIELDS + AFUMIGATUS_FIELDS
    dtype = np.dtype(FIELDS, align=True)  # type: ignore

    @classmethod
    def create_cell_tuple(
        cls,
        *,
        iron_pool: float = 0,
        status: Status = Status.RESTING_CONIDIA,
        state: State = State.FREE,
        **kwargs,
    ) -&gt; np.record:

        growth = cls.GROWTH_SCALE_FACTOR * Point.from_array(2 * rg.random(3) - 1)
        network = cls.initial_boolean_network()
        growable = True
        switched = False
        branchable = False
        iteration = 0
        iron = False
        health = 100
        mobile = True

        return CellData.create_cell_tuple(**kwargs) + (
            network,
            growth,
            growable,
            switched,
            branchable,
            state,
            status,
            iron_pool,
            iron,
            iteration,
            health,
            mobile,
        )

    @classmethod
    def initial_boolean_network(cls) -&gt; np.ndarray:
        return np.asarray(
            [
                True,
                False,
                True,
                False,
                True,
                True,
                True,
                True,
                True,
                False,
                False,
                False,
                True,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
            ]
        )


@attr.s(auto_attribs=True, kw_only=True, frozen=True)
class AfumigatusCell(MutableMapping):
    tree: &#39;AfumigatusCellTreeList&#39;
    index: int = attr.ib()

    @index.validator
    def _validate_index(self, attribute, value):
        if value &gt;= len(self.tree):
            raise ValueError(&#39;Invalid cell index&#39;)

    def __attrs_post_init__(self):
        if self.index &lt; 0:
            object.__setattr__(self, &#39;index&#39;, self.index + len(self.tree))

    @property
    def record(self) -&gt; CellType:
        return self.tree.cells[self.index]

    @property
    def parent(self) -&gt; Optional[&#39;AfumigatusCell&#39;]:
        indices = self.tree.adjacency[:, self.index].nonzero()[0]
        if len(indices) == 1:
            return None
        if len(indices) == 2 and indices[0] == self.index:
            index = indices[0]
            if index == self.index:
                index = indices[1]
            return self.__class__(tree=self.tree, index=index)

        raise Exception(f&#39;Invalid adjacency matrix at index {self.index}&#39;)

    @property
    def children(self) -&gt; Iterator[&#39;AfumigatusCell&#39;]:
        indices = self.tree.adjacency[self.index].nonzero()[1]
        for index in indices:
            if index != self.index:
                yield self.__class__(tree=self.tree, index=index)

    def add_child(self, cell: Union[CellType, &#39;AfumigatusCell&#39;]):
        if isinstance(cell, AfumigatusCell):
            cell = cell.record
        self.tree.append(cell, parent=self.index)

    def kill(self) -&gt; List[&#39;AfumigatusCell&#39;]:
        &#34;&#34;&#34;Mark the current cell as dead and remove it from the tree.&#34;&#34;&#34;
        return self.tree.kill(self.index)

    def __getitem__(self, key):
        return self.record.__getitem__(key)

    def __setitem__(self, key, value):
        self.tree.cell_data[key][self.index] = value

    def __delitem__(self, key):
        return self.record.__delitem__(key)

    def __iter__(self):
        for key in self.record.dtype.fields.keys():
            yield key

    def __contains__(self, key):
        return key in self.record.dtype.fields

    def __len__(self):
        return len(self.record)


@attr.s(kw_only=True, frozen=True, repr=False)
class AfumigatusCellList(CellList):
    CellDataClass = AfumigatusCellData


@attr.s(kw_only=True, frozen=True, repr=False)
class AfumigatusCellTreeList(object):
    cells: CellList = attr.ib()
    _adjacency: sparse_matrix = attr.ib()

    @_adjacency.default
    def __set_default_adjacency(self):
        return sparse_matrix((0, 0))

    def __attrs_post_init__(self):
        cells = self.cells
        adjacency = self._adjacency

        object.__setattr__(self, &#39;_adjacency&#39;, sparse_matrix((cells.max_cells, cells.max_cells)))

        if len(cells) &gt; 0:
            for key, value in adjacency.items():
                self._adjacency[key] = value

    @property
    def adjacency(self) -&gt; sparse_matrix:
        return self._adjacency[: len(self), : len(self)]

    @property
    def roots(self) -&gt; List[CellType]:
        # This is linear in the number of nodes... might need to be optimized.
        roots = []
        for i in range(len(self)):
            cell = self[i]
            if not cell[&#39;dead&#39;] and cell.parent is None:
                roots.append(cell)
        return roots

    @property
    def cell_data(self) -&gt; AfumigatusCellData:
        return self.cells.cell_data

    @property
    def max_cells(self) -&gt; int:
        return self.cells.max_cells

    @property
    def grid(self) -&gt; RectangularGrid:
        return self.cells.grid

    @classmethod
    def random_branch_direction(cls, growth: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Rotate by a random 45 degree angle from the axis of growth.&#34;&#34;&#34;
        growth = Point.from_array(growth)

        # get a random vector orthogonal to the growth vector
        axis = Point.from_array(np.cross(growth, rg.standard_normal(3)))
        axis = (np.pi / 4) * axis / axis.norm()

        # rotate the growth vector 45 degrees along the random axis
        rotation = Rotation.from_rotvec(axis)
        return rotation.apply(growth)

    @classmethod
    def create_from_seed(cls, grid, **kwargs) -&gt; &#39;AfumigatusCellTreeList&#39;:
        cells = AfumigatusCellList.create_from_seed(grid, **kwargs)
        adjacency = sparse_matrix((1, 1))
        adjacency[0, 0] = 1

        return cls(cells=cells, adjacency=adjacency)

    def __len__(self):
        return len(self.cells)

    def __getitem__(self, index: int) -&gt; AfumigatusCell:
        if isinstance(index, str):
            raise TypeError(&#39;Expected an integer index, did you mean `tree.cell_data[key]`?&#39;)
        return AfumigatusCell(tree=self, index=index)

    def append(self, cell, parent=None):
        index = len(self)
        self.cells.append(cell)
        self._adjacency[index, index] = 1

        if parent is not None:
            self._adjacency[parent, index] = 1
            iron_pool = self.cells[parent][&#39;iron_pool&#39;] / 2
            self.cells[parent][&#39;iron_pool&#39;] = self.cells[-1][&#39;iron_pool&#39;] = iron_pool

    def extend(self, cells: CellData, parents: Iterable[Union[int, None]] = None) -&gt; None:
        if parents is None:
            parents = [None] * len(cells)

        for cell, parent in zip(cells, parents):
            self.append(cell, parent)

    def kill(self, index: int) -&gt; List[AfumigatusCell]:
        &#34;&#34;&#34;Kill the cell at the given index and remove it from the tree.

        This method will return a list of cells which were children of the
        killed cell.  These children will be the roots of newly formed trees.
        &#34;&#34;&#34;
        self.cell_data[index][&#39;dead&#39;] = True
        roots = []
        for i in range(len(self)):
            if i == index:
                continue
            if self._adjacency.pop((i, index), None):
                self[i][&#39;growable&#39;] = True
            if self._adjacency.pop((index, i), None):
                roots.append(self[i])
        return roots

    def is_growable(self) -&gt; np.ndarray:
        cells = self.cells.cell_data
        return self.cells.alive(
            cells[&#39;growable&#39;]
            &amp; cells.point_mask(cells[&#39;point&#39;] + cells[&#39;growth&#39;], self.grid)
            &amp; (cells[&#39;status&#39;] == AfumigatusCellData.Status.HYPHAE)
        )

    def is_branchable(self, branch_probability: float) -&gt; np.ndarray:
        cells = self.cells.cell_data
        return self.cells.alive(
            cells[&#39;branchable&#39;]
            &amp; (rg.random(cells.shape) &lt; branch_probability)
            &amp; (cells[&#39;status&#39;] == AfumigatusCellData.Status.HYPHAE)
        )

    def absorb_iron(self):
        &#34;&#34;&#34;Absorb iron from the environment.

        This is a dummy method for the visualization testing purpose.
        &#34;&#34;&#34;
        #  TODO: implement a real iron uptake model
        cells = self.cells.cell_data
        iron = rg.random(len(self.cells))
        cells[&#39;iron_pool&#39;] = np.add(cells[&#39;iron_pool&#39;], iron)

    def age(self):
        &#34;&#34;&#34;Add 1 to iteration each time step.&#34;&#34;&#34;
        cells = self.cells.cell_data
        cells[&#39;iteration&#39;] += 1

    def alive(self):
        return self.cells.alive()

    def elongate(self):
        cells = self.cell_data
        mask = self.is_growable()
        if len(mask) == 0:
            return

        cells[&#39;growable&#39;][mask] = False
        cells[&#39;branchable&#39;][mask] = True

        children = AfumigatusCellData(len(mask), initialize=True)
        children[&#39;point&#39;] = cells[&#39;point&#39;][mask] + cells[&#39;growth&#39;][mask]
        children[&#39;growth&#39;] = cells[&#39;growth&#39;][mask]

        self.extend(children, parents=mask)

    def branch(self, branch_probability: float):
        cells = self.cell_data
        indices = self.is_branchable(branch_probability)
        if len(indices) == 0:
            return

        children = AfumigatusCellData(len(indices), initialize=True)
        children[&#39;growth&#39;] = cells[indices][&#39;growth&#39;]
        children[&#39;growth&#39;] = np.apply_along_axis(
            self.random_branch_direction, 1, children[&#39;growth&#39;]
        )

        children[&#39;point&#39;] = cells[&#39;point&#39;][indices] + children[&#39;growth&#39;]

        # filter out children lying outside of the domain
        indices = indices[cells.point_mask(children[&#39;point&#39;], self.grid)]
        if len(indices) == 0:
            return

        # set properties
        cells[&#39;branchable&#39;][indices] = False
        children[&#39;growable&#39;] = True
        children[&#39;branchable&#39;] = False

        self.extend(children, parents=indices)

    def save(self, group: Group, name: str, metadata: dict) -&gt; Group:
        composite_group = group.create_group(name)
        composite_group.attrs[&#39;class&#39;] = get_class_path(self)
        composite_group.attrs[&#39;type&#39;] = &#39;CellTree&#39;
        self.cells.save(composite_group, &#39;cells&#39;, metadata)

        sp = self.adjacency.tocoo()
        composite_group.create_dataset(name=&#39;row&#39;, data=sp.row)
        composite_group.create_dataset(name=&#39;col&#39;, data=sp.col)
        composite_group.create_dataset(name=&#39;value&#39;, data=sp.data)
        return composite_group

    @classmethod
    def load(
        cls, global_state: State, group: Group, name: str, metadata: dict
    ) -&gt; &#39;AfumigatusCellTreeList&#39;:
        composite_dataset = group[name]
        cells = AfumigatusCellList.load(global_state, composite_dataset, &#39;cells&#39;, metadata)

        adjacency = coo_matrix(
            (
                composite_dataset[&#39;value&#39;],
                (composite_dataset[&#39;row&#39;], composite_dataset[&#39;col&#39;]),
            ),
            shape=(cells.max_cells, cells.max_cells),
        ).todok()

        return cls(cells=cells, adjacency=adjacency)


def cell_list_factory(self: &#39;AfumigatusState&#39;):
    cells = AfumigatusCellList(grid=self.global_state.grid)
    return AfumigatusCellTreeList(cells=cells)


@attr.s(kw_only=True)
class AfumigatusState(ModuleState):
    tree: AfumigatusCellTreeList = attr.ib(default=attr.Factory(cell_list_factory, takes_self=True))
    p_lodge: float = 0.5
    ITER_TO_CHANGE_STATUS: int = 2


class Afumigatus(ModuleModel):
    name = &#39;afumigatus&#39;
    StateClass = AfumigatusState

    def initialize(self, state: State):
        afumigatus: AfumigatusState = state.afumigatus

        afumigatus.p_lodge = self.config.getfloat(&#39;p_lodge&#39;)
        afumigatus.ITER_TO_CHANGE_STATUS = self.config.getint(&#39;ITER_TO_CHANGE_STATUS&#39;)

        point = Point(x=4, y=4, z=4)
        afumigatus.tree = AfumigatusCellTreeList.create_from_seed(
            grid=state.grid, point=point, status=AfumigatusCellData.Status.HYPHAE
        )

        return state

    def advance(self, state: State, previous_time: float) -&gt; State:
        # afumigatus: AfumigatusState = state.afumigatus
        # grid = state.grid
        # tissue = state.geometry.lung_tissue
        #
        # for index in afumigatus.tree.cells.alive():
        #    cell = afumigatus.tree.cells[index]
        #    vox = grid.get_voxel(cell[&#39;point&#39;])
        #
        #    if cell[&#39;mobile&#39;]:
        #        if vox.x &gt; Voxel(x=grid.xv[-1], y=grid.yv[0], z=grid.zv[0]):
        #            cell[&#39;status&#39;] = AfumigatusCellData.Status.DEAD
        #            cell[&#39;dead&#39;] = True
        #        if tissue[vox.z, vox.y, vox.x] == TissueTypes.EPITHELIUM:
        #            if afumigatus.p_lodge &gt; rg.random():
        #                cell[&#39;mobile&#39;] = False
        #    if cell[&#39;iteration&#39;] &gt;= afumigatus.ITER_TO_CHANGE_STATUS:
        #        if cell[&#39;status&#39;] == AfumigatusCellData.Status.RESTING_CONIDIA:
        #            cell[&#39;status&#39;] = AfumigatusCellData.Status.SWELLING_CONIDIA
        #        elif cell[&#39;status&#39;] == AfumigatusCellData.Status.SWELLING_CONIDIA:
        #            cell[&#39;status&#39;] = AfumigatusCellData.Status.GERMTUBE
        #        elif cell[&#39;status&#39;] == AfumigatusCellData.Status.INTERNALIZED:
        #            if afumigatus.p_internal_swell &gt; rg.random():
        #                cell[&#39;status&#39;] = AfumigatusCellData.Status.SWELLING_CONIDIA
        #
        #        if cell[&#39;status&#39;] == AfumigatusCellData.Status.SWELLING_CONIDIA:
        #            cell[&#39;iteration&#39;] = 0

        return state</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nlisim.modules.afumigatus.cell_list_factory"><code class="name flex">
<span>def <span class="ident">cell_list_factory</span></span>(<span>self: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_list_factory(self: &#39;AfumigatusState&#39;):
    cells = AfumigatusCellList(grid=self.global_state.grid)
    return AfumigatusCellTreeList(cells=cells)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nlisim.modules.afumigatus.Afumigatus"><code class="flex name class">
<span>class <span class="ident">Afumigatus</span></span>
<span>(</span><span>config: <a title="nlisim.config.SimulationConfig" href="../config.html#nlisim.config.SimulationConfig">SimulationConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Afumigatus(ModuleModel):
    name = &#39;afumigatus&#39;
    StateClass = AfumigatusState

    def initialize(self, state: State):
        afumigatus: AfumigatusState = state.afumigatus

        afumigatus.p_lodge = self.config.getfloat(&#39;p_lodge&#39;)
        afumigatus.ITER_TO_CHANGE_STATUS = self.config.getint(&#39;ITER_TO_CHANGE_STATUS&#39;)

        point = Point(x=4, y=4, z=4)
        afumigatus.tree = AfumigatusCellTreeList.create_from_seed(
            grid=state.grid, point=point, status=AfumigatusCellData.Status.HYPHAE
        )

        return state

    def advance(self, state: State, previous_time: float) -&gt; State:
        # afumigatus: AfumigatusState = state.afumigatus
        # grid = state.grid
        # tissue = state.geometry.lung_tissue
        #
        # for index in afumigatus.tree.cells.alive():
        #    cell = afumigatus.tree.cells[index]
        #    vox = grid.get_voxel(cell[&#39;point&#39;])
        #
        #    if cell[&#39;mobile&#39;]:
        #        if vox.x &gt; Voxel(x=grid.xv[-1], y=grid.yv[0], z=grid.zv[0]):
        #            cell[&#39;status&#39;] = AfumigatusCellData.Status.DEAD
        #            cell[&#39;dead&#39;] = True
        #        if tissue[vox.z, vox.y, vox.x] == TissueTypes.EPITHELIUM:
        #            if afumigatus.p_lodge &gt; rg.random():
        #                cell[&#39;mobile&#39;] = False
        #    if cell[&#39;iteration&#39;] &gt;= afumigatus.ITER_TO_CHANGE_STATUS:
        #        if cell[&#39;status&#39;] == AfumigatusCellData.Status.RESTING_CONIDIA:
        #            cell[&#39;status&#39;] = AfumigatusCellData.Status.SWELLING_CONIDIA
        #        elif cell[&#39;status&#39;] == AfumigatusCellData.Status.SWELLING_CONIDIA:
        #            cell[&#39;status&#39;] = AfumigatusCellData.Status.GERMTUBE
        #        elif cell[&#39;status&#39;] == AfumigatusCellData.Status.INTERNALIZED:
        #            if afumigatus.p_internal_swell &gt; rg.random():
        #                cell[&#39;status&#39;] = AfumigatusCellData.Status.SWELLING_CONIDIA
        #
        #        if cell[&#39;status&#39;] == AfumigatusCellData.Status.SWELLING_CONIDIA:
        #            cell[&#39;iteration&#39;] = 0

        return state</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleModel.StateClass" href="../module.html#nlisim.module.ModuleModel.StateClass">StateClass</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.advance" href="../module.html#nlisim.module.ModuleModel.advance">advance</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.construct" href="../module.html#nlisim.module.ModuleModel.construct">construct</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.finalize" href="../module.html#nlisim.module.ModuleModel.finalize">finalize</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.initialize" href="../module.html#nlisim.module.ModuleModel.initialize">initialize</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.name" href="../module.html#nlisim.module.ModuleModel.name">name</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.section" href="../module.html#nlisim.module.ModuleModel.section">section</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.time_step" href="../module.html#nlisim.module.ModuleModel.time_step">time_step</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCell"><code class="flex name class">
<span>class <span class="ident">AfumigatusCell</span></span>
<span>(</span><span>*, tree: <a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a>, index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class AfumigatusCell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCell(MutableMapping):
    tree: &#39;AfumigatusCellTreeList&#39;
    index: int = attr.ib()

    @index.validator
    def _validate_index(self, attribute, value):
        if value &gt;= len(self.tree):
            raise ValueError(&#39;Invalid cell index&#39;)

    def __attrs_post_init__(self):
        if self.index &lt; 0:
            object.__setattr__(self, &#39;index&#39;, self.index + len(self.tree))

    @property
    def record(self) -&gt; CellType:
        return self.tree.cells[self.index]

    @property
    def parent(self) -&gt; Optional[&#39;AfumigatusCell&#39;]:
        indices = self.tree.adjacency[:, self.index].nonzero()[0]
        if len(indices) == 1:
            return None
        if len(indices) == 2 and indices[0] == self.index:
            index = indices[0]
            if index == self.index:
                index = indices[1]
            return self.__class__(tree=self.tree, index=index)

        raise Exception(f&#39;Invalid adjacency matrix at index {self.index}&#39;)

    @property
    def children(self) -&gt; Iterator[&#39;AfumigatusCell&#39;]:
        indices = self.tree.adjacency[self.index].nonzero()[1]
        for index in indices:
            if index != self.index:
                yield self.__class__(tree=self.tree, index=index)

    def add_child(self, cell: Union[CellType, &#39;AfumigatusCell&#39;]):
        if isinstance(cell, AfumigatusCell):
            cell = cell.record
        self.tree.append(cell, parent=self.index)

    def kill(self) -&gt; List[&#39;AfumigatusCell&#39;]:
        &#34;&#34;&#34;Mark the current cell as dead and remove it from the tree.&#34;&#34;&#34;
        return self.tree.kill(self.index)

    def __getitem__(self, key):
        return self.record.__getitem__(key)

    def __setitem__(self, key, value):
        self.tree.cell_data[key][self.index] = value

    def __delitem__(self, key):
        return self.record.__delitem__(key)

    def __iter__(self):
        for key in self.record.dtype.fields.keys():
            yield key

    def __contains__(self, key):
        return key in self.record.dtype.fields

    def __len__(self):
        return len(self.record)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.index"><code class="name">var <span class="ident">index</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.tree"><code class="name">var <span class="ident">tree</span> : <a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.children"><code class="name">var <span class="ident">children</span> : Iterator[<a title="nlisim.modules.afumigatus.AfumigatusCell" href="#nlisim.modules.afumigatus.AfumigatusCell">AfumigatusCell</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self) -&gt; Iterator[&#39;AfumigatusCell&#39;]:
    indices = self.tree.adjacency[self.index].nonzero()[1]
    for index in indices:
        if index != self.index:
            yield self.__class__(tree=self.tree, index=index)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.parent"><code class="name">var <span class="ident">parent</span> : Union[<a title="nlisim.modules.afumigatus.AfumigatusCell" href="#nlisim.modules.afumigatus.AfumigatusCell">AfumigatusCell</a>, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self) -&gt; Optional[&#39;AfumigatusCell&#39;]:
    indices = self.tree.adjacency[:, self.index].nonzero()[0]
    if len(indices) == 1:
        return None
    if len(indices) == 2 and indices[0] == self.index:
        index = indices[0]
        if index == self.index:
            index = indices[1]
        return self.__class__(tree=self.tree, index=index)

    raise Exception(f&#39;Invalid adjacency matrix at index {self.index}&#39;)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.record"><code class="name">var <span class="ident">record</span> : Any</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def record(self) -&gt; CellType:
    return self.tree.cells[self.index]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, cell: Union[Any, ForwardRef('<a title="nlisim.modules.afumigatus.AfumigatusCell" href="#nlisim.modules.afumigatus.AfumigatusCell">AfumigatusCell</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_child(self, cell: Union[CellType, &#39;AfumigatusCell&#39;]):
    if isinstance(cell, AfumigatusCell):
        cell = cell.record
    self.tree.append(cell, parent=self.index)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCell.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self) ‑> List[<a title="nlisim.modules.afumigatus.AfumigatusCell" href="#nlisim.modules.afumigatus.AfumigatusCell">AfumigatusCell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Mark the current cell as dead and remove it from the tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self) -&gt; List[&#39;AfumigatusCell&#39;]:
    &#34;&#34;&#34;Mark the current cell as dead and remove it from the tree.&#34;&#34;&#34;
    return self.tree.kill(self.index)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellData</span></span>
<span>(</span><span>arg: Union[int, Iterable[numpy.record]], initialize: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A low-level data contain for an array cells.</p>
<p>This class is a subtype of
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html">numpy.recarray</a>
containing the lowest level representation of a list of "cells" in a
simulation.
The underlying data format of this type are identical to a
simple array of C structures with the fields given in the static "dtype"
variable.</p>
<p>The base class contains only a single coordinate representing the location
of the center of the cell.
Most implementations will want to override this
class to append more fields.
Subclasses must also override the base
implementation of <code>create_cell</code> to construct a single record containing
the additional fields.</p>
<p>For example, the following derived class adds an addition floating point value
associated with each cell.</p>
<pre><code class="language-python">class DerivedCell(CellData):
    FIELDS = CellData.FIELDS + [
        ('iron_content', 'f8')
    ]

    dtype = np.dtype(CellData.FIELDS, align=True)

    @classmethod
    def create_cell_tuple(cls, iron_content=0, **kwargs):
        return CellData.create_cell_tuple(**kwargs) + (iron_content,)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellData(CellData):
    GROWTH_SCALE_FACTOR = 0.02  # from original code
    BOOLEAN_NETWORK_LENGTH = 23

    class Status(IntEnum):
        RESTING_CONIDIA = 0
        SWELLING_CONIDIA = 1
        GERMTUBE = 5
        HYPHAE = 2
        DYING = 3
        DEAD = 4
        INTERNALIZED = 6

    class State(IntEnum):
        FREE = 0
        INTERNALIZING = 1
        RELEASING = 2

    AFUMIGATUS_FIELDS = [
        (&#39;boolean_network&#39;, &#39;b1&#39;, BOOLEAN_NETWORK_LENGTH),
        (&#39;growth&#39;, Point.dtype),
        (&#39;growable&#39;, &#39;b1&#39;),
        (&#39;switched&#39;, &#39;b1&#39;),
        (&#39;branchable&#39;, &#39;b1&#39;),
        (&#39;state&#39;, &#39;u1&#39;),
        (&#39;status&#39;, &#39;u1&#39;),
        (&#39;iron_pool&#39;, &#39;f8&#39;),
        (&#39;iron&#39;, &#39;b1&#39;),
        (&#39;iteration&#39;, &#39;i4&#39;),
        (&#39;health&#39;, &#39;f8&#39;),
        (&#39;mobile&#39;, &#39;b1&#39;),
    ]

    FIELDS = CellData.FIELDS + AFUMIGATUS_FIELDS
    dtype = np.dtype(FIELDS, align=True)  # type: ignore

    @classmethod
    def create_cell_tuple(
        cls,
        *,
        iron_pool: float = 0,
        status: Status = Status.RESTING_CONIDIA,
        state: State = State.FREE,
        **kwargs,
    ) -&gt; np.record:

        growth = cls.GROWTH_SCALE_FACTOR * Point.from_array(2 * rg.random(3) - 1)
        network = cls.initial_boolean_network()
        growable = True
        switched = False
        branchable = False
        iteration = 0
        iron = False
        health = 100
        mobile = True

        return CellData.create_cell_tuple(**kwargs) + (
            network,
            growth,
            growable,
            switched,
            branchable,
            state,
            status,
            iron_pool,
            iron,
            iteration,
            health,
            mobile,
        )

    @classmethod
    def initial_boolean_network(cls) -&gt; np.ndarray:
        return np.asarray(
            [
                True,
                False,
                True,
                False,
                True,
                True,
                True,
                True,
                True,
                False,
                False,
                False,
                True,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
                False,
            ]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></li>
<li>numpy.ndarray</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.AFUMIGATUS_FIELDS"><code class="name">var <span class="ident">AFUMIGATUS_FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.BOOLEAN_NETWORK_LENGTH"><code class="name">var <span class="ident">BOOLEAN_NETWORK_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.GROWTH_SCALE_FACTOR"><code class="name">var <span class="ident">GROWTH_SCALE_FACTOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.State"><code class="name">var <span class="ident">State</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.Status"><code class="name">var <span class="ident">Status</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.initial_boolean_network"><code class="name flex">
<span>def <span class="ident">initial_boolean_network</span></span>(<span>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initial_boolean_network(cls) -&gt; np.ndarray:
    return np.asarray(
        [
            True,
            False,
            True,
            False,
            True,
            True,
            True,
            True,
            True,
            False,
            False,
            False,
            True,
            False,
            False,
            False,
            False,
            False,
            False,
            False,
            False,
            False,
            False,
        ]
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellData.FIELDS" href="../cell.html#nlisim.cell.CellData.FIELDS">FIELDS</a></code></li>
<li><code><a title="nlisim.cell.CellData.create_cell" href="../cell.html#nlisim.cell.CellData.create_cell">create_cell</a></code></li>
<li><code><a title="nlisim.cell.CellData.create_cell_tuple" href="../cell.html#nlisim.cell.CellData.create_cell_tuple">create_cell_tuple</a></code></li>
<li><code><a title="nlisim.cell.CellData.dtype" href="../cell.html#nlisim.cell.CellData.dtype">dtype</a></code></li>
<li><code><a title="nlisim.cell.CellData.point_mask" href="../cell.html#nlisim.cell.CellData.point_mask">point_mask</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellList"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellList</span></span>
<span>(</span><span>*, grid: <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a>, max_cells: int = 1000000, cell_data: <a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>A python view on top of a CellData array.</p>
<p>This class represents a pythonic interface to the data contained in a
CellData array.
Because the CellData class is a low-level object, it does
not allow dynamically appending new elements.
Objects of this class get
around this limitation by pre-allocating a large block of memory that is
transparently available.
User-facing properties are sliced to make it
appear as if the extra data is not there.</p>
<p>Subclassed types are expected to set the <code>CellDataClass</code> attribute to
a subclass of <code>CellData</code>.
This provides information about the underlying
low-level array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>simulation.grid.RectangularGrid</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_cells</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>cells</code></strong> :&ensp;<code>simulation.cell.CellData</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Method generated by attrs for class AfumigatusCellList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellList(CellList):
    CellDataClass = AfumigatusCellData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellList.grid"><code class="name">var <span class="ident">grid</span> : <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellList.max_cells"><code class="name">var <span class="ident">max_cells</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellList.CellDataClass" href="../cell.html#nlisim.cell.CellList.CellDataClass">CellDataClass</a></code></li>
<li><code><a title="nlisim.cell.CellList.alive" href="../cell.html#nlisim.cell.CellList.alive">alive</a></code></li>
<li><code><a title="nlisim.cell.CellList.append" href="../cell.html#nlisim.cell.CellList.append">append</a></code></li>
<li><code><a title="nlisim.cell.CellList.cell_data" href="../cell.html#nlisim.cell.CellList.cell_data">cell_data</a></code></li>
<li><code><a title="nlisim.cell.CellList.create_from_seed" href="../cell.html#nlisim.cell.CellList.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="nlisim.cell.CellList.extend" href="../cell.html#nlisim.cell.CellList.extend">extend</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_cells_in_voxel" href="../cell.html#nlisim.cell.CellList.get_cells_in_voxel">get_cells_in_voxel</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_neighboring_cells" href="../cell.html#nlisim.cell.CellList.get_neighboring_cells">get_neighboring_cells</a></code></li>
<li><code><a title="nlisim.cell.CellList.load" href="../cell.html#nlisim.cell.CellList.load">load</a></code></li>
<li><code><a title="nlisim.cell.CellList.save" href="../cell.html#nlisim.cell.CellList.save">save</a></code></li>
<li><code><a title="nlisim.cell.CellList.update_voxel_index" href="../cell.html#nlisim.cell.CellList.update_voxel_index">update_voxel_index</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellTreeList</span></span>
<span>(</span><span>*, cells: <a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a>, adjacency: scipy.sparse.dok.dok_matrix = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class AfumigatusCellTreeList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellTreeList(object):
    cells: CellList = attr.ib()
    _adjacency: sparse_matrix = attr.ib()

    @_adjacency.default
    def __set_default_adjacency(self):
        return sparse_matrix((0, 0))

    def __attrs_post_init__(self):
        cells = self.cells
        adjacency = self._adjacency

        object.__setattr__(self, &#39;_adjacency&#39;, sparse_matrix((cells.max_cells, cells.max_cells)))

        if len(cells) &gt; 0:
            for key, value in adjacency.items():
                self._adjacency[key] = value

    @property
    def adjacency(self) -&gt; sparse_matrix:
        return self._adjacency[: len(self), : len(self)]

    @property
    def roots(self) -&gt; List[CellType]:
        # This is linear in the number of nodes... might need to be optimized.
        roots = []
        for i in range(len(self)):
            cell = self[i]
            if not cell[&#39;dead&#39;] and cell.parent is None:
                roots.append(cell)
        return roots

    @property
    def cell_data(self) -&gt; AfumigatusCellData:
        return self.cells.cell_data

    @property
    def max_cells(self) -&gt; int:
        return self.cells.max_cells

    @property
    def grid(self) -&gt; RectangularGrid:
        return self.cells.grid

    @classmethod
    def random_branch_direction(cls, growth: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Rotate by a random 45 degree angle from the axis of growth.&#34;&#34;&#34;
        growth = Point.from_array(growth)

        # get a random vector orthogonal to the growth vector
        axis = Point.from_array(np.cross(growth, rg.standard_normal(3)))
        axis = (np.pi / 4) * axis / axis.norm()

        # rotate the growth vector 45 degrees along the random axis
        rotation = Rotation.from_rotvec(axis)
        return rotation.apply(growth)

    @classmethod
    def create_from_seed(cls, grid, **kwargs) -&gt; &#39;AfumigatusCellTreeList&#39;:
        cells = AfumigatusCellList.create_from_seed(grid, **kwargs)
        adjacency = sparse_matrix((1, 1))
        adjacency[0, 0] = 1

        return cls(cells=cells, adjacency=adjacency)

    def __len__(self):
        return len(self.cells)

    def __getitem__(self, index: int) -&gt; AfumigatusCell:
        if isinstance(index, str):
            raise TypeError(&#39;Expected an integer index, did you mean `tree.cell_data[key]`?&#39;)
        return AfumigatusCell(tree=self, index=index)

    def append(self, cell, parent=None):
        index = len(self)
        self.cells.append(cell)
        self._adjacency[index, index] = 1

        if parent is not None:
            self._adjacency[parent, index] = 1
            iron_pool = self.cells[parent][&#39;iron_pool&#39;] / 2
            self.cells[parent][&#39;iron_pool&#39;] = self.cells[-1][&#39;iron_pool&#39;] = iron_pool

    def extend(self, cells: CellData, parents: Iterable[Union[int, None]] = None) -&gt; None:
        if parents is None:
            parents = [None] * len(cells)

        for cell, parent in zip(cells, parents):
            self.append(cell, parent)

    def kill(self, index: int) -&gt; List[AfumigatusCell]:
        &#34;&#34;&#34;Kill the cell at the given index and remove it from the tree.

        This method will return a list of cells which were children of the
        killed cell.  These children will be the roots of newly formed trees.
        &#34;&#34;&#34;
        self.cell_data[index][&#39;dead&#39;] = True
        roots = []
        for i in range(len(self)):
            if i == index:
                continue
            if self._adjacency.pop((i, index), None):
                self[i][&#39;growable&#39;] = True
            if self._adjacency.pop((index, i), None):
                roots.append(self[i])
        return roots

    def is_growable(self) -&gt; np.ndarray:
        cells = self.cells.cell_data
        return self.cells.alive(
            cells[&#39;growable&#39;]
            &amp; cells.point_mask(cells[&#39;point&#39;] + cells[&#39;growth&#39;], self.grid)
            &amp; (cells[&#39;status&#39;] == AfumigatusCellData.Status.HYPHAE)
        )

    def is_branchable(self, branch_probability: float) -&gt; np.ndarray:
        cells = self.cells.cell_data
        return self.cells.alive(
            cells[&#39;branchable&#39;]
            &amp; (rg.random(cells.shape) &lt; branch_probability)
            &amp; (cells[&#39;status&#39;] == AfumigatusCellData.Status.HYPHAE)
        )

    def absorb_iron(self):
        &#34;&#34;&#34;Absorb iron from the environment.

        This is a dummy method for the visualization testing purpose.
        &#34;&#34;&#34;
        #  TODO: implement a real iron uptake model
        cells = self.cells.cell_data
        iron = rg.random(len(self.cells))
        cells[&#39;iron_pool&#39;] = np.add(cells[&#39;iron_pool&#39;], iron)

    def age(self):
        &#34;&#34;&#34;Add 1 to iteration each time step.&#34;&#34;&#34;
        cells = self.cells.cell_data
        cells[&#39;iteration&#39;] += 1

    def alive(self):
        return self.cells.alive()

    def elongate(self):
        cells = self.cell_data
        mask = self.is_growable()
        if len(mask) == 0:
            return

        cells[&#39;growable&#39;][mask] = False
        cells[&#39;branchable&#39;][mask] = True

        children = AfumigatusCellData(len(mask), initialize=True)
        children[&#39;point&#39;] = cells[&#39;point&#39;][mask] + cells[&#39;growth&#39;][mask]
        children[&#39;growth&#39;] = cells[&#39;growth&#39;][mask]

        self.extend(children, parents=mask)

    def branch(self, branch_probability: float):
        cells = self.cell_data
        indices = self.is_branchable(branch_probability)
        if len(indices) == 0:
            return

        children = AfumigatusCellData(len(indices), initialize=True)
        children[&#39;growth&#39;] = cells[indices][&#39;growth&#39;]
        children[&#39;growth&#39;] = np.apply_along_axis(
            self.random_branch_direction, 1, children[&#39;growth&#39;]
        )

        children[&#39;point&#39;] = cells[&#39;point&#39;][indices] + children[&#39;growth&#39;]

        # filter out children lying outside of the domain
        indices = indices[cells.point_mask(children[&#39;point&#39;], self.grid)]
        if len(indices) == 0:
            return

        # set properties
        cells[&#39;branchable&#39;][indices] = False
        children[&#39;growable&#39;] = True
        children[&#39;branchable&#39;] = False

        self.extend(children, parents=indices)

    def save(self, group: Group, name: str, metadata: dict) -&gt; Group:
        composite_group = group.create_group(name)
        composite_group.attrs[&#39;class&#39;] = get_class_path(self)
        composite_group.attrs[&#39;type&#39;] = &#39;CellTree&#39;
        self.cells.save(composite_group, &#39;cells&#39;, metadata)

        sp = self.adjacency.tocoo()
        composite_group.create_dataset(name=&#39;row&#39;, data=sp.row)
        composite_group.create_dataset(name=&#39;col&#39;, data=sp.col)
        composite_group.create_dataset(name=&#39;value&#39;, data=sp.data)
        return composite_group

    @classmethod
    def load(
        cls, global_state: State, group: Group, name: str, metadata: dict
    ) -&gt; &#39;AfumigatusCellTreeList&#39;:
        composite_dataset = group[name]
        cells = AfumigatusCellList.load(global_state, composite_dataset, &#39;cells&#39;, metadata)

        adjacency = coo_matrix(
            (
                composite_dataset[&#39;value&#39;],
                (composite_dataset[&#39;row&#39;], composite_dataset[&#39;col&#39;]),
            ),
            shape=(cells.max_cells, cells.max_cells),
        ).todok()

        return cls(cells=cells, adjacency=adjacency)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.cells"><code class="name">var <span class="ident">cells</span> : <a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.create_from_seed"><code class="name flex">
<span>def <span class="ident">create_from_seed</span></span>(<span>grid, **kwargs) ‑> <a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_from_seed(cls, grid, **kwargs) -&gt; &#39;AfumigatusCellTreeList&#39;:
    cells = AfumigatusCellList.create_from_seed(grid, **kwargs)
    adjacency = sparse_matrix((1, 1))
    adjacency[0, 0] = 1

    return cls(cells=cells, adjacency=adjacency)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>global_state: <a title="nlisim.state.State" href="../state.html#nlisim.state.State">State</a>, group: h5py._hl.group.Group, name: str, metadata: dict) ‑> <a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(
    cls, global_state: State, group: Group, name: str, metadata: dict
) -&gt; &#39;AfumigatusCellTreeList&#39;:
    composite_dataset = group[name]
    cells = AfumigatusCellList.load(global_state, composite_dataset, &#39;cells&#39;, metadata)

    adjacency = coo_matrix(
        (
            composite_dataset[&#39;value&#39;],
            (composite_dataset[&#39;row&#39;], composite_dataset[&#39;col&#39;]),
        ),
        shape=(cells.max_cells, cells.max_cells),
    ).todok()

    return cls(cells=cells, adjacency=adjacency)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.random_branch_direction"><code class="name flex">
<span>def <span class="ident">random_branch_direction</span></span>(<span>growth: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate by a random 45 degree angle from the axis of growth.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def random_branch_direction(cls, growth: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Rotate by a random 45 degree angle from the axis of growth.&#34;&#34;&#34;
    growth = Point.from_array(growth)

    # get a random vector orthogonal to the growth vector
    axis = Point.from_array(np.cross(growth, rg.standard_normal(3)))
    axis = (np.pi / 4) * axis / axis.norm()

    # rotate the growth vector 45 degrees along the random axis
    rotation = Rotation.from_rotvec(axis)
    return rotation.apply(growth)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.adjacency"><code class="name">var <span class="ident">adjacency</span> : scipy.sparse.dok.dok_matrix</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def adjacency(self) -&gt; sparse_matrix:
    return self._adjacency[: len(self), : len(self)]</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.cell_data"><code class="name">var <span class="ident">cell_data</span> : <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cell_data(self) -&gt; AfumigatusCellData:
    return self.cells.cell_data</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.grid"><code class="name">var <span class="ident">grid</span> : <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid(self) -&gt; RectangularGrid:
    return self.cells.grid</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.max_cells"><code class="name">var <span class="ident">max_cells</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_cells(self) -&gt; int:
    return self.cells.max_cells</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.roots"><code class="name">var <span class="ident">roots</span> : List[Any]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def roots(self) -&gt; List[CellType]:
    # This is linear in the number of nodes... might need to be optimized.
    roots = []
    for i in range(len(self)):
        cell = self[i]
        if not cell[&#39;dead&#39;] and cell.parent is None:
            roots.append(cell)
    return roots</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.absorb_iron"><code class="name flex">
<span>def <span class="ident">absorb_iron</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Absorb iron from the environment.</p>
<p>This is a dummy method for the visualization testing purpose.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absorb_iron(self):
    &#34;&#34;&#34;Absorb iron from the environment.

    This is a dummy method for the visualization testing purpose.
    &#34;&#34;&#34;
    #  TODO: implement a real iron uptake model
    cells = self.cells.cell_data
    iron = rg.random(len(self.cells))
    cells[&#39;iron_pool&#39;] = np.add(cells[&#39;iron_pool&#39;], iron)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.age"><code class="name flex">
<span>def <span class="ident">age</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add 1 to iteration each time step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def age(self):
    &#34;&#34;&#34;Add 1 to iteration each time step.&#34;&#34;&#34;
    cells = self.cells.cell_data
    cells[&#39;iteration&#39;] += 1</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.alive"><code class="name flex">
<span>def <span class="ident">alive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alive(self):
    return self.cells.alive()</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, cell, parent=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, cell, parent=None):
    index = len(self)
    self.cells.append(cell)
    self._adjacency[index, index] = 1

    if parent is not None:
        self._adjacency[parent, index] = 1
        iron_pool = self.cells[parent][&#39;iron_pool&#39;] / 2
        self.cells[parent][&#39;iron_pool&#39;] = self.cells[-1][&#39;iron_pool&#39;] = iron_pool</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.branch"><code class="name flex">
<span>def <span class="ident">branch</span></span>(<span>self, branch_probability: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def branch(self, branch_probability: float):
    cells = self.cell_data
    indices = self.is_branchable(branch_probability)
    if len(indices) == 0:
        return

    children = AfumigatusCellData(len(indices), initialize=True)
    children[&#39;growth&#39;] = cells[indices][&#39;growth&#39;]
    children[&#39;growth&#39;] = np.apply_along_axis(
        self.random_branch_direction, 1, children[&#39;growth&#39;]
    )

    children[&#39;point&#39;] = cells[&#39;point&#39;][indices] + children[&#39;growth&#39;]

    # filter out children lying outside of the domain
    indices = indices[cells.point_mask(children[&#39;point&#39;], self.grid)]
    if len(indices) == 0:
        return

    # set properties
    cells[&#39;branchable&#39;][indices] = False
    children[&#39;growable&#39;] = True
    children[&#39;branchable&#39;] = False

    self.extend(children, parents=indices)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.elongate"><code class="name flex">
<span>def <span class="ident">elongate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elongate(self):
    cells = self.cell_data
    mask = self.is_growable()
    if len(mask) == 0:
        return

    cells[&#39;growable&#39;][mask] = False
    cells[&#39;branchable&#39;][mask] = True

    children = AfumigatusCellData(len(mask), initialize=True)
    children[&#39;point&#39;] = cells[&#39;point&#39;][mask] + cells[&#39;growth&#39;][mask]
    children[&#39;growth&#39;] = cells[&#39;growth&#39;][mask]

    self.extend(children, parents=mask)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, cells: <a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a>, parents: Iterable[Union[int, NoneType]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, cells: CellData, parents: Iterable[Union[int, None]] = None) -&gt; None:
    if parents is None:
        parents = [None] * len(cells)

    for cell, parent in zip(cells, parents):
        self.append(cell, parent)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.is_branchable"><code class="name flex">
<span>def <span class="ident">is_branchable</span></span>(<span>self, branch_probability: float) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_branchable(self, branch_probability: float) -&gt; np.ndarray:
    cells = self.cells.cell_data
    return self.cells.alive(
        cells[&#39;branchable&#39;]
        &amp; (rg.random(cells.shape) &lt; branch_probability)
        &amp; (cells[&#39;status&#39;] == AfumigatusCellData.Status.HYPHAE)
    )</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.is_growable"><code class="name flex">
<span>def <span class="ident">is_growable</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_growable(self) -&gt; np.ndarray:
    cells = self.cells.cell_data
    return self.cells.alive(
        cells[&#39;growable&#39;]
        &amp; cells.point_mask(cells[&#39;point&#39;] + cells[&#39;growth&#39;], self.grid)
        &amp; (cells[&#39;status&#39;] == AfumigatusCellData.Status.HYPHAE)
    )</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self, index: int) ‑> List[<a title="nlisim.modules.afumigatus.AfumigatusCell" href="#nlisim.modules.afumigatus.AfumigatusCell">AfumigatusCell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Kill the cell at the given index and remove it from the tree.</p>
<p>This method will return a list of cells which were children of the
killed cell.
These children will be the roots of newly formed trees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self, index: int) -&gt; List[AfumigatusCell]:
    &#34;&#34;&#34;Kill the cell at the given index and remove it from the tree.

    This method will return a list of cells which were children of the
    killed cell.  These children will be the roots of newly formed trees.
    &#34;&#34;&#34;
    self.cell_data[index][&#39;dead&#39;] = True
    roots = []
    for i in range(len(self)):
        if i == index:
            continue
        if self._adjacency.pop((i, index), None):
            self[i][&#39;growable&#39;] = True
        if self._adjacency.pop((index, i), None):
            roots.append(self[i])
    return roots</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellTreeList.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, group: h5py._hl.group.Group, name: str, metadata: dict) ‑> h5py._hl.group.Group</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, group: Group, name: str, metadata: dict) -&gt; Group:
    composite_group = group.create_group(name)
    composite_group.attrs[&#39;class&#39;] = get_class_path(self)
    composite_group.attrs[&#39;type&#39;] = &#39;CellTree&#39;
    self.cells.save(composite_group, &#39;cells&#39;, metadata)

    sp = self.adjacency.tocoo()
    composite_group.create_dataset(name=&#39;row&#39;, data=sp.row)
    composite_group.create_dataset(name=&#39;col&#39;, data=sp.col)
    composite_group.create_dataset(name=&#39;value&#39;, data=sp.data)
    return composite_group</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState"><code class="flex name class">
<span>class <span class="ident">AfumigatusState</span></span>
<span>(</span><span>*, global_state: State, tree: <a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>Base type intended to store the state for simulation modules.</p>
<p>This class contains serialization support for basic types (float, int, str,
bool) and numpy arrays of those types.
Modules containing more complicated
state must override the serialization mechanism with custom behavior.</p>
<p>Method generated by attrs for class AfumigatusState.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusState(ModuleState):
    tree: AfumigatusCellTreeList = attr.ib(default=attr.Factory(cell_list_factory, takes_self=True))
    p_lodge: float = 0.5
    ITER_TO_CHANGE_STATUS: int = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusState.ITER_TO_CHANGE_STATUS"><code class="name">var <span class="ident">ITER_TO_CHANGE_STATUS</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.p_lodge"><code class="name">var <span class="ident">p_lodge</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.tree"><code class="name">var <span class="ident">tree</span> : <a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleState.load_attribute" href="../module.html#nlisim.module.ModuleState.load_attribute">load_attribute</a></code></li>
<li><code><a title="nlisim.module.ModuleState.load_state" href="../module.html#nlisim.module.ModuleState.load_state">load_state</a></code></li>
<li><code><a title="nlisim.module.ModuleState.save_attribute" href="../module.html#nlisim.module.ModuleState.save_attribute">save_attribute</a></code></li>
<li><code><a title="nlisim.module.ModuleState.save_state" href="../module.html#nlisim.module.ModuleState.save_state">save_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nlisim.modules" href="index.html">nlisim.modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.cell_list_factory" href="#nlisim.modules.afumigatus.cell_list_factory">cell_list_factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nlisim.modules.afumigatus.Afumigatus" href="#nlisim.modules.afumigatus.Afumigatus">Afumigatus</a></code></h4>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCell" href="#nlisim.modules.afumigatus.AfumigatusCell">AfumigatusCell</a></code></h4>
<ul class="two-column">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.add_child" href="#nlisim.modules.afumigatus.AfumigatusCell.add_child">add_child</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.children" href="#nlisim.modules.afumigatus.AfumigatusCell.children">children</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.index" href="#nlisim.modules.afumigatus.AfumigatusCell.index">index</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.kill" href="#nlisim.modules.afumigatus.AfumigatusCell.kill">kill</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.parent" href="#nlisim.modules.afumigatus.AfumigatusCell.parent">parent</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.record" href="#nlisim.modules.afumigatus.AfumigatusCell.record">record</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCell.tree" href="#nlisim.modules.afumigatus.AfumigatusCell.tree">tree</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.AFUMIGATUS_FIELDS" href="#nlisim.modules.afumigatus.AfumigatusCellData.AFUMIGATUS_FIELDS">AFUMIGATUS_FIELDS</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.BOOLEAN_NETWORK_LENGTH" href="#nlisim.modules.afumigatus.AfumigatusCellData.BOOLEAN_NETWORK_LENGTH">BOOLEAN_NETWORK_LENGTH</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.GROWTH_SCALE_FACTOR" href="#nlisim.modules.afumigatus.AfumigatusCellData.GROWTH_SCALE_FACTOR">GROWTH_SCALE_FACTOR</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.State" href="#nlisim.modules.afumigatus.AfumigatusCellData.State">State</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.Status" href="#nlisim.modules.afumigatus.AfumigatusCellData.Status">Status</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.initial_boolean_network" href="#nlisim.modules.afumigatus.AfumigatusCellData.initial_boolean_network">initial_boolean_network</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellList" href="#nlisim.modules.afumigatus.AfumigatusCellList">AfumigatusCellList</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellList.grid" href="#nlisim.modules.afumigatus.AfumigatusCellList.grid">grid</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellList.max_cells" href="#nlisim.modules.afumigatus.AfumigatusCellList.max_cells">max_cells</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList">AfumigatusCellTreeList</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.absorb_iron" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.absorb_iron">absorb_iron</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.adjacency" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.adjacency">adjacency</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.age" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.age">age</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.alive" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.alive">alive</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.append" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.append">append</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.branch" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.branch">branch</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.cell_data" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.cell_data">cell_data</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.cells" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.cells">cells</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.create_from_seed" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.elongate" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.elongate">elongate</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.extend" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.extend">extend</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.grid" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.grid">grid</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.is_branchable" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.is_branchable">is_branchable</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.is_growable" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.is_growable">is_growable</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.kill" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.kill">kill</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.load" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.load">load</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.max_cells" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.max_cells">max_cells</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.random_branch_direction" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.random_branch_direction">random_branch_direction</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.roots" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.roots">roots</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellTreeList.save" href="#nlisim.modules.afumigatus.AfumigatusCellTreeList.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.ITER_TO_CHANGE_STATUS" href="#nlisim.modules.afumigatus.AfumigatusState.ITER_TO_CHANGE_STATUS">ITER_TO_CHANGE_STATUS</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.p_lodge" href="#nlisim.modules.afumigatus.AfumigatusState.p_lodge">p_lodge</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.tree" href="#nlisim.modules.afumigatus.AfumigatusState.tree">tree</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>