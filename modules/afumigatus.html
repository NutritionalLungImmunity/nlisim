<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nlisim.modules.afumigatus API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nlisim.modules.afumigatus</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from enum import IntEnum, unique
import math
from queue import Queue
import random
from typing import Any, Dict, Tuple

import attr
from attr import attrib, attrs
import numpy as np

from nlisim.cell import CellData, CellFields, CellList
from nlisim.coordinates import Point, Voxel
from nlisim.grid import RectangularGrid
from nlisim.module import ModuleModel, ModuleState
from nlisim.modules.iron import IronState
from nlisim.modules.phagocyte import interact_with_aspergillus
from nlisim.random import rg
from nlisim.state import State
from nlisim.util import TissueType


@unique
class AfumigatusCellStatus(IntEnum):
    DEAD = 0
    RESTING_CONIDIA = 1
    SWELLING_CONIDIA = 2
    GERM_TUBE = 3
    HYPHAE = 4
    STERILE_CONIDIA = 5


@unique
class NetworkSpecies(IntEnum):
    hapX = 0  # gene # noqa: N815
    sreA = 1  # gene # noqa: N815
    HapX = 2  # protein
    SreA = 3  # protein
    RIA = 4
    EstB = 5
    MirB = 6
    SidA = 7
    TAFC = 8
    ICP = 9
    LIP = 10
    CccA = 11
    FC0fe = 12
    FC1fe = 13
    VAC = 14
    ROS = 15
    Yap1 = 16
    SOD2_3 = 17
    Cat1_2 = 18
    ThP = 19
    Fe = 20
    Oxygen = 21


@unique
class AfumigatusCellState(IntEnum):
    FREE = 0
    INTERNALIZING = 1
    RELEASING = 2


def random_sphere_point() -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a random point on the unit 2-sphere in R^3 using Marsaglia&#39;s method&#34;&#34;&#34;
    # generate vector in unit disc
    u: np.ndarray = 2 * rg.random(size=2) - 1
    while np.linalg.norm(u) &gt; 1.0:
        u = 2 * rg.random(size=2) - 1

    norm_squared_u = float(np.dot(u, u))
    return np.array(
        [
            2 * u[0] * np.sqrt(1 - norm_squared_u),
            2 * u[1] * np.sqrt(1 - norm_squared_u),
            1 - 2 * norm_squared_u,
        ],
        dtype=np.float64,
    )


class AfumigatusCellData(CellData):
    AFUMIGATUS_FIELDS: CellFields = [
        (&#39;iron_pool&#39;, np.float64),  # units: atto-mol
        (&#39;state&#39;, np.uint8),
        (&#39;status&#39;, np.uint8),
        (&#39;is_root&#39;, bool),
        (&#39;vec&#39;, np.float64, 3),  # unit vector, length is in afumigatus.hyphal_length
        (&#39;activation_iteration&#39;, np.int64),
        (&#39;growth_iteration&#39;, np.int64),
        (&#39;boolean_network&#39;, &#39;b1&#39;, len(NetworkSpecies)),
        (&#39;next_branch&#39;, np.int64),
        (&#39;next_septa&#39;, np.int64),
        (&#39;previous_septa&#39;, np.int64),
        (&#39;bn_iteration&#39;, np.int64),
    ]

    FIELDS = CellData.FIELDS + AFUMIGATUS_FIELDS
    dtype = np.dtype(FIELDS, align=True)  # type: ignore

    @classmethod
    def create_cell_tuple(cls, **kwargs) -&gt; Tuple:
        initializer = {
            &#39;iron_pool&#39;: kwargs.get(&#39;iron_pool&#39;, 0),
            &#39;state&#39;: kwargs.get(&#39;state&#39;, AfumigatusCellState.FREE),
            &#39;status&#39;: kwargs.get(&#39;status&#39;, AfumigatusCellStatus.RESTING_CONIDIA),
            &#39;is_root&#39;: kwargs.get(&#39;is_root&#39;, True),
            &#39;vec&#39;: kwargs.get(&#39;vec&#39;, random_sphere_point()),  # dz, dy, dx
            &#39;activation_iteration&#39;: kwargs.get(&#39;activation_iteration&#39;, 0),
            &#39;growth_iteration&#39;: kwargs.get(&#39;growth_iteration&#39;, 0),
            &#39;boolean_network&#39;: kwargs.get(&#39;boolean_network&#39;, cls.initial_boolean_network()),
            &#39;bn_iteration&#39;: kwargs.get(&#39;bn_iteration&#39;, 0),
            &#39;next_branch&#39;: kwargs.get(&#39;next_branch&#39;, -1),
            &#39;next_septa&#39;: kwargs.get(&#39;next_septa&#39;, -1),
            &#39;previous_septa&#39;: kwargs.get(&#39;previous_septa&#39;, -1),
        }

        # ensure that these come in the correct order
        return CellData.create_cell_tuple(**kwargs) + tuple(
            [initializer[key] for key, *_ in AfumigatusCellData.AFUMIGATUS_FIELDS]
        )

    @classmethod
    def initial_boolean_network(cls) -&gt; np.ndarray:
        init_afumigatus_boolean_species = {
            NetworkSpecies.hapX: True,
            NetworkSpecies.sreA: False,
            NetworkSpecies.HapX: True,
            NetworkSpecies.SreA: False,
            NetworkSpecies.RIA: True,
            NetworkSpecies.EstB: True,
            NetworkSpecies.MirB: True,
            NetworkSpecies.SidA: True,
            NetworkSpecies.TAFC: True,
            NetworkSpecies.ICP: False,
            NetworkSpecies.LIP: False,
            NetworkSpecies.CccA: False,
            NetworkSpecies.FC0fe: True,
            NetworkSpecies.FC1fe: False,
            NetworkSpecies.VAC: False,
            NetworkSpecies.ROS: False,
            NetworkSpecies.Yap1: False,
            NetworkSpecies.SOD2_3: False,
            NetworkSpecies.Cat1_2: False,
            NetworkSpecies.ThP: False,
            NetworkSpecies.Fe: False,
            NetworkSpecies.Oxygen: False,
        }
        return np.asarray(
            [init_afumigatus_boolean_species[species] for species in NetworkSpecies], dtype=bool
        )


@attrs(kw_only=True, frozen=True, repr=False)
class AfumigatusCellList(CellList):
    CellDataClass = AfumigatusCellData


def cell_list_factory(self: &#39;AfumigatusState&#39;) -&gt; AfumigatusCellList:
    return AfumigatusCellList(grid=self.global_state.grid)


@attrs(kw_only=True)
class AfumigatusState(ModuleState):
    cells: AfumigatusCellList = attrib(default=attr.Factory(cell_list_factory, takes_self=True))
    pr_ma_hyphae: float  # units: probability
    pr_ma_hyphae_param: float  # units: M
    pr_ma_phag: float  # units: probability
    pr_ma_phag_param: float  # units: M
    pr_branch: float  # units: probability
    steps_to_bn_eval: int  # units: steps
    hyphal_length: float  # units: µm
    hyphae_volume: float  # units: L
    conidia_vol: float  # units: L
    kd_lip: float  # units: aM
    init_iron: float  # units: atto-mol
    time_to_swelling: float  # units: hours
    iter_to_swelling: int  # units: steps
    time_to_germinate: float  # units: hours
    iter_to_germinate: int  # units: steps
    time_to_grow: float  # units: hours
    iter_to_grow: int  # units: steps
    pr_aspergillus_change: float
    rel_phag_affinity_unit_t: float
    phag_affinity_t: float
    aspergillus_change_half_life: float  # units: hours


class Afumigatus(ModuleModel):
    name = &#39;afumigatus&#39;
    StateClass = AfumigatusState

    from nlisim.modules.macrophage import MacrophageCellData, MacrophageState

    def initialize(self, state: State):
        afumigatus: AfumigatusState = state.afumigatus
        voxel_volume = state.voxel_volume  # units: L
        lung_tissue = state.lung_tissue

        afumigatus.pr_ma_hyphae_param = self.config.getfloat(&#39;pr_ma_hyphae_param&#39;)
        afumigatus.pr_ma_phag_param = self.config.getfloat(&#39;pr_ma_phag_param&#39;)
        afumigatus.phag_affinity_t = self.config.getfloat(&#39;phag_affinity_t&#39;)

        afumigatus.pr_branch = self.config.getfloat(&#39;pr_branch&#39;)  # units: probability
        afumigatus.steps_to_bn_eval = self.config.getint(&#39;steps_to_bn_eval&#39;)  # units: steps

        afumigatus.conidia_vol = self.config.getfloat(&#39;conidia_vol&#39;)  # units: L
        afumigatus.hyphae_volume = self.config.getfloat(&#39;hyphae_volume&#39;)  # units: L
        afumigatus.hyphal_length = self.config.getfloat(&#39;hyphal_length&#39;)  # units: µm

        afumigatus.kd_lip = self.config.getfloat(&#39;kd_lip&#39;)  # units: aM

        afumigatus.time_to_swelling = self.config.getfloat(&#39;time_to_swelling&#39;)  # units: hours
        afumigatus.time_to_germinate = self.config.getfloat(&#39;time_to_germinate&#39;)  # units: hours
        afumigatus.time_to_grow = self.config.getfloat(&#39;time_to_grow&#39;)  # units: hours
        afumigatus.aspergillus_change_half_life = self.config.getfloat(
            &#39;aspergillus_change_half_life&#39;
        )  # units: hours

        # computed values
        afumigatus.init_iron = afumigatus.kd_lip * afumigatus.conidia_vol  # units: aM*L = atto-mols

        afumigatus.rel_phag_affinity_unit_t = self.time_step / afumigatus.phag_affinity_t

        afumigatus.pr_ma_hyphae = -math.expm1(
            -afumigatus.rel_phag_affinity_unit_t / (afumigatus.pr_ma_hyphae_param * voxel_volume)
        )  # exponent units:  ?/(?*L) = TODO
        afumigatus.pr_ma_phag = -math.expm1(
            -afumigatus.rel_phag_affinity_unit_t / (voxel_volume * afumigatus.pr_ma_phag_param)
        )  # exponent units:  ?/(?*L) = TODO

        afumigatus.iter_to_swelling = max(
            0, int(afumigatus.time_to_swelling * (60 / self.time_step) - 2)
        )  # units: hours * (min/hour) / (min/step) = steps TODO: -2?
        afumigatus.iter_to_germinate = max(
            0, int(afumigatus.time_to_germinate * (60 / self.time_step) - 2)
        )  # units: hours * (min/hour) / (min/step) = steps TODO: -2?
        afumigatus.iter_to_grow = max(
            0, int(afumigatus.time_to_grow * 60 / self.time_step) - 1
        )  # units: hours * (min/hour) / (min/step) = steps
        afumigatus.pr_aspergillus_change = -math.log(0.5) / (
            afumigatus.aspergillus_change_half_life * (60 / self.time_step)
        )

        # place cells for initial infection
        locations = list(zip(*np.where(lung_tissue == TissueType.EPITHELIUM)))
        dz_field: np.ndarray = state.grid.delta(axis=0)
        dy_field: np.ndarray = state.grid.delta(axis=1)
        dx_field: np.ndarray = state.grid.delta(axis=2)
        for vox_z, vox_y, vox_x in random.choices(
            locations, k=self.config.getint(&#39;init_infection_num&#39;)
        ):
            # the x,y,z coordinates are in the centers of the grids
            z = state.grid.z[vox_z]
            y = state.grid.y[vox_y]
            x = state.grid.x[vox_x]
            dz = dz_field[vox_z, vox_y, vox_x]
            dy = dy_field[vox_z, vox_y, vox_x]
            dx = dx_field[vox_z, vox_y, vox_x]
            afumigatus.cells.append(
                AfumigatusCellData.create_cell(
                    point=Point(
                        x=x + rg.uniform(-dx / 2, dx / 2),
                        y=y + rg.uniform(-dy / 2, dy / 2),
                        z=z + rg.uniform(-dz / 2, dz / 2),
                    ),
                    iron_pool=afumigatus.init_iron,
                )
            )

        return state

    def advance(self, state: State, previous_time: float) -&gt; State:
        from nlisim.grid import RectangularGrid
        from nlisim.modules.macrophage import MacrophageCellData, MacrophageState, PhagocyteStatus

        afumigatus: AfumigatusState = state.afumigatus
        macrophage: MacrophageState = state.macrophage
        iron: IronState = state.iron
        grid: RectangularGrid = state.grid
        lung_tissue: np.ndarray = state.lung_tissue

        # update live cells
        for afumigatus_cell_index in afumigatus.cells.alive():
            # get cell and voxel position
            afumigatus_cell: AfumigatusCellData = afumigatus.cells[afumigatus_cell_index]
            voxel: Voxel = grid.get_voxel(afumigatus_cell[&#39;point&#39;])

            # ------------ update cell

            cell_self_update(afumigatus, afumigatus_cell, afumigatus_cell_index)

            # ------------ cell growth
            if (
                afumigatus_cell[&#39;state&#39;] == AfumigatusCellState.FREE
                and lung_tissue[tuple(voxel)] != TissueType.AIR
            ):
                elongate(
                    afumigatus_cell, afumigatus_cell_index, afumigatus.iter_to_grow, afumigatus
                )
                if afumigatus_cell[&#39;next_septa&#39;] != -1:  # only branch if we have already elongated
                    branch(afumigatus_cell, afumigatus_cell_index, afumigatus.pr_branch, afumigatus)

            # ------------ interactions after this point

            # interact with macrophages, possibly internalizing the aspergillus cell
            for macrophage_index in macrophage.cells.get_cells_in_voxel(voxel):
                macrophage_cell: MacrophageCellData = macrophage.cells[macrophage_index]

                # Only healthy macrophages can internalize
                if macrophage_cell[&#39;status&#39;] in {
                    PhagocyteStatus.APOPTOTIC,
                    PhagocyteStatus.NECROTIC,
                    PhagocyteStatus.DEAD,
                }:
                    continue

                Afumigatus.fungus_macrophage_interaction(
                    afumigatus=afumigatus,
                    afumigatus_cell=afumigatus_cell,
                    afumigatus_cell_index=afumigatus_cell_index,
                    macrophage=macrophage,
                    macrophage_cell=macrophage_cell,
                    macrophage_cell_index=macrophage_index,
                    iron=iron,
                    grid=grid,
                )

            # -----------

        return state

    @staticmethod
    def fungus_macrophage_interaction(
        afumigatus: AfumigatusState,
        afumigatus_cell: AfumigatusCellData,
        afumigatus_cell_index: int,
        macrophage: &#39;MacrophageState&#39;,
        macrophage_cell: &#39;MacrophageCellData&#39;,
        macrophage_cell_index: int,
        iron: IronState,
        grid: RectangularGrid,
    ):
        from nlisim.modules.macrophage import PhagocyteStatus

        probability_of_interaction = (
            afumigatus.pr_ma_hyphae
            if afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE
            else afumigatus.pr_ma_phag
        )

        # return if they do not interact
        if rg.random() &gt;= probability_of_interaction:
            return

        # now they interact

        interact_with_aspergillus(
            phagocyte_cell=macrophage_cell,
            phagocyte_cell_index=macrophage_cell_index,
            phagocyte_cells=macrophage.cells,
            aspergillus_cell=afumigatus_cell,
            aspergillus_cell_index=afumigatus_cell_index,
            phagocyte=macrophage,
            phagocytize=afumigatus_cell[&#39;status&#39;] != AfumigatusCellStatus.HYPHAE,
        )

        # unlink the fungal cell from its tree
        if (
            afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE
            and macrophage_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE
        ):
            Afumigatus.kill_fungal_cell(
                afumigatus, afumigatus_cell, afumigatus_cell_index, iron, grid
            )

    @staticmethod
    def kill_fungal_cell(
        afumigatus: AfumigatusState,
        afumigatus_cell: AfumigatusCellData,
        afumigatus_cell_index: int,
        iron: IronState,
        grid: RectangularGrid,
    ):
        &#34;&#34;&#34;Kill a fungal cell.

        Unlinks the cell from its fungal tree and releases its iron.
        &#34;&#34;&#34;
        # unlink from any children
        if afumigatus_cell[&#39;next_septa&#39;] != -1:
            next_septa = afumigatus_cell[&#39;next_septa&#39;]
            afumigatus_cell[&#39;next_septa&#39;] = -1
            afumigatus.cells[next_septa][&#39;is_root&#39;] = True
            afumigatus.cells[next_septa][&#39;previous_septa&#39;] = -1
        if afumigatus_cell[&#39;next_branch&#39;] != -1:
            next_branch = afumigatus_cell[&#39;next_branch&#39;]
            afumigatus_cell[&#39;next_branch&#39;] = -1
            afumigatus.cells[next_branch][&#39;is_root&#39;] = True
            afumigatus.cells[next_branch][&#39;previous_septa&#39;] = -1

        # unlink from parent, if exists
        parent_id = afumigatus_cell[&#39;previous_septa&#39;]
        if parent_id != -1:
            afumigatus_cell[&#39;previous_septa&#39;] = -1
            parent_cell: AfumigatusCellData = afumigatus.cells[parent_id]
            if parent_cell[&#39;next_septa&#39;] == afumigatus_cell_index:
                parent_cell[&#39;next_septa&#39;] = -1
            elif parent_cell[&#39;next_branch&#39;] == afumigatus_cell_index:
                parent_cell[&#39;next_branch&#39;] = -1
            else:
                raise AssertionError(&#34;The fungal tree structure is malformed.&#34;)

        # kill the cell off and release its iron
        voxel: Voxel = grid.get_voxel(afumigatus_cell[&#39;point&#39;])
        iron.grid[voxel.z, voxel.y, voxel.x] += afumigatus_cell[&#39;iron_pool&#39;]
        afumigatus_cell[&#39;iron_pool&#39;] = 0.0
        afumigatus_cell[&#39;dead&#39;] = True
        afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.DEAD

    def summary_stats(self, state: State) -&gt; Dict[str, Any]:
        afumigatus: AfumigatusState = state.afumigatus
        live_fungus = afumigatus.cells.alive()

        max_index = max(map(int, AfumigatusCellStatus))
        status_counts = np.bincount(
            np.fromiter(
                (
                    afumigatus.cells[afumigatus_cell_index][&#39;status&#39;]
                    for afumigatus_cell_index in live_fungus
                ),
                dtype=np.uint8,
            ),
            minlength=max_index + 1,
        )

        lip_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.LIP
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        mirb_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.MirB
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        estb_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.EstB
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        tafc_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.TAFC
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        return {
            &#39;count&#39;: len(live_fungus),
            &#39;resting conidia&#39;: int(status_counts[AfumigatusCellStatus.RESTING_CONIDIA]),
            &#39;swelling conidia&#39;: int(status_counts[AfumigatusCellStatus.SWELLING_CONIDIA]),
            &#39;sterile conidia&#39;: int(status_counts[AfumigatusCellStatus.STERILE_CONIDIA]),
            &#39;germ tube&#39;: int(status_counts[AfumigatusCellStatus.GERM_TUBE]),
            &#39;hyphae&#39;: int(status_counts[AfumigatusCellStatus.HYPHAE]),
            &#39;LIP active&#39;: lip_active,
            &#39;MirB active&#39;: mirb_active,
            &#39;EstB active&#39;: estb_active,
            &#39;TAFC active&#39;: tafc_active,
        }

    def visualization_data(self, state: State):
        return &#39;cells&#39;, state.afumigatus.cells


def cell_self_update(
    afumigatus: AfumigatusState,
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
) -&gt; None:
    afumigatus_cell[&#39;activation_iteration&#39;] += 1

    process_boolean_network(
        afumigatus_cell=afumigatus_cell,
        steps_to_eval=afumigatus.steps_to_bn_eval,
        afumigatus=afumigatus,
    )

    # resting conidia become swelling conidia after a number of iterations
    # (with some probability)
    if (
        afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.RESTING_CONIDIA
        and afumigatus_cell[&#39;activation_iteration&#39;] &gt;= afumigatus.iter_to_swelling
        and rg.random() &lt; afumigatus.pr_aspergillus_change
    ):
        afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.SWELLING_CONIDIA
        afumigatus_cell[&#39;activation_iteration&#39;] = 0

    elif (
        afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.SWELLING_CONIDIA
        and afumigatus_cell[&#39;activation_iteration&#39;] &gt;= afumigatus.iter_to_germinate
    ):
        afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.GERM_TUBE
        afumigatus_cell[&#39;activation_iteration&#39;] = 0

    # TODO: verify this, 1 turn on internalizing then free?
    if afumigatus_cell[&#39;state&#39;] in {
        AfumigatusCellState.INTERNALIZING,
        AfumigatusCellState.RELEASING,
    }:
        afumigatus_cell[&#39;state&#39;] = AfumigatusCellState.FREE

    # Distribute iron evenly within fungal tree.
    # Note: called for every cell, but a no-op on non-root cells.
    diffuse_iron(afumigatus_cell_index, afumigatus)


def process_boolean_network(
    afumigatus: AfumigatusState,
    afumigatus_cell: AfumigatusCellData,
    steps_to_eval: int,
):
    afumigatus_cell[&#39;bn_iteration&#39;] += 1
    afumigatus_cell[&#39;bn_iteration&#39;] %= steps_to_eval

    if afumigatus_cell[&#39;bn_iteration&#39;] != 0:
        return

    bool_net = afumigatus_cell[&#39;boolean_network&#39;]

    temp: np.ndarray = np.zeros(shape=bool_net.shape, dtype=bool)

    temp[NetworkSpecies.hapX] = ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.sreA] = ~bool_net[NetworkSpecies.HapX]
    temp[NetworkSpecies.HapX] = bool_net[NetworkSpecies.hapX] &amp; ~bool_net[NetworkSpecies.LIP]
    temp[NetworkSpecies.SreA] = bool_net[NetworkSpecies.sreA] &amp; bool_net[NetworkSpecies.LIP]
    temp[NetworkSpecies.RIA] = ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.EstB] = ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.MirB] = bool_net[NetworkSpecies.HapX] &amp; ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.SidA] = bool_net[NetworkSpecies.HapX] &amp; ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.TAFC] = bool_net[NetworkSpecies.SidA]
    temp[NetworkSpecies.ICP] = ~bool_net[NetworkSpecies.HapX] &amp; (
        bool_net[NetworkSpecies.VAC] | bool_net[NetworkSpecies.FC1fe]
    )
    temp[NetworkSpecies.LIP] = (
        bool_net[NetworkSpecies.Fe] &amp; bool_net[NetworkSpecies.RIA]
    ) | lip_activation(afumigatus=afumigatus, iron_pool=afumigatus_cell[&#39;iron_pool&#39;])
    temp[NetworkSpecies.CccA] = ~bool_net[NetworkSpecies.HapX]
    temp[NetworkSpecies.FC0fe] = bool_net[NetworkSpecies.SidA]
    temp[NetworkSpecies.FC1fe] = bool_net[NetworkSpecies.LIP] &amp; bool_net[NetworkSpecies.FC0fe]
    temp[NetworkSpecies.VAC] = bool_net[NetworkSpecies.LIP] &amp; bool_net[NetworkSpecies.CccA]
    temp[NetworkSpecies.ROS] = (
        bool_net[NetworkSpecies.Oxygen]
        &amp; ~(
            bool_net[NetworkSpecies.SOD2_3]
            &amp; bool_net[NetworkSpecies.ThP]
            &amp; bool_net[NetworkSpecies.Cat1_2]
        )
    ) | (
        bool_net[NetworkSpecies.ROS]
        &amp; ~(
            bool_net[NetworkSpecies.SOD2_3]
            &amp; (bool_net[NetworkSpecies.ThP] | bool_net[NetworkSpecies.Cat1_2])
        )
    )
    temp[NetworkSpecies.Yap1] = bool_net[NetworkSpecies.ROS]
    temp[NetworkSpecies.SOD2_3] = bool_net[NetworkSpecies.Yap1]
    temp[NetworkSpecies.Cat1_2] = bool_net[NetworkSpecies.Yap1] &amp; ~bool_net[NetworkSpecies.HapX]
    temp[NetworkSpecies.ThP] = bool_net[NetworkSpecies.Yap1]
    temp[NetworkSpecies.Fe] = 0  # might change according to iron environment?
    temp[NetworkSpecies.Oxygen] = 0

    # copy temp back to bool_net
    np.copyto(dst=bool_net, src=temp)


def diffuse_iron(root_cell_index: int, afumigatus: AfumigatusState) -&gt; None:
    &#34;&#34;&#34;
    Evenly distributes iron amongst fungal cells in a tree

    Parameters
    ----------
    root_cell_index : int
        index of tree root, function is a noop on non-root cells
    afumigatus : AfumigatusState
        state class for fungus
    Returns
    -------

    &#34;&#34;&#34;
    if not afumigatus.cells[root_cell_index][&#39;is_root&#39;]:
        return

    tree_cells = set()
    total_iron: float = 0.0

    # walk along the tree, collecting iron
    q: Queue = Queue()
    q.put(root_cell_index)
    while not q.empty():
        next_cell_index = q.get()
        tree_cells.add(next_cell_index)

        next_cell = afumigatus.cells[next_cell_index]
        total_iron += next_cell[&#39;iron_pool&#39;]

        if next_cell[&#39;next_branch&#39;] &gt;= 0:
            q.put(next_cell[&#39;next_branch&#39;])
        if next_cell[&#39;next_septa&#39;] &gt;= 0:
            q.put(next_cell[&#39;next_septa&#39;])

    # distribute the iron evenly
    iron_per_cell: float = total_iron / len(tree_cells)
    for tree_cell_index in tree_cells:
        afumigatus.cells[tree_cell_index][&#39;iron_pool&#39;] = iron_per_cell


def lip_activation(afumigatus: AfumigatusState, iron_pool: float) -&gt; bool:
    molar_concentration = iron_pool / afumigatus.hyphae_volume
    activation = 1 - np.exp(-molar_concentration / afumigatus.kd_lip)
    return bool(rg.random() &lt; activation)


def elongate(
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
    iter_to_grow: int,
    afumigatus: AfumigatusState,
):
    if (
        afumigatus_cell[&#39;next_septa&#39;] != -1  # already has a next septa
        or not afumigatus_cell[&#39;boolean_network&#39;][NetworkSpecies.LIP]
    ):
        return

    hyphal_length: float = afumigatus.hyphal_length
    if afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE:
        if afumigatus_cell[&#39;growth_iteration&#39;] &lt; iter_to_grow:
            afumigatus_cell[&#39;growth_iteration&#39;] += 1
        else:
            afumigatus_cell[&#39;growth_iteration&#39;] = 0
            afumigatus_cell[&#39;iron_pool&#39;] /= 2.0
            next_septa_center_point = (
                afumigatus_cell[&#39;point&#39;] + hyphal_length * afumigatus_cell[&#39;vec&#39;]
            )  # center to center is two half hyphal lengths

            # create the new septa
            next_septa: CellData = AfumigatusCellData.create_cell(
                point=Point(
                    x=next_septa_center_point[2],
                    y=next_septa_center_point[1],
                    z=next_septa_center_point[0],
                ),
                vec=afumigatus_cell[&#39;vec&#39;],
                iron_pool=0,
                status=AfumigatusCellStatus.HYPHAE,
                state=afumigatus_cell[&#39;state&#39;],
                is_root=False,
            )
            next_septa_id: int = afumigatus.cells.append(next_septa)

            # link the septae together
            afumigatus_cell[&#39;next_septa&#39;] = next_septa_id
            next_septa[&#39;previous_septa&#39;] = afumigatus_cell_index

    elif afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.GERM_TUBE:
        if afumigatus_cell[&#39;growth_iteration&#39;] &lt; iter_to_grow:
            afumigatus_cell[&#39;growth_iteration&#39;] += 1
        else:
            afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.HYPHAE
            # center of cell moves
            afumigatus_cell[&#39;point&#39;] += (hyphal_length / 2) * afumigatus_cell[&#39;vec&#39;]
            afumigatus.cells.update_voxel_index([afumigatus_cell_index])


def branch(
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
    pr_branch: float,
    afumigatus: AfumigatusState,
):
    if (
        afumigatus_cell[&#39;next_branch&#39;] != -1  # if it already has a branch
        or afumigatus_cell[&#39;status&#39;] != AfumigatusCellStatus.HYPHAE
        or not afumigatus_cell[&#39;boolean_network&#39;][NetworkSpecies.LIP]
    ):
        return

    hyphal_length: float = afumigatus.hyphal_length
    if rg.random() &lt; pr_branch:
        # now we branch
        branch_vector = generate_branch_direction(cell_vec=afumigatus_cell[&#39;vec&#39;])
        branch_center_point = (
            afumigatus_cell[&#39;point&#39;]
            + (hyphal_length / 2) * afumigatus_cell[&#39;vec&#39;]
            + (hyphal_length / 2) * branch_vector
        )  # center of new branch is offset by rest (half) of this septa and half of the new septa

        # create the new septa
        next_branch: CellData = AfumigatusCellData.create_cell(
            point=Point(
                x=branch_center_point[2], y=branch_center_point[1], z=branch_center_point[0]
            ),
            vec=branch_vector,
            growth_iteration=-1,
            iron_pool=0,
            status=AfumigatusCellStatus.HYPHAE,
            state=afumigatus_cell[&#39;state&#39;],
            is_root=False,
        )
        next_branch_id: int = afumigatus.cells.append(next_branch)

        # link them together
        afumigatus_cell[&#39;next_branch&#39;] = next_branch_id
        next_branch[&#39;previous_septa&#39;] = afumigatus_cell_index


def generate_branch_direction(cell_vec: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate a direction vector for branches.

    Parameters
    ----------
    cell_vec : np.ndarray
        a unit 3-vector

    Returns
    -------
    np.ndarray
        a random unit 3-vector at a 45 degree angle to `cell_vec`, sampled from the
        uniform distribution
    &#34;&#34;&#34;
    # norm should be approx 1, can delete for performance
    cell_vec /= np.linalg.norm(cell_vec)

    # create orthogonal basis adapted to cell&#39;s direction
    # get first orthogonal vector
    u: np.ndarray
    epsilon = 0.1
    e1 = np.array([1.0, 0.0, 0.0], dtype=np.float64)
    e2 = np.array([0.0, 1.0, 0.0], dtype=np.float64)
    # if the cell vector isn&#39;t too close to +/- e1, generate the orthogonal vector using the cross
    # product with e1. otherwise use e2. (we can&#39;t be too close to both)
    u = (
        np.cross(cell_vec, e1)
        if (np.linalg.norm(cell_vec - e1) &gt; epsilon and np.linalg.norm(cell_vec + e1) &gt; epsilon)
        else np.cross(cell_vec, e2)
    )
    u /= np.linalg.norm(u)  # unlike the other normalizations, this is non-optional

    # get second orthogonal vector, orthogonal to both the cell vec and the first orthogonal vector
    v = np.cross(cell_vec, u)
    # norm should be approx 1, can delete for performance
    v /= np.linalg.norm(v)

    # change of coordinates matrix
    p_matrix = np.array([cell_vec, u, v]).T

    # form a random unit vector on a 45 degree cone
    theta = rg.random() * 2 * np.pi
    branch_direction = p_matrix @ np.array([1.0, np.cos(theta), np.sin(theta)]) / np.sqrt(2)
    # norm should be approx 1, can delete for performance
    branch_direction /= np.linalg.norm(branch_direction)

    return branch_direction</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nlisim.modules.afumigatus.branch"><code class="name flex">
<span>def <span class="ident">branch</span></span>(<span>afumigatus_cell: <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a>, afumigatus_cell_index: int, pr_branch: float, afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def branch(
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
    pr_branch: float,
    afumigatus: AfumigatusState,
):
    if (
        afumigatus_cell[&#39;next_branch&#39;] != -1  # if it already has a branch
        or afumigatus_cell[&#39;status&#39;] != AfumigatusCellStatus.HYPHAE
        or not afumigatus_cell[&#39;boolean_network&#39;][NetworkSpecies.LIP]
    ):
        return

    hyphal_length: float = afumigatus.hyphal_length
    if rg.random() &lt; pr_branch:
        # now we branch
        branch_vector = generate_branch_direction(cell_vec=afumigatus_cell[&#39;vec&#39;])
        branch_center_point = (
            afumigatus_cell[&#39;point&#39;]
            + (hyphal_length / 2) * afumigatus_cell[&#39;vec&#39;]
            + (hyphal_length / 2) * branch_vector
        )  # center of new branch is offset by rest (half) of this septa and half of the new septa

        # create the new septa
        next_branch: CellData = AfumigatusCellData.create_cell(
            point=Point(
                x=branch_center_point[2], y=branch_center_point[1], z=branch_center_point[0]
            ),
            vec=branch_vector,
            growth_iteration=-1,
            iron_pool=0,
            status=AfumigatusCellStatus.HYPHAE,
            state=afumigatus_cell[&#39;state&#39;],
            is_root=False,
        )
        next_branch_id: int = afumigatus.cells.append(next_branch)

        # link them together
        afumigatus_cell[&#39;next_branch&#39;] = next_branch_id
        next_branch[&#39;previous_septa&#39;] = afumigatus_cell_index</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.cell_list_factory"><code class="name flex">
<span>def <span class="ident">cell_list_factory</span></span>(<span>self: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>) ‑> <a title="nlisim.modules.afumigatus.AfumigatusCellList" href="#nlisim.modules.afumigatus.AfumigatusCellList">AfumigatusCellList</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_list_factory(self: &#39;AfumigatusState&#39;) -&gt; AfumigatusCellList:
    return AfumigatusCellList(grid=self.global_state.grid)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.cell_self_update"><code class="name flex">
<span>def <span class="ident">cell_self_update</span></span>(<span>afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>, afumigatus_cell: <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a>, afumigatus_cell_index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cell_self_update(
    afumigatus: AfumigatusState,
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
) -&gt; None:
    afumigatus_cell[&#39;activation_iteration&#39;] += 1

    process_boolean_network(
        afumigatus_cell=afumigatus_cell,
        steps_to_eval=afumigatus.steps_to_bn_eval,
        afumigatus=afumigatus,
    )

    # resting conidia become swelling conidia after a number of iterations
    # (with some probability)
    if (
        afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.RESTING_CONIDIA
        and afumigatus_cell[&#39;activation_iteration&#39;] &gt;= afumigatus.iter_to_swelling
        and rg.random() &lt; afumigatus.pr_aspergillus_change
    ):
        afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.SWELLING_CONIDIA
        afumigatus_cell[&#39;activation_iteration&#39;] = 0

    elif (
        afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.SWELLING_CONIDIA
        and afumigatus_cell[&#39;activation_iteration&#39;] &gt;= afumigatus.iter_to_germinate
    ):
        afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.GERM_TUBE
        afumigatus_cell[&#39;activation_iteration&#39;] = 0

    # TODO: verify this, 1 turn on internalizing then free?
    if afumigatus_cell[&#39;state&#39;] in {
        AfumigatusCellState.INTERNALIZING,
        AfumigatusCellState.RELEASING,
    }:
        afumigatus_cell[&#39;state&#39;] = AfumigatusCellState.FREE

    # Distribute iron evenly within fungal tree.
    # Note: called for every cell, but a no-op on non-root cells.
    diffuse_iron(afumigatus_cell_index, afumigatus)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.diffuse_iron"><code class="name flex">
<span>def <span class="ident">diffuse_iron</span></span>(<span>root_cell_index: int, afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Evenly distributes iron amongst fungal cells in a tree</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>root_cell_index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of tree root, function is a noop on non-root cells</dd>
<dt><strong><code>afumigatus</code></strong> :&ensp;<code><a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a></code></dt>
<dd>state class for fungus</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diffuse_iron(root_cell_index: int, afumigatus: AfumigatusState) -&gt; None:
    &#34;&#34;&#34;
    Evenly distributes iron amongst fungal cells in a tree

    Parameters
    ----------
    root_cell_index : int
        index of tree root, function is a noop on non-root cells
    afumigatus : AfumigatusState
        state class for fungus
    Returns
    -------

    &#34;&#34;&#34;
    if not afumigatus.cells[root_cell_index][&#39;is_root&#39;]:
        return

    tree_cells = set()
    total_iron: float = 0.0

    # walk along the tree, collecting iron
    q: Queue = Queue()
    q.put(root_cell_index)
    while not q.empty():
        next_cell_index = q.get()
        tree_cells.add(next_cell_index)

        next_cell = afumigatus.cells[next_cell_index]
        total_iron += next_cell[&#39;iron_pool&#39;]

        if next_cell[&#39;next_branch&#39;] &gt;= 0:
            q.put(next_cell[&#39;next_branch&#39;])
        if next_cell[&#39;next_septa&#39;] &gt;= 0:
            q.put(next_cell[&#39;next_septa&#39;])

    # distribute the iron evenly
    iron_per_cell: float = total_iron / len(tree_cells)
    for tree_cell_index in tree_cells:
        afumigatus.cells[tree_cell_index][&#39;iron_pool&#39;] = iron_per_cell</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.elongate"><code class="name flex">
<span>def <span class="ident">elongate</span></span>(<span>afumigatus_cell: <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a>, afumigatus_cell_index: int, iter_to_grow: int, afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elongate(
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
    iter_to_grow: int,
    afumigatus: AfumigatusState,
):
    if (
        afumigatus_cell[&#39;next_septa&#39;] != -1  # already has a next septa
        or not afumigatus_cell[&#39;boolean_network&#39;][NetworkSpecies.LIP]
    ):
        return

    hyphal_length: float = afumigatus.hyphal_length
    if afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE:
        if afumigatus_cell[&#39;growth_iteration&#39;] &lt; iter_to_grow:
            afumigatus_cell[&#39;growth_iteration&#39;] += 1
        else:
            afumigatus_cell[&#39;growth_iteration&#39;] = 0
            afumigatus_cell[&#39;iron_pool&#39;] /= 2.0
            next_septa_center_point = (
                afumigatus_cell[&#39;point&#39;] + hyphal_length * afumigatus_cell[&#39;vec&#39;]
            )  # center to center is two half hyphal lengths

            # create the new septa
            next_septa: CellData = AfumigatusCellData.create_cell(
                point=Point(
                    x=next_septa_center_point[2],
                    y=next_septa_center_point[1],
                    z=next_septa_center_point[0],
                ),
                vec=afumigatus_cell[&#39;vec&#39;],
                iron_pool=0,
                status=AfumigatusCellStatus.HYPHAE,
                state=afumigatus_cell[&#39;state&#39;],
                is_root=False,
            )
            next_septa_id: int = afumigatus.cells.append(next_septa)

            # link the septae together
            afumigatus_cell[&#39;next_septa&#39;] = next_septa_id
            next_septa[&#39;previous_septa&#39;] = afumigatus_cell_index

    elif afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.GERM_TUBE:
        if afumigatus_cell[&#39;growth_iteration&#39;] &lt; iter_to_grow:
            afumigatus_cell[&#39;growth_iteration&#39;] += 1
        else:
            afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.HYPHAE
            # center of cell moves
            afumigatus_cell[&#39;point&#39;] += (hyphal_length / 2) * afumigatus_cell[&#39;vec&#39;]
            afumigatus.cells.update_voxel_index([afumigatus_cell_index])</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.generate_branch_direction"><code class="name flex">
<span>def <span class="ident">generate_branch_direction</span></span>(<span>cell_vec: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a direction vector for branches.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cell_vec</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>a unit 3-vector</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>a random unit 3-vector at a 45 degree angle to <code>cell_vec</code>, sampled from the
uniform distribution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_branch_direction(cell_vec: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate a direction vector for branches.

    Parameters
    ----------
    cell_vec : np.ndarray
        a unit 3-vector

    Returns
    -------
    np.ndarray
        a random unit 3-vector at a 45 degree angle to `cell_vec`, sampled from the
        uniform distribution
    &#34;&#34;&#34;
    # norm should be approx 1, can delete for performance
    cell_vec /= np.linalg.norm(cell_vec)

    # create orthogonal basis adapted to cell&#39;s direction
    # get first orthogonal vector
    u: np.ndarray
    epsilon = 0.1
    e1 = np.array([1.0, 0.0, 0.0], dtype=np.float64)
    e2 = np.array([0.0, 1.0, 0.0], dtype=np.float64)
    # if the cell vector isn&#39;t too close to +/- e1, generate the orthogonal vector using the cross
    # product with e1. otherwise use e2. (we can&#39;t be too close to both)
    u = (
        np.cross(cell_vec, e1)
        if (np.linalg.norm(cell_vec - e1) &gt; epsilon and np.linalg.norm(cell_vec + e1) &gt; epsilon)
        else np.cross(cell_vec, e2)
    )
    u /= np.linalg.norm(u)  # unlike the other normalizations, this is non-optional

    # get second orthogonal vector, orthogonal to both the cell vec and the first orthogonal vector
    v = np.cross(cell_vec, u)
    # norm should be approx 1, can delete for performance
    v /= np.linalg.norm(v)

    # change of coordinates matrix
    p_matrix = np.array([cell_vec, u, v]).T

    # form a random unit vector on a 45 degree cone
    theta = rg.random() * 2 * np.pi
    branch_direction = p_matrix @ np.array([1.0, np.cos(theta), np.sin(theta)]) / np.sqrt(2)
    # norm should be approx 1, can delete for performance
    branch_direction /= np.linalg.norm(branch_direction)

    return branch_direction</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.lip_activation"><code class="name flex">
<span>def <span class="ident">lip_activation</span></span>(<span>afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>, iron_pool: float) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lip_activation(afumigatus: AfumigatusState, iron_pool: float) -&gt; bool:
    molar_concentration = iron_pool / afumigatus.hyphae_volume
    activation = 1 - np.exp(-molar_concentration / afumigatus.kd_lip)
    return bool(rg.random() &lt; activation)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.process_boolean_network"><code class="name flex">
<span>def <span class="ident">process_boolean_network</span></span>(<span>afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>, afumigatus_cell: <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a>, steps_to_eval: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_boolean_network(
    afumigatus: AfumigatusState,
    afumigatus_cell: AfumigatusCellData,
    steps_to_eval: int,
):
    afumigatus_cell[&#39;bn_iteration&#39;] += 1
    afumigatus_cell[&#39;bn_iteration&#39;] %= steps_to_eval

    if afumigatus_cell[&#39;bn_iteration&#39;] != 0:
        return

    bool_net = afumigatus_cell[&#39;boolean_network&#39;]

    temp: np.ndarray = np.zeros(shape=bool_net.shape, dtype=bool)

    temp[NetworkSpecies.hapX] = ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.sreA] = ~bool_net[NetworkSpecies.HapX]
    temp[NetworkSpecies.HapX] = bool_net[NetworkSpecies.hapX] &amp; ~bool_net[NetworkSpecies.LIP]
    temp[NetworkSpecies.SreA] = bool_net[NetworkSpecies.sreA] &amp; bool_net[NetworkSpecies.LIP]
    temp[NetworkSpecies.RIA] = ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.EstB] = ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.MirB] = bool_net[NetworkSpecies.HapX] &amp; ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.SidA] = bool_net[NetworkSpecies.HapX] &amp; ~bool_net[NetworkSpecies.SreA]
    temp[NetworkSpecies.TAFC] = bool_net[NetworkSpecies.SidA]
    temp[NetworkSpecies.ICP] = ~bool_net[NetworkSpecies.HapX] &amp; (
        bool_net[NetworkSpecies.VAC] | bool_net[NetworkSpecies.FC1fe]
    )
    temp[NetworkSpecies.LIP] = (
        bool_net[NetworkSpecies.Fe] &amp; bool_net[NetworkSpecies.RIA]
    ) | lip_activation(afumigatus=afumigatus, iron_pool=afumigatus_cell[&#39;iron_pool&#39;])
    temp[NetworkSpecies.CccA] = ~bool_net[NetworkSpecies.HapX]
    temp[NetworkSpecies.FC0fe] = bool_net[NetworkSpecies.SidA]
    temp[NetworkSpecies.FC1fe] = bool_net[NetworkSpecies.LIP] &amp; bool_net[NetworkSpecies.FC0fe]
    temp[NetworkSpecies.VAC] = bool_net[NetworkSpecies.LIP] &amp; bool_net[NetworkSpecies.CccA]
    temp[NetworkSpecies.ROS] = (
        bool_net[NetworkSpecies.Oxygen]
        &amp; ~(
            bool_net[NetworkSpecies.SOD2_3]
            &amp; bool_net[NetworkSpecies.ThP]
            &amp; bool_net[NetworkSpecies.Cat1_2]
        )
    ) | (
        bool_net[NetworkSpecies.ROS]
        &amp; ~(
            bool_net[NetworkSpecies.SOD2_3]
            &amp; (bool_net[NetworkSpecies.ThP] | bool_net[NetworkSpecies.Cat1_2])
        )
    )
    temp[NetworkSpecies.Yap1] = bool_net[NetworkSpecies.ROS]
    temp[NetworkSpecies.SOD2_3] = bool_net[NetworkSpecies.Yap1]
    temp[NetworkSpecies.Cat1_2] = bool_net[NetworkSpecies.Yap1] &amp; ~bool_net[NetworkSpecies.HapX]
    temp[NetworkSpecies.ThP] = bool_net[NetworkSpecies.Yap1]
    temp[NetworkSpecies.Fe] = 0  # might change according to iron environment?
    temp[NetworkSpecies.Oxygen] = 0

    # copy temp back to bool_net
    np.copyto(dst=bool_net, src=temp)</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.random_sphere_point"><code class="name flex">
<span>def <span class="ident">random_sphere_point</span></span>(<span>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a random point on the unit 2-sphere in R^3 using Marsaglia's method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_sphere_point() -&gt; np.ndarray:
    &#34;&#34;&#34;Generate a random point on the unit 2-sphere in R^3 using Marsaglia&#39;s method&#34;&#34;&#34;
    # generate vector in unit disc
    u: np.ndarray = 2 * rg.random(size=2) - 1
    while np.linalg.norm(u) &gt; 1.0:
        u = 2 * rg.random(size=2) - 1

    norm_squared_u = float(np.dot(u, u))
    return np.array(
        [
            2 * u[0] * np.sqrt(1 - norm_squared_u),
            2 * u[1] * np.sqrt(1 - norm_squared_u),
            1 - 2 * norm_squared_u,
        ],
        dtype=np.float64,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nlisim.modules.afumigatus.Afumigatus"><code class="flex name class">
<span>class <span class="ident">Afumigatus</span></span>
<span>(</span><span>config: <a title="nlisim.config.SimulationConfig" href="../config.html#nlisim.config.SimulationConfig">SimulationConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Afumigatus(ModuleModel):
    name = &#39;afumigatus&#39;
    StateClass = AfumigatusState

    from nlisim.modules.macrophage import MacrophageCellData, MacrophageState

    def initialize(self, state: State):
        afumigatus: AfumigatusState = state.afumigatus
        voxel_volume = state.voxel_volume  # units: L
        lung_tissue = state.lung_tissue

        afumigatus.pr_ma_hyphae_param = self.config.getfloat(&#39;pr_ma_hyphae_param&#39;)
        afumigatus.pr_ma_phag_param = self.config.getfloat(&#39;pr_ma_phag_param&#39;)
        afumigatus.phag_affinity_t = self.config.getfloat(&#39;phag_affinity_t&#39;)

        afumigatus.pr_branch = self.config.getfloat(&#39;pr_branch&#39;)  # units: probability
        afumigatus.steps_to_bn_eval = self.config.getint(&#39;steps_to_bn_eval&#39;)  # units: steps

        afumigatus.conidia_vol = self.config.getfloat(&#39;conidia_vol&#39;)  # units: L
        afumigatus.hyphae_volume = self.config.getfloat(&#39;hyphae_volume&#39;)  # units: L
        afumigatus.hyphal_length = self.config.getfloat(&#39;hyphal_length&#39;)  # units: µm

        afumigatus.kd_lip = self.config.getfloat(&#39;kd_lip&#39;)  # units: aM

        afumigatus.time_to_swelling = self.config.getfloat(&#39;time_to_swelling&#39;)  # units: hours
        afumigatus.time_to_germinate = self.config.getfloat(&#39;time_to_germinate&#39;)  # units: hours
        afumigatus.time_to_grow = self.config.getfloat(&#39;time_to_grow&#39;)  # units: hours
        afumigatus.aspergillus_change_half_life = self.config.getfloat(
            &#39;aspergillus_change_half_life&#39;
        )  # units: hours

        # computed values
        afumigatus.init_iron = afumigatus.kd_lip * afumigatus.conidia_vol  # units: aM*L = atto-mols

        afumigatus.rel_phag_affinity_unit_t = self.time_step / afumigatus.phag_affinity_t

        afumigatus.pr_ma_hyphae = -math.expm1(
            -afumigatus.rel_phag_affinity_unit_t / (afumigatus.pr_ma_hyphae_param * voxel_volume)
        )  # exponent units:  ?/(?*L) = TODO
        afumigatus.pr_ma_phag = -math.expm1(
            -afumigatus.rel_phag_affinity_unit_t / (voxel_volume * afumigatus.pr_ma_phag_param)
        )  # exponent units:  ?/(?*L) = TODO

        afumigatus.iter_to_swelling = max(
            0, int(afumigatus.time_to_swelling * (60 / self.time_step) - 2)
        )  # units: hours * (min/hour) / (min/step) = steps TODO: -2?
        afumigatus.iter_to_germinate = max(
            0, int(afumigatus.time_to_germinate * (60 / self.time_step) - 2)
        )  # units: hours * (min/hour) / (min/step) = steps TODO: -2?
        afumigatus.iter_to_grow = max(
            0, int(afumigatus.time_to_grow * 60 / self.time_step) - 1
        )  # units: hours * (min/hour) / (min/step) = steps
        afumigatus.pr_aspergillus_change = -math.log(0.5) / (
            afumigatus.aspergillus_change_half_life * (60 / self.time_step)
        )

        # place cells for initial infection
        locations = list(zip(*np.where(lung_tissue == TissueType.EPITHELIUM)))
        dz_field: np.ndarray = state.grid.delta(axis=0)
        dy_field: np.ndarray = state.grid.delta(axis=1)
        dx_field: np.ndarray = state.grid.delta(axis=2)
        for vox_z, vox_y, vox_x in random.choices(
            locations, k=self.config.getint(&#39;init_infection_num&#39;)
        ):
            # the x,y,z coordinates are in the centers of the grids
            z = state.grid.z[vox_z]
            y = state.grid.y[vox_y]
            x = state.grid.x[vox_x]
            dz = dz_field[vox_z, vox_y, vox_x]
            dy = dy_field[vox_z, vox_y, vox_x]
            dx = dx_field[vox_z, vox_y, vox_x]
            afumigatus.cells.append(
                AfumigatusCellData.create_cell(
                    point=Point(
                        x=x + rg.uniform(-dx / 2, dx / 2),
                        y=y + rg.uniform(-dy / 2, dy / 2),
                        z=z + rg.uniform(-dz / 2, dz / 2),
                    ),
                    iron_pool=afumigatus.init_iron,
                )
            )

        return state

    def advance(self, state: State, previous_time: float) -&gt; State:
        from nlisim.grid import RectangularGrid
        from nlisim.modules.macrophage import MacrophageCellData, MacrophageState, PhagocyteStatus

        afumigatus: AfumigatusState = state.afumigatus
        macrophage: MacrophageState = state.macrophage
        iron: IronState = state.iron
        grid: RectangularGrid = state.grid
        lung_tissue: np.ndarray = state.lung_tissue

        # update live cells
        for afumigatus_cell_index in afumigatus.cells.alive():
            # get cell and voxel position
            afumigatus_cell: AfumigatusCellData = afumigatus.cells[afumigatus_cell_index]
            voxel: Voxel = grid.get_voxel(afumigatus_cell[&#39;point&#39;])

            # ------------ update cell

            cell_self_update(afumigatus, afumigatus_cell, afumigatus_cell_index)

            # ------------ cell growth
            if (
                afumigatus_cell[&#39;state&#39;] == AfumigatusCellState.FREE
                and lung_tissue[tuple(voxel)] != TissueType.AIR
            ):
                elongate(
                    afumigatus_cell, afumigatus_cell_index, afumigatus.iter_to_grow, afumigatus
                )
                if afumigatus_cell[&#39;next_septa&#39;] != -1:  # only branch if we have already elongated
                    branch(afumigatus_cell, afumigatus_cell_index, afumigatus.pr_branch, afumigatus)

            # ------------ interactions after this point

            # interact with macrophages, possibly internalizing the aspergillus cell
            for macrophage_index in macrophage.cells.get_cells_in_voxel(voxel):
                macrophage_cell: MacrophageCellData = macrophage.cells[macrophage_index]

                # Only healthy macrophages can internalize
                if macrophage_cell[&#39;status&#39;] in {
                    PhagocyteStatus.APOPTOTIC,
                    PhagocyteStatus.NECROTIC,
                    PhagocyteStatus.DEAD,
                }:
                    continue

                Afumigatus.fungus_macrophage_interaction(
                    afumigatus=afumigatus,
                    afumigatus_cell=afumigatus_cell,
                    afumigatus_cell_index=afumigatus_cell_index,
                    macrophage=macrophage,
                    macrophage_cell=macrophage_cell,
                    macrophage_cell_index=macrophage_index,
                    iron=iron,
                    grid=grid,
                )

            # -----------

        return state

    @staticmethod
    def fungus_macrophage_interaction(
        afumigatus: AfumigatusState,
        afumigatus_cell: AfumigatusCellData,
        afumigatus_cell_index: int,
        macrophage: &#39;MacrophageState&#39;,
        macrophage_cell: &#39;MacrophageCellData&#39;,
        macrophage_cell_index: int,
        iron: IronState,
        grid: RectangularGrid,
    ):
        from nlisim.modules.macrophage import PhagocyteStatus

        probability_of_interaction = (
            afumigatus.pr_ma_hyphae
            if afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE
            else afumigatus.pr_ma_phag
        )

        # return if they do not interact
        if rg.random() &gt;= probability_of_interaction:
            return

        # now they interact

        interact_with_aspergillus(
            phagocyte_cell=macrophage_cell,
            phagocyte_cell_index=macrophage_cell_index,
            phagocyte_cells=macrophage.cells,
            aspergillus_cell=afumigatus_cell,
            aspergillus_cell_index=afumigatus_cell_index,
            phagocyte=macrophage,
            phagocytize=afumigatus_cell[&#39;status&#39;] != AfumigatusCellStatus.HYPHAE,
        )

        # unlink the fungal cell from its tree
        if (
            afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE
            and macrophage_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE
        ):
            Afumigatus.kill_fungal_cell(
                afumigatus, afumigatus_cell, afumigatus_cell_index, iron, grid
            )

    @staticmethod
    def kill_fungal_cell(
        afumigatus: AfumigatusState,
        afumigatus_cell: AfumigatusCellData,
        afumigatus_cell_index: int,
        iron: IronState,
        grid: RectangularGrid,
    ):
        &#34;&#34;&#34;Kill a fungal cell.

        Unlinks the cell from its fungal tree and releases its iron.
        &#34;&#34;&#34;
        # unlink from any children
        if afumigatus_cell[&#39;next_septa&#39;] != -1:
            next_septa = afumigatus_cell[&#39;next_septa&#39;]
            afumigatus_cell[&#39;next_septa&#39;] = -1
            afumigatus.cells[next_septa][&#39;is_root&#39;] = True
            afumigatus.cells[next_septa][&#39;previous_septa&#39;] = -1
        if afumigatus_cell[&#39;next_branch&#39;] != -1:
            next_branch = afumigatus_cell[&#39;next_branch&#39;]
            afumigatus_cell[&#39;next_branch&#39;] = -1
            afumigatus.cells[next_branch][&#39;is_root&#39;] = True
            afumigatus.cells[next_branch][&#39;previous_septa&#39;] = -1

        # unlink from parent, if exists
        parent_id = afumigatus_cell[&#39;previous_septa&#39;]
        if parent_id != -1:
            afumigatus_cell[&#39;previous_septa&#39;] = -1
            parent_cell: AfumigatusCellData = afumigatus.cells[parent_id]
            if parent_cell[&#39;next_septa&#39;] == afumigatus_cell_index:
                parent_cell[&#39;next_septa&#39;] = -1
            elif parent_cell[&#39;next_branch&#39;] == afumigatus_cell_index:
                parent_cell[&#39;next_branch&#39;] = -1
            else:
                raise AssertionError(&#34;The fungal tree structure is malformed.&#34;)

        # kill the cell off and release its iron
        voxel: Voxel = grid.get_voxel(afumigatus_cell[&#39;point&#39;])
        iron.grid[voxel.z, voxel.y, voxel.x] += afumigatus_cell[&#39;iron_pool&#39;]
        afumigatus_cell[&#39;iron_pool&#39;] = 0.0
        afumigatus_cell[&#39;dead&#39;] = True
        afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.DEAD

    def summary_stats(self, state: State) -&gt; Dict[str, Any]:
        afumigatus: AfumigatusState = state.afumigatus
        live_fungus = afumigatus.cells.alive()

        max_index = max(map(int, AfumigatusCellStatus))
        status_counts = np.bincount(
            np.fromiter(
                (
                    afumigatus.cells[afumigatus_cell_index][&#39;status&#39;]
                    for afumigatus_cell_index in live_fungus
                ),
                dtype=np.uint8,
            ),
            minlength=max_index + 1,
        )

        lip_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.LIP
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        mirb_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.MirB
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        estb_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.EstB
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        tafc_active = int(
            np.sum(
                np.fromiter(
                    (
                        afumigatus.cells[afumigatus_cell_index][&#39;boolean_network&#39;][
                            NetworkSpecies.TAFC
                        ]
                        for afumigatus_cell_index in live_fungus
                    ),
                    dtype=bool,
                )
            )
        )

        return {
            &#39;count&#39;: len(live_fungus),
            &#39;resting conidia&#39;: int(status_counts[AfumigatusCellStatus.RESTING_CONIDIA]),
            &#39;swelling conidia&#39;: int(status_counts[AfumigatusCellStatus.SWELLING_CONIDIA]),
            &#39;sterile conidia&#39;: int(status_counts[AfumigatusCellStatus.STERILE_CONIDIA]),
            &#39;germ tube&#39;: int(status_counts[AfumigatusCellStatus.GERM_TUBE]),
            &#39;hyphae&#39;: int(status_counts[AfumigatusCellStatus.HYPHAE]),
            &#39;LIP active&#39;: lip_active,
            &#39;MirB active&#39;: mirb_active,
            &#39;EstB active&#39;: estb_active,
            &#39;TAFC active&#39;: tafc_active,
        }

    def visualization_data(self, state: State):
        return &#39;cells&#39;, state.afumigatus.cells</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.Afumigatus.MacrophageCellData"><code class="name">var <span class="ident">MacrophageCellData</span></code></dt>
<dd>
<div class="desc"><p>A low-level data contain for an array cells.</p>
<p>This class is a subtype of
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html">numpy.recarray</a>
containing the lowest level representation of a list of "cells" in a
simulation.
The underlying data format of this type are identical to a
simple array of C structures with the fields given in the static "dtype"
variable.</p>
<p>The base class contains only a single coordinate representing the location
of the center of the cell.
Most implementations will want to override this
class to append more fields.
Subclasses must also override the base
implementation of <code>create_cell</code> to construct a single record containing
the additional fields.</p>
<p>For example, the following derived class adds an addition floating point value
associated with each cell.</p>
<pre><code class="language-python">class DerivedCell(CellData):
    FIELDS = CellData.FIELDS + [
        ('iron_content', 'f8')
    ]

    dtype = np.dtype(CellData.FIELDS, align=True)

    @classmethod
    def create_cell_tuple(cls, iron_content=0, **kwargs) -&gt; Tuple:
        return CellData.create_cell_tuple(**kwargs) + (iron_content,)
</code></pre></div>
</dd>
<dt id="nlisim.modules.afumigatus.Afumigatus.MacrophageState"><code class="name">var <span class="ident">MacrophageState</span></code></dt>
<dd>
<div class="desc"><p>Base type intended to store the state for simulation modules.</p>
<p>This class contains serialization support for basic types (float, int, str,
bool) and numpy arrays of those types.
Modules containing more complicated
state must override the serialization mechanism with custom behavior.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nlisim.modules.afumigatus.Afumigatus.fungus_macrophage_interaction"><code class="name flex">
<span>def <span class="ident">fungus_macrophage_interaction</span></span>(<span>afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>, afumigatus_cell: <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a>, afumigatus_cell_index: int, macrophage: MacrophageState, macrophage_cell: MacrophageCellData, macrophage_cell_index: int, iron: <a title="nlisim.modules.iron.IronState" href="iron.html#nlisim.modules.iron.IronState">IronState</a>, grid: <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fungus_macrophage_interaction(
    afumigatus: AfumigatusState,
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
    macrophage: &#39;MacrophageState&#39;,
    macrophage_cell: &#39;MacrophageCellData&#39;,
    macrophage_cell_index: int,
    iron: IronState,
    grid: RectangularGrid,
):
    from nlisim.modules.macrophage import PhagocyteStatus

    probability_of_interaction = (
        afumigatus.pr_ma_hyphae
        if afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE
        else afumigatus.pr_ma_phag
    )

    # return if they do not interact
    if rg.random() &gt;= probability_of_interaction:
        return

    # now they interact

    interact_with_aspergillus(
        phagocyte_cell=macrophage_cell,
        phagocyte_cell_index=macrophage_cell_index,
        phagocyte_cells=macrophage.cells,
        aspergillus_cell=afumigatus_cell,
        aspergillus_cell_index=afumigatus_cell_index,
        phagocyte=macrophage,
        phagocytize=afumigatus_cell[&#39;status&#39;] != AfumigatusCellStatus.HYPHAE,
    )

    # unlink the fungal cell from its tree
    if (
        afumigatus_cell[&#39;status&#39;] == AfumigatusCellStatus.HYPHAE
        and macrophage_cell[&#39;status&#39;] == PhagocyteStatus.ACTIVE
    ):
        Afumigatus.kill_fungal_cell(
            afumigatus, afumigatus_cell, afumigatus_cell_index, iron, grid
        )</code></pre>
</details>
</dd>
<dt id="nlisim.modules.afumigatus.Afumigatus.kill_fungal_cell"><code class="name flex">
<span>def <span class="ident">kill_fungal_cell</span></span>(<span>afumigatus: <a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a>, afumigatus_cell: <a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a>, afumigatus_cell_index: int, iron: <a title="nlisim.modules.iron.IronState" href="iron.html#nlisim.modules.iron.IronState">IronState</a>, grid: <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Kill a fungal cell.</p>
<p>Unlinks the cell from its fungal tree and releases its iron.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def kill_fungal_cell(
    afumigatus: AfumigatusState,
    afumigatus_cell: AfumigatusCellData,
    afumigatus_cell_index: int,
    iron: IronState,
    grid: RectangularGrid,
):
    &#34;&#34;&#34;Kill a fungal cell.

    Unlinks the cell from its fungal tree and releases its iron.
    &#34;&#34;&#34;
    # unlink from any children
    if afumigatus_cell[&#39;next_septa&#39;] != -1:
        next_septa = afumigatus_cell[&#39;next_septa&#39;]
        afumigatus_cell[&#39;next_septa&#39;] = -1
        afumigatus.cells[next_septa][&#39;is_root&#39;] = True
        afumigatus.cells[next_septa][&#39;previous_septa&#39;] = -1
    if afumigatus_cell[&#39;next_branch&#39;] != -1:
        next_branch = afumigatus_cell[&#39;next_branch&#39;]
        afumigatus_cell[&#39;next_branch&#39;] = -1
        afumigatus.cells[next_branch][&#39;is_root&#39;] = True
        afumigatus.cells[next_branch][&#39;previous_septa&#39;] = -1

    # unlink from parent, if exists
    parent_id = afumigatus_cell[&#39;previous_septa&#39;]
    if parent_id != -1:
        afumigatus_cell[&#39;previous_septa&#39;] = -1
        parent_cell: AfumigatusCellData = afumigatus.cells[parent_id]
        if parent_cell[&#39;next_septa&#39;] == afumigatus_cell_index:
            parent_cell[&#39;next_septa&#39;] = -1
        elif parent_cell[&#39;next_branch&#39;] == afumigatus_cell_index:
            parent_cell[&#39;next_branch&#39;] = -1
        else:
            raise AssertionError(&#34;The fungal tree structure is malformed.&#34;)

    # kill the cell off and release its iron
    voxel: Voxel = grid.get_voxel(afumigatus_cell[&#39;point&#39;])
    iron.grid[voxel.z, voxel.y, voxel.x] += afumigatus_cell[&#39;iron_pool&#39;]
    afumigatus_cell[&#39;iron_pool&#39;] = 0.0
    afumigatus_cell[&#39;dead&#39;] = True
    afumigatus_cell[&#39;status&#39;] = AfumigatusCellStatus.DEAD</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.module.ModuleModel" href="../module.html#nlisim.module.ModuleModel">ModuleModel</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleModel.StateClass" href="../module.html#nlisim.module.ModuleModel.StateClass">StateClass</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.advance" href="../module.html#nlisim.module.ModuleModel.advance">advance</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.construct" href="../module.html#nlisim.module.ModuleModel.construct">construct</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.finalize" href="../module.html#nlisim.module.ModuleModel.finalize">finalize</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.initialize" href="../module.html#nlisim.module.ModuleModel.initialize">initialize</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.name" href="../module.html#nlisim.module.ModuleModel.name">name</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.section" href="../module.html#nlisim.module.ModuleModel.section">section</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.summary_stats" href="../module.html#nlisim.module.ModuleModel.summary_stats">summary_stats</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.time_step" href="../module.html#nlisim.module.ModuleModel.time_step">time_step</a></code></li>
<li><code><a title="nlisim.module.ModuleModel.visualization_data" href="../module.html#nlisim.module.ModuleModel.visualization_data">visualization_data</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellData</span></span>
<span>(</span><span>arg: Union[int, Iterable[ForwardRef('CellData')]], initialize: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A low-level data contain for an array cells.</p>
<p>This class is a subtype of
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.recarray.html">numpy.recarray</a>
containing the lowest level representation of a list of "cells" in a
simulation.
The underlying data format of this type are identical to a
simple array of C structures with the fields given in the static "dtype"
variable.</p>
<p>The base class contains only a single coordinate representing the location
of the center of the cell.
Most implementations will want to override this
class to append more fields.
Subclasses must also override the base
implementation of <code>create_cell</code> to construct a single record containing
the additional fields.</p>
<p>For example, the following derived class adds an addition floating point value
associated with each cell.</p>
<pre><code class="language-python">class DerivedCell(CellData):
    FIELDS = CellData.FIELDS + [
        ('iron_content', 'f8')
    ]

    dtype = np.dtype(CellData.FIELDS, align=True)

    @classmethod
    def create_cell_tuple(cls, iron_content=0, **kwargs) -&gt; Tuple:
        return CellData.create_cell_tuple(**kwargs) + (iron_content,)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellData(CellData):
    AFUMIGATUS_FIELDS: CellFields = [
        (&#39;iron_pool&#39;, np.float64),  # units: atto-mol
        (&#39;state&#39;, np.uint8),
        (&#39;status&#39;, np.uint8),
        (&#39;is_root&#39;, bool),
        (&#39;vec&#39;, np.float64, 3),  # unit vector, length is in afumigatus.hyphal_length
        (&#39;activation_iteration&#39;, np.int64),
        (&#39;growth_iteration&#39;, np.int64),
        (&#39;boolean_network&#39;, &#39;b1&#39;, len(NetworkSpecies)),
        (&#39;next_branch&#39;, np.int64),
        (&#39;next_septa&#39;, np.int64),
        (&#39;previous_septa&#39;, np.int64),
        (&#39;bn_iteration&#39;, np.int64),
    ]

    FIELDS = CellData.FIELDS + AFUMIGATUS_FIELDS
    dtype = np.dtype(FIELDS, align=True)  # type: ignore

    @classmethod
    def create_cell_tuple(cls, **kwargs) -&gt; Tuple:
        initializer = {
            &#39;iron_pool&#39;: kwargs.get(&#39;iron_pool&#39;, 0),
            &#39;state&#39;: kwargs.get(&#39;state&#39;, AfumigatusCellState.FREE),
            &#39;status&#39;: kwargs.get(&#39;status&#39;, AfumigatusCellStatus.RESTING_CONIDIA),
            &#39;is_root&#39;: kwargs.get(&#39;is_root&#39;, True),
            &#39;vec&#39;: kwargs.get(&#39;vec&#39;, random_sphere_point()),  # dz, dy, dx
            &#39;activation_iteration&#39;: kwargs.get(&#39;activation_iteration&#39;, 0),
            &#39;growth_iteration&#39;: kwargs.get(&#39;growth_iteration&#39;, 0),
            &#39;boolean_network&#39;: kwargs.get(&#39;boolean_network&#39;, cls.initial_boolean_network()),
            &#39;bn_iteration&#39;: kwargs.get(&#39;bn_iteration&#39;, 0),
            &#39;next_branch&#39;: kwargs.get(&#39;next_branch&#39;, -1),
            &#39;next_septa&#39;: kwargs.get(&#39;next_septa&#39;, -1),
            &#39;previous_septa&#39;: kwargs.get(&#39;previous_septa&#39;, -1),
        }

        # ensure that these come in the correct order
        return CellData.create_cell_tuple(**kwargs) + tuple(
            [initializer[key] for key, *_ in AfumigatusCellData.AFUMIGATUS_FIELDS]
        )

    @classmethod
    def initial_boolean_network(cls) -&gt; np.ndarray:
        init_afumigatus_boolean_species = {
            NetworkSpecies.hapX: True,
            NetworkSpecies.sreA: False,
            NetworkSpecies.HapX: True,
            NetworkSpecies.SreA: False,
            NetworkSpecies.RIA: True,
            NetworkSpecies.EstB: True,
            NetworkSpecies.MirB: True,
            NetworkSpecies.SidA: True,
            NetworkSpecies.TAFC: True,
            NetworkSpecies.ICP: False,
            NetworkSpecies.LIP: False,
            NetworkSpecies.CccA: False,
            NetworkSpecies.FC0fe: True,
            NetworkSpecies.FC1fe: False,
            NetworkSpecies.VAC: False,
            NetworkSpecies.ROS: False,
            NetworkSpecies.Yap1: False,
            NetworkSpecies.SOD2_3: False,
            NetworkSpecies.Cat1_2: False,
            NetworkSpecies.ThP: False,
            NetworkSpecies.Fe: False,
            NetworkSpecies.Oxygen: False,
        }
        return np.asarray(
            [init_afumigatus_boolean_species[species] for species in NetworkSpecies], dtype=bool
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></li>
<li>numpy.ndarray</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.AFUMIGATUS_FIELDS"><code class="name">var <span class="ident">AFUMIGATUS_FIELDS</span> : List[Union[Tuple[str, numpy.dtype], Tuple[str, Type[Any]], Tuple[str, Type[Any], int], Tuple[str, str], Tuple[str, str, int]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellData.initial_boolean_network"><code class="name flex">
<span>def <span class="ident">initial_boolean_network</span></span>(<span>) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initial_boolean_network(cls) -&gt; np.ndarray:
    init_afumigatus_boolean_species = {
        NetworkSpecies.hapX: True,
        NetworkSpecies.sreA: False,
        NetworkSpecies.HapX: True,
        NetworkSpecies.SreA: False,
        NetworkSpecies.RIA: True,
        NetworkSpecies.EstB: True,
        NetworkSpecies.MirB: True,
        NetworkSpecies.SidA: True,
        NetworkSpecies.TAFC: True,
        NetworkSpecies.ICP: False,
        NetworkSpecies.LIP: False,
        NetworkSpecies.CccA: False,
        NetworkSpecies.FC0fe: True,
        NetworkSpecies.FC1fe: False,
        NetworkSpecies.VAC: False,
        NetworkSpecies.ROS: False,
        NetworkSpecies.Yap1: False,
        NetworkSpecies.SOD2_3: False,
        NetworkSpecies.Cat1_2: False,
        NetworkSpecies.ThP: False,
        NetworkSpecies.Fe: False,
        NetworkSpecies.Oxygen: False,
    }
    return np.asarray(
        [init_afumigatus_boolean_species[species] for species in NetworkSpecies], dtype=bool
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellData.FIELDS" href="../cell.html#nlisim.cell.CellData.FIELDS">FIELDS</a></code></li>
<li><code><a title="nlisim.cell.CellData.create_cell" href="../cell.html#nlisim.cell.CellData.create_cell">create_cell</a></code></li>
<li><code><a title="nlisim.cell.CellData.create_cell_tuple" href="../cell.html#nlisim.cell.CellData.create_cell_tuple">create_cell_tuple</a></code></li>
<li><code><a title="nlisim.cell.CellData.dtype" href="../cell.html#nlisim.cell.CellData.dtype">dtype</a></code></li>
<li><code><a title="nlisim.cell.CellData.point_mask" href="../cell.html#nlisim.cell.CellData.point_mask">point_mask</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellList"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellList</span></span>
<span>(</span><span>*, grid: <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a>, max_cells: int = 1000000, cell_data: <a title="nlisim.cell.CellData" href="../cell.html#nlisim.cell.CellData">CellData</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>A python view on top of a CellData array.</p>
<p>This class represents a pythonic interface to the data contained in a
CellData array.
Because the CellData class is a low-level object, it does
not allow dynamically appending new elements.
Objects of this class get
around this limitation by pre-allocating a large block of memory that is
transparently available.
User-facing properties are sliced to make it
appear as if the extra data is not there.</p>
<p>Subclassed types are expected to set the <code>CellDataClass</code> attribute to
a subclass of <code>CellData</code>.
This provides information about the underlying
low-level array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>simulation.grid.RectangularGrid</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>max_cells</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>&nbsp;</dd>
<dt><strong><code>cells</code></strong> :&ensp;<code>simulation.cell.CellData</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Method generated by attrs for class AfumigatusCellList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellList(CellList):
    CellDataClass = AfumigatusCellData</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellList.grid"><code class="name">var <span class="ident">grid</span> : <a title="nlisim.grid.RectangularGrid" href="../grid.html#nlisim.grid.RectangularGrid">RectangularGrid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellList.max_cells"><code class="name">var <span class="ident">max_cells</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.cell.CellList" href="../cell.html#nlisim.cell.CellList">CellList</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.cell.CellList.CellDataClass" href="../cell.html#nlisim.cell.CellList.CellDataClass">CellDataClass</a></code></li>
<li><code><a title="nlisim.cell.CellList.alive" href="../cell.html#nlisim.cell.CellList.alive">alive</a></code></li>
<li><code><a title="nlisim.cell.CellList.append" href="../cell.html#nlisim.cell.CellList.append">append</a></code></li>
<li><code><a title="nlisim.cell.CellList.cell_data" href="../cell.html#nlisim.cell.CellList.cell_data">cell_data</a></code></li>
<li><code><a title="nlisim.cell.CellList.create_from_seed" href="../cell.html#nlisim.cell.CellList.create_from_seed">create_from_seed</a></code></li>
<li><code><a title="nlisim.cell.CellList.extend" href="../cell.html#nlisim.cell.CellList.extend">extend</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_cells_in_voxel" href="../cell.html#nlisim.cell.CellList.get_cells_in_voxel">get_cells_in_voxel</a></code></li>
<li><code><a title="nlisim.cell.CellList.get_neighboring_cells" href="../cell.html#nlisim.cell.CellList.get_neighboring_cells">get_neighboring_cells</a></code></li>
<li><code><a title="nlisim.cell.CellList.load" href="../cell.html#nlisim.cell.CellList.load">load</a></code></li>
<li><code><a title="nlisim.cell.CellList.save" href="../cell.html#nlisim.cell.CellList.save">save</a></code></li>
<li><code><a title="nlisim.cell.CellList.update_voxel_index" href="../cell.html#nlisim.cell.CellList.update_voxel_index">update_voxel_index</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellState"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellState</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellState(IntEnum):
    FREE = 0
    INTERNALIZING = 1
    RELEASING = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellState.FREE"><code class="name">var <span class="ident">FREE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellState.INTERNALIZING"><code class="name">var <span class="ident">INTERNALIZING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellState.RELEASING"><code class="name">var <span class="ident">RELEASING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus"><code class="flex name class">
<span>class <span class="ident">AfumigatusCellStatus</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusCellStatus(IntEnum):
    DEAD = 0
    RESTING_CONIDIA = 1
    SWELLING_CONIDIA = 2
    GERM_TUBE = 3
    HYPHAE = 4
    STERILE_CONIDIA = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus.DEAD"><code class="name">var <span class="ident">DEAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus.GERM_TUBE"><code class="name">var <span class="ident">GERM_TUBE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus.HYPHAE"><code class="name">var <span class="ident">HYPHAE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus.RESTING_CONIDIA"><code class="name">var <span class="ident">RESTING_CONIDIA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus.STERILE_CONIDIA"><code class="name">var <span class="ident">STERILE_CONIDIA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusCellStatus.SWELLING_CONIDIA"><code class="name">var <span class="ident">SWELLING_CONIDIA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState"><code class="flex name class">
<span>class <span class="ident">AfumigatusState</span></span>
<span>(</span><span>*, global_state: State, cells: <a title="nlisim.modules.afumigatus.AfumigatusCellList" href="#nlisim.modules.afumigatus.AfumigatusCellList">AfumigatusCellList</a> = NOTHING)</span>
</code></dt>
<dd>
<div class="desc"><p>Base type intended to store the state for simulation modules.</p>
<p>This class contains serialization support for basic types (float, int, str,
bool) and numpy arrays of those types.
Modules containing more complicated
state must override the serialization mechanism with custom behavior.</p>
<p>Method generated by attrs for class AfumigatusState.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AfumigatusState(ModuleState):
    cells: AfumigatusCellList = attrib(default=attr.Factory(cell_list_factory, takes_self=True))
    pr_ma_hyphae: float  # units: probability
    pr_ma_hyphae_param: float  # units: M
    pr_ma_phag: float  # units: probability
    pr_ma_phag_param: float  # units: M
    pr_branch: float  # units: probability
    steps_to_bn_eval: int  # units: steps
    hyphal_length: float  # units: µm
    hyphae_volume: float  # units: L
    conidia_vol: float  # units: L
    kd_lip: float  # units: aM
    init_iron: float  # units: atto-mol
    time_to_swelling: float  # units: hours
    iter_to_swelling: int  # units: steps
    time_to_germinate: float  # units: hours
    iter_to_germinate: int  # units: steps
    time_to_grow: float  # units: hours
    iter_to_grow: int  # units: steps
    pr_aspergillus_change: float
    rel_phag_affinity_unit_t: float
    phag_affinity_t: float
    aspergillus_change_half_life: float  # units: hours</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.AfumigatusState.aspergillus_change_half_life"><code class="name">var <span class="ident">aspergillus_change_half_life</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.cells"><code class="name">var <span class="ident">cells</span> : <a title="nlisim.modules.afumigatus.AfumigatusCellList" href="#nlisim.modules.afumigatus.AfumigatusCellList">AfumigatusCellList</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.conidia_vol"><code class="name">var <span class="ident">conidia_vol</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.hyphae_volume"><code class="name">var <span class="ident">hyphae_volume</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.hyphal_length"><code class="name">var <span class="ident">hyphal_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.init_iron"><code class="name">var <span class="ident">init_iron</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.iter_to_germinate"><code class="name">var <span class="ident">iter_to_germinate</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.iter_to_grow"><code class="name">var <span class="ident">iter_to_grow</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.iter_to_swelling"><code class="name">var <span class="ident">iter_to_swelling</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.kd_lip"><code class="name">var <span class="ident">kd_lip</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.phag_affinity_t"><code class="name">var <span class="ident">phag_affinity_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.pr_aspergillus_change"><code class="name">var <span class="ident">pr_aspergillus_change</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.pr_branch"><code class="name">var <span class="ident">pr_branch</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.pr_ma_hyphae"><code class="name">var <span class="ident">pr_ma_hyphae</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.pr_ma_hyphae_param"><code class="name">var <span class="ident">pr_ma_hyphae_param</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.pr_ma_phag"><code class="name">var <span class="ident">pr_ma_phag</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.pr_ma_phag_param"><code class="name">var <span class="ident">pr_ma_phag_param</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.rel_phag_affinity_unit_t"><code class="name">var <span class="ident">rel_phag_affinity_unit_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.steps_to_bn_eval"><code class="name">var <span class="ident">steps_to_bn_eval</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.time_to_germinate"><code class="name">var <span class="ident">time_to_germinate</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.time_to_grow"><code class="name">var <span class="ident">time_to_grow</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.AfumigatusState.time_to_swelling"><code class="name">var <span class="ident">time_to_swelling</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="nlisim.module.ModuleState" href="../module.html#nlisim.module.ModuleState">ModuleState</a></b></code>:
<ul class="hlist">
<li><code><a title="nlisim.module.ModuleState.load_attribute" href="../module.html#nlisim.module.ModuleState.load_attribute">load_attribute</a></code></li>
<li><code><a title="nlisim.module.ModuleState.load_state" href="../module.html#nlisim.module.ModuleState.load_state">load_state</a></code></li>
<li><code><a title="nlisim.module.ModuleState.save_attribute" href="../module.html#nlisim.module.ModuleState.save_attribute">save_attribute</a></code></li>
<li><code><a title="nlisim.module.ModuleState.save_state" href="../module.html#nlisim.module.ModuleState.save_state">save_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies"><code class="flex name class">
<span>class <span class="ident">NetworkSpecies</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkSpecies(IntEnum):
    hapX = 0  # gene # noqa: N815
    sreA = 1  # gene # noqa: N815
    HapX = 2  # protein
    SreA = 3  # protein
    RIA = 4
    EstB = 5
    MirB = 6
    SidA = 7
    TAFC = 8
    ICP = 9
    LIP = 10
    CccA = 11
    FC0fe = 12
    FC1fe = 13
    VAC = 14
    ROS = 15
    Yap1 = 16
    SOD2_3 = 17
    Cat1_2 = 18
    ThP = 19
    Fe = 20
    Oxygen = 21</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.Cat1_2"><code class="name">var <span class="ident">Cat1_2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.CccA"><code class="name">var <span class="ident">CccA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.EstB"><code class="name">var <span class="ident">EstB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.FC0fe"><code class="name">var <span class="ident">FC0fe</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.FC1fe"><code class="name">var <span class="ident">FC1fe</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.Fe"><code class="name">var <span class="ident">Fe</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.HapX"><code class="name">var <span class="ident">HapX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.ICP"><code class="name">var <span class="ident">ICP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.LIP"><code class="name">var <span class="ident">LIP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.MirB"><code class="name">var <span class="ident">MirB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.Oxygen"><code class="name">var <span class="ident">Oxygen</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.RIA"><code class="name">var <span class="ident">RIA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.ROS"><code class="name">var <span class="ident">ROS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.SOD2_3"><code class="name">var <span class="ident">SOD2_3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.SidA"><code class="name">var <span class="ident">SidA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.SreA"><code class="name">var <span class="ident">SreA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.TAFC"><code class="name">var <span class="ident">TAFC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.ThP"><code class="name">var <span class="ident">ThP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.VAC"><code class="name">var <span class="ident">VAC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.Yap1"><code class="name">var <span class="ident">Yap1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.hapX"><code class="name">var <span class="ident">hapX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nlisim.modules.afumigatus.NetworkSpecies.sreA"><code class="name">var <span class="ident">sreA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nlisim.modules" href="index.html">nlisim.modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.branch" href="#nlisim.modules.afumigatus.branch">branch</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.cell_list_factory" href="#nlisim.modules.afumigatus.cell_list_factory">cell_list_factory</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.cell_self_update" href="#nlisim.modules.afumigatus.cell_self_update">cell_self_update</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.diffuse_iron" href="#nlisim.modules.afumigatus.diffuse_iron">diffuse_iron</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.elongate" href="#nlisim.modules.afumigatus.elongate">elongate</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.generate_branch_direction" href="#nlisim.modules.afumigatus.generate_branch_direction">generate_branch_direction</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.lip_activation" href="#nlisim.modules.afumigatus.lip_activation">lip_activation</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.process_boolean_network" href="#nlisim.modules.afumigatus.process_boolean_network">process_boolean_network</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.random_sphere_point" href="#nlisim.modules.afumigatus.random_sphere_point">random_sphere_point</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nlisim.modules.afumigatus.Afumigatus" href="#nlisim.modules.afumigatus.Afumigatus">Afumigatus</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.Afumigatus.MacrophageCellData" href="#nlisim.modules.afumigatus.Afumigatus.MacrophageCellData">MacrophageCellData</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.Afumigatus.MacrophageState" href="#nlisim.modules.afumigatus.Afumigatus.MacrophageState">MacrophageState</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.Afumigatus.fungus_macrophage_interaction" href="#nlisim.modules.afumigatus.Afumigatus.fungus_macrophage_interaction">fungus_macrophage_interaction</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.Afumigatus.kill_fungal_cell" href="#nlisim.modules.afumigatus.Afumigatus.kill_fungal_cell">kill_fungal_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellData" href="#nlisim.modules.afumigatus.AfumigatusCellData">AfumigatusCellData</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.AFUMIGATUS_FIELDS" href="#nlisim.modules.afumigatus.AfumigatusCellData.AFUMIGATUS_FIELDS">AFUMIGATUS_FIELDS</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellData.initial_boolean_network" href="#nlisim.modules.afumigatus.AfumigatusCellData.initial_boolean_network">initial_boolean_network</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellList" href="#nlisim.modules.afumigatus.AfumigatusCellList">AfumigatusCellList</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellList.grid" href="#nlisim.modules.afumigatus.AfumigatusCellList.grid">grid</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellList.max_cells" href="#nlisim.modules.afumigatus.AfumigatusCellList.max_cells">max_cells</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellState" href="#nlisim.modules.afumigatus.AfumigatusCellState">AfumigatusCellState</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellState.FREE" href="#nlisim.modules.afumigatus.AfumigatusCellState.FREE">FREE</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellState.INTERNALIZING" href="#nlisim.modules.afumigatus.AfumigatusCellState.INTERNALIZING">INTERNALIZING</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellState.RELEASING" href="#nlisim.modules.afumigatus.AfumigatusCellState.RELEASING">RELEASING</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus" href="#nlisim.modules.afumigatus.AfumigatusCellStatus">AfumigatusCellStatus</a></code></h4>
<ul class="two-column">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus.DEAD" href="#nlisim.modules.afumigatus.AfumigatusCellStatus.DEAD">DEAD</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus.GERM_TUBE" href="#nlisim.modules.afumigatus.AfumigatusCellStatus.GERM_TUBE">GERM_TUBE</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus.HYPHAE" href="#nlisim.modules.afumigatus.AfumigatusCellStatus.HYPHAE">HYPHAE</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus.RESTING_CONIDIA" href="#nlisim.modules.afumigatus.AfumigatusCellStatus.RESTING_CONIDIA">RESTING_CONIDIA</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus.STERILE_CONIDIA" href="#nlisim.modules.afumigatus.AfumigatusCellStatus.STERILE_CONIDIA">STERILE_CONIDIA</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusCellStatus.SWELLING_CONIDIA" href="#nlisim.modules.afumigatus.AfumigatusCellStatus.SWELLING_CONIDIA">SWELLING_CONIDIA</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.AfumigatusState" href="#nlisim.modules.afumigatus.AfumigatusState">AfumigatusState</a></code></h4>
<ul class="">
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.aspergillus_change_half_life" href="#nlisim.modules.afumigatus.AfumigatusState.aspergillus_change_half_life">aspergillus_change_half_life</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.cells" href="#nlisim.modules.afumigatus.AfumigatusState.cells">cells</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.conidia_vol" href="#nlisim.modules.afumigatus.AfumigatusState.conidia_vol">conidia_vol</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.hyphae_volume" href="#nlisim.modules.afumigatus.AfumigatusState.hyphae_volume">hyphae_volume</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.hyphal_length" href="#nlisim.modules.afumigatus.AfumigatusState.hyphal_length">hyphal_length</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.init_iron" href="#nlisim.modules.afumigatus.AfumigatusState.init_iron">init_iron</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.iter_to_germinate" href="#nlisim.modules.afumigatus.AfumigatusState.iter_to_germinate">iter_to_germinate</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.iter_to_grow" href="#nlisim.modules.afumigatus.AfumigatusState.iter_to_grow">iter_to_grow</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.iter_to_swelling" href="#nlisim.modules.afumigatus.AfumigatusState.iter_to_swelling">iter_to_swelling</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.kd_lip" href="#nlisim.modules.afumigatus.AfumigatusState.kd_lip">kd_lip</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.phag_affinity_t" href="#nlisim.modules.afumigatus.AfumigatusState.phag_affinity_t">phag_affinity_t</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.pr_aspergillus_change" href="#nlisim.modules.afumigatus.AfumigatusState.pr_aspergillus_change">pr_aspergillus_change</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.pr_branch" href="#nlisim.modules.afumigatus.AfumigatusState.pr_branch">pr_branch</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.pr_ma_hyphae" href="#nlisim.modules.afumigatus.AfumigatusState.pr_ma_hyphae">pr_ma_hyphae</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.pr_ma_hyphae_param" href="#nlisim.modules.afumigatus.AfumigatusState.pr_ma_hyphae_param">pr_ma_hyphae_param</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.pr_ma_phag" href="#nlisim.modules.afumigatus.AfumigatusState.pr_ma_phag">pr_ma_phag</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.pr_ma_phag_param" href="#nlisim.modules.afumigatus.AfumigatusState.pr_ma_phag_param">pr_ma_phag_param</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.rel_phag_affinity_unit_t" href="#nlisim.modules.afumigatus.AfumigatusState.rel_phag_affinity_unit_t">rel_phag_affinity_unit_t</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.steps_to_bn_eval" href="#nlisim.modules.afumigatus.AfumigatusState.steps_to_bn_eval">steps_to_bn_eval</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.time_to_germinate" href="#nlisim.modules.afumigatus.AfumigatusState.time_to_germinate">time_to_germinate</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.time_to_grow" href="#nlisim.modules.afumigatus.AfumigatusState.time_to_grow">time_to_grow</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.AfumigatusState.time_to_swelling" href="#nlisim.modules.afumigatus.AfumigatusState.time_to_swelling">time_to_swelling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nlisim.modules.afumigatus.NetworkSpecies" href="#nlisim.modules.afumigatus.NetworkSpecies">NetworkSpecies</a></code></h4>
<ul class="two-column">
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.Cat1_2" href="#nlisim.modules.afumigatus.NetworkSpecies.Cat1_2">Cat1_2</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.CccA" href="#nlisim.modules.afumigatus.NetworkSpecies.CccA">CccA</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.EstB" href="#nlisim.modules.afumigatus.NetworkSpecies.EstB">EstB</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.FC0fe" href="#nlisim.modules.afumigatus.NetworkSpecies.FC0fe">FC0fe</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.FC1fe" href="#nlisim.modules.afumigatus.NetworkSpecies.FC1fe">FC1fe</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.Fe" href="#nlisim.modules.afumigatus.NetworkSpecies.Fe">Fe</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.HapX" href="#nlisim.modules.afumigatus.NetworkSpecies.HapX">HapX</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.ICP" href="#nlisim.modules.afumigatus.NetworkSpecies.ICP">ICP</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.LIP" href="#nlisim.modules.afumigatus.NetworkSpecies.LIP">LIP</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.MirB" href="#nlisim.modules.afumigatus.NetworkSpecies.MirB">MirB</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.Oxygen" href="#nlisim.modules.afumigatus.NetworkSpecies.Oxygen">Oxygen</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.RIA" href="#nlisim.modules.afumigatus.NetworkSpecies.RIA">RIA</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.ROS" href="#nlisim.modules.afumigatus.NetworkSpecies.ROS">ROS</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.SOD2_3" href="#nlisim.modules.afumigatus.NetworkSpecies.SOD2_3">SOD2_3</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.SidA" href="#nlisim.modules.afumigatus.NetworkSpecies.SidA">SidA</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.SreA" href="#nlisim.modules.afumigatus.NetworkSpecies.SreA">SreA</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.TAFC" href="#nlisim.modules.afumigatus.NetworkSpecies.TAFC">TAFC</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.ThP" href="#nlisim.modules.afumigatus.NetworkSpecies.ThP">ThP</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.VAC" href="#nlisim.modules.afumigatus.NetworkSpecies.VAC">VAC</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.Yap1" href="#nlisim.modules.afumigatus.NetworkSpecies.Yap1">Yap1</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.hapX" href="#nlisim.modules.afumigatus.NetworkSpecies.hapX">hapX</a></code></li>
<li><code><a title="nlisim.modules.afumigatus.NetworkSpecies.sreA" href="#nlisim.modules.afumigatus.NetworkSpecies.sreA">sreA</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>